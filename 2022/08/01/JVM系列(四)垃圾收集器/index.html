<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/blog/images/favicon32.ico">
  <link rel="icon" type="image/png" sizes="32x32" href="/blog/images/favicon32.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/blog/images/favicon16.ico">
  <link rel="mask-icon" href="/blog/images/favicon32.ico" color="#222">
  <link rel="manifest" href="/blog/images/manifest.json">
  <meta name="msapplication-config" content="/blog/images/browserconfig.xml">

<link rel="stylesheet" href="/blog/css/main.css">


<link rel="stylesheet" href="/blog/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"flyoptimistic.github.io","root":"/blog/","scheme":"Gemini","version":"8.0.0-rc.3","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":true,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":"valine","storage":true,"lazyload":false,"nav":null,"activeClass":"valine"},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

<script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
<link href="//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css" rel="stylesheet">
<style>
  .pace .pace-progress {
    background: #1E92FB; /*进度条颜色*/
    height: 3px;
  }
  .pace .pace-progress-inner {
     box-shadow: 0 0 10px #1E92FB, 0 0 5px     #1E92FB; /*阴影颜色*/
  }
  .pace .pace-activity {
    border-top-color: #1E92FB;    /*上边框颜色*/
    border-left-color: #1E92FB;    /*左边框颜色*/
  }
</style>
  <meta name="description" content="CMS垃圾收集器">
<meta property="og:type" content="article">
<meta property="og:title" content="JVM系列(四)垃圾收集器">
<meta property="og:url" content="https://flyoptimistic.github.io/blog/2022/08/01/JVM%E7%B3%BB%E5%88%97(%E5%9B%9B)%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/index.html">
<meta property="og:site_name" content="北木南的博客">
<meta property="og:description" content="CMS垃圾收集器">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://flyoptimistic.github.io/blog/2022/08/01/JVM%E7%B3%BB%E5%88%97(%E5%9B%9B)%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95.png">
<meta property="og:image" content="https://flyoptimistic.github.io/blog/2022/08/01/JVM%E7%B3%BB%E5%88%97(%E5%9B%9B)%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/%E6%A0%87%E8%AE%B0%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95.jpeg">
<meta property="og:image" content="https://flyoptimistic.github.io/blog/2022/08/01/JVM%E7%B3%BB%E5%88%97(%E5%9B%9B)%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4%E6%B3%95.jpeg">
<meta property="og:image" content="https://flyoptimistic.github.io/blog/2022/08/01/JVM%E7%B3%BB%E5%88%97(%E5%9B%9B)%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/%E6%A0%87%E8%AE%B0%E6%95%B4%E7%90%86%E7%AE%97%E6%B3%95.jpeg">
<meta property="og:image" content="https://flyoptimistic.github.io/blog/2022/08/01/JVM%E7%B3%BB%E5%88%97(%E5%9B%9B)%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8.png">
<meta property="og:image" content="https://flyoptimistic.github.io/blog/2022/08/01/JVM%E7%B3%BB%E5%88%97(%E5%9B%9B)%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/serial%E6%94%B6%E9%9B%86%E5%99%A8.jpeg">
<meta property="og:image" content="https://flyoptimistic.github.io/blog/2022/08/01/JVM%E7%B3%BB%E5%88%97(%E5%9B%9B)%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/parallel%E6%94%B6%E9%9B%86%E5%99%A8.jpeg">
<meta property="og:image" content="https://flyoptimistic.github.io/blog/2022/08/01/JVM%E7%B3%BB%E5%88%97(%E5%9B%9B)%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/parnew%E6%94%B6%E9%9B%86%E5%99%A8.jpeg">
<meta property="og:image" content="https://flyoptimistic.github.io/blog/2022/08/01/JVM%E7%B3%BB%E5%88%97(%E5%9B%9B)%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/CMS%E7%AE%97%E6%B3%95.jpeg">
<meta property="og:image" content="https://flyoptimistic.github.io/blog/2022/08/01/JVM%E7%B3%BB%E5%88%97(%E5%9B%9B)%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/%E7%94%B5%E5%95%86%E8%AE%A2%E5%8D%95%E7%B3%BB%E7%BB%9F.png">
<meta property="og:image" content="https://flyoptimistic.github.io/blog/2022/08/01/JVM%E7%B3%BB%E5%88%97(%E5%9B%9B)%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/%E8%BF%90%E8%A1%8C%E6%97%B6%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.png">
<meta property="og:image" content="https://flyoptimistic.github.io/blog/2022/08/01/JVM%E7%B3%BB%E5%88%97(%E5%9B%9B)%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0.png">
<meta property="og:image" content="https://flyoptimistic.github.io/blog/2022/08/01/JVM%E7%B3%BB%E5%88%97(%E5%9B%9B)%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/%E5%A4%9A%E6%A0%87.webp">
<meta property="og:image" content="https://flyoptimistic.github.io/blog/2022/08/01/JVM%E7%B3%BB%E5%88%97(%E5%9B%9B)%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/%E6%BC%8F%E6%A0%87.webp">
<meta property="og:image" content="https://flyoptimistic.github.io/blog/2022/08/01/JVM%E7%B3%BB%E5%88%97(%E5%9B%9B)%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/%E5%A2%9E%E9%87%8F%E6%9B%B4%E6%96%B0.png">
<meta property="og:image" content="https://flyoptimistic.github.io/blog/2022/08/01/JVM%E7%B3%BB%E5%88%97(%E5%9B%9B)%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/%E5%8E%9F%E5%A7%8B%E5%BF%AB%E7%85%A7.png">
<meta property="og:image" content="https://flyoptimistic.github.io/blog/2022/08/01/JVM%E7%B3%BB%E5%88%97(%E5%9B%9B)%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/%E8%AE%B0%E5%BF%86%E9%9B%86%E4%B8%8E%E5%8D%A1%E8%A1%A8.png">
<meta property="article:published_time" content="2022-08-01T04:00:00.000Z">
<meta property="article:modified_time" content="2022-08-01T05:57:14.498Z">
<meta property="article:author" content="北木南">
<meta property="article:tag" content="JVM">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://flyoptimistic.github.io/blog/2022/08/01/JVM%E7%B3%BB%E5%88%97(%E5%9B%9B)%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95.png">

<link rel="canonical" href="https://flyoptimistic.github.io/blog/2022/08/01/JVM%E7%B3%BB%E5%88%97(%E5%9B%9B)%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>JVM系列(四)垃圾收集器 | 北木南的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
        <span class="toggle-line toggle-line-first"></span>
        <span class="toggle-line toggle-line-middle"></span>
        <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/blog/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">北木南的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/blog/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/blog/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/blog/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/blog/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/blog/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/flyoptimistic" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://flyoptimistic.github.io/blog/2022/08/01/JVM%E7%B3%BB%E5%88%97(%E5%9B%9B)%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.jpg">
      <meta itemprop="name" content="北木南">
      <meta itemprop="description" content="心有猛虎，细嗅蔷薇">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="北木南的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          JVM系列(四)垃圾收集器
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-08-01 12:00:00 / 修改时间：13:57:14" itemprop="dateCreated datePublished" datetime="2022-08-01T12:00:00+08:00">2022-08-01</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/Java/JVM/" itemprop="url" rel="index"><span itemprop="name">JVM</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/blog/2022/08/01/JVM%E7%B3%BB%E5%88%97(%E5%9B%9B)%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/blog/2022/08/01/JVM%E7%B3%BB%E5%88%97(%E5%9B%9B)%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>9.5k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>9 分钟</span>
            </span>
            <div class="post-description">CMS垃圾收集器</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h2><p><img data-src="%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95.png" alt="垃圾收集算法"></p>
<h3 id="分代收集理论"><a href="#分代收集理论" class="headerlink" title="分代收集理论"></a>分代收集理论</h3><p>当前虚拟机的垃圾收集都采用分代收集算法，这种算法没有什么新的思想，只是根据对象存活周期的不同将内存分为几块。一般将java堆分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。</p>
<p>比如在新生代中，每次收集都会有大量对象(近99%)死去，所以可以选择复制算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。而老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集。注意，“标记-清除”或“标记-整理”算法会比复制算法慢10倍以上。</p>
<h3 id="标记-复制算法"><a href="#标记-复制算法" class="headerlink" title="标记-复制算法"></a>标记-复制算法</h3><p>为了解决效率问题，“复制”收集算法出现了。它可以将内存分为大小相同的两块，每次使用其中的一块。当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。这样就使每次的内存回收都是对内存区间的一半进行回收。</p>
<img data-src="标记复制算法.jpeg" alt="标记复制算法" style="zoom: 50%;" />

<h3 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h3><p>算法分为“标记”和“清除”阶段:标记存活的对象,统一回收所有未标记的对象(一般选择这种);也可以反过来,标记出所有需要回收的对象,在标记完成后统一回收所有被标记的对象.它是最基础的收集算法,比较简单,但是会带来两个明显的问题:</p>
<ol>
<li>效率问题(如果需要标记的对象太多,效率不高)</li>
<li>空间问题(标记清除后产生大量不连续的碎片)</li>
</ol>
<img data-src="标记清除法.jpeg" alt="标记清除法" style="zoom:50%;" />

<h3 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h3><p>根据老年代的特点特出的一种标记算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象回收，而是让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存。</p>
<p><img data-src="%E6%A0%87%E8%AE%B0%E6%95%B4%E7%90%86%E7%AE%97%E6%B3%95.jpeg" alt="标记整理算法"></p>
<h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><p><img data-src="%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8.png" alt="垃圾收集器"></p>
<p><strong>如果说收集算法是内存回收的方法论,那么垃圾收集器就是内存回收的具体实现.</strong></p>
<p>虽然我们对各个收集器进行比较，但并非为了挑选出一个最好的收集器。因为直到现在为止还没有最好的垃圾收集器出现，更加没有万能的垃圾收集器，<strong>我们能做的就是根据具体应用场景选择适合自己的垃圾收集器</strong>。试想一下：如果有一种任何场景下都适用的完美收集器存在，那么我们的Java虚拟机就不会实现那么多不同的垃圾收集器了。</p>
<h3 id="Serial收集器-XX-UseSerialGC-XX-UseSerialOldGC"><a href="#Serial收集器-XX-UseSerialGC-XX-UseSerialOldGC" class="headerlink" title="Serial收集器(-XX:+UseSerialGC -XX:+UseSerialOldGC)"></a>Serial收集器(-XX:+UseSerialGC -XX:+UseSerialOldGC)</h3><p>Serial（串行）收集器是最基本、历史最悠久的垃圾收集器了。大家看名字就知道这个收集器是一个单线程收集器了。它的 <strong>“单线程”</strong> 的意义不仅仅意味着它只会使用一条垃圾收集线程去完成垃圾收集工作，更重要的是它在进行垃圾收集工作的时候必须暂停其他所有的工作线程（ <strong>“Stop The World”</strong> ），直到它收集结束。</p>
<p><strong>新生代采用复制算法，老年代采用标记-整理算法。</strong></p>
<p><img data-src="serial%E6%94%B6%E9%9B%86%E5%99%A8.jpeg" alt="serial收集器"></p>
<p>虚拟机的设计者们当然知道Stop The World带来的不良用户体验，所以在后续的垃圾收集器设计中停顿时间在不断缩短（仍然还有停顿，寻找最优秀的垃圾收集器的过程仍然在继续）。</p>
<p>但是Serial收集器有没有优于其他垃圾收集器的地方呢？当然有，它<strong>简单而高效（与其他收集器的单线程相比）</strong>。Serial收集器由于没有线程交互的开销，自然可以获得很高的单线程收集效率。</p>
<p><strong>Serial Old收集器是Serial收集器的老年代版本</strong>，它同样是一个单线程收集器。它主要有两大用途：一种用途是在JDK1.5以及以前的版本中与Parallel Scavenge收集器搭配使用，<strong>另一种用途是作为CMS收集器的后备方案</strong>。</p>
<h3 id="Parallel-Scavenge收集器-XX-UseParallelGC-年轻代-XX-UseParallelOldGC-老年代"><a href="#Parallel-Scavenge收集器-XX-UseParallelGC-年轻代-XX-UseParallelOldGC-老年代" class="headerlink" title="Parallel Scavenge收集器(-XX:+UseParallelGC(年轻代) -XX:+UseParallelOldGC(老年代))"></a>Parallel Scavenge收集器(-XX:+UseParallelGC(年轻代) -XX:+UseParallelOldGC(老年代))</h3><p><strong>Parallel</strong>收集器其实<strong>就是Serial收集器的多线程版本</strong>，除了使用多线程进行垃圾收集外，其余行为（控制参数、收集算法、回收策略等等）和Serial收集器类似。默认的收集线程数跟cpu核数相同，当然也可以用参数(-XX:ParallelGCThreads)指定收集线程数，但是一般不推荐修改。</p>
<p><strong>Parallel Scavenge收集器关注点是吞吐量（高效率的利用CPU）。CMS等垃圾收集器的关注点更多的是用户线程的停顿时间（提高用户体验）。所谓吞吐量就是CPU中用于运行用户代码的时间与CPU总消耗时间的比值。</strong> Parallel Scavenge收集器提供了很多参数供用户找到最合适的停顿时间或最大吞吐量，如果对于收集器运作不太了解的话，可以选择把内存管理优化交给虚拟机去完成也是一个不错的选择。</p>
<p><strong>新生代采用复制算法，老年代采用标记-整理算法。</strong></p>
<p><img data-src="parallel%E6%94%B6%E9%9B%86%E5%99%A8.jpeg" alt="parallel收集器"></p>
<p><strong>Parallel Old收集器是Parallel Scavenge收集器的老年代版本</strong>。使用多线程和“标记-整理”算法。在注重吞吐量以及CPU资源的场合，都可以优先考虑 Parallel Scavenge收集器和Parallel Old收集器(<strong>JDK8默认的新生代和老年代收集器</strong>)。</p>
<h3 id="ParNew收集器-XX-UseParNewGC"><a href="#ParNew收集器-XX-UseParNewGC" class="headerlink" title="ParNew收集器(-XX:+UseParNewGC)"></a>ParNew收集器(-XX:+UseParNewGC)</h3><p>ParNew收集器其实<strong>跟Parallel收集器很类似</strong>，区别主要在于它可以和CMS收集器配合使用。</p>
<p><strong>新生代采用复制算法，老年代采用标记-整理算法。</strong></p>
<p><img data-src="parnew%E6%94%B6%E9%9B%86%E5%99%A8.jpeg" alt="parnew收集器"></p>
<p>它是许多运行在Server模式下的虚拟机的首要选择，除了Serial收集器外，只有它能与CMS收集器（真正意义上的并发收集器，后面会介绍到）配合工作。</p>
<h3 id="CMS收集器-XX-UseConcMarkSweepGC-old"><a href="#CMS收集器-XX-UseConcMarkSweepGC-old" class="headerlink" title="CMS收集器(-XX:+UseConcMarkSweepGC(old))"></a>CMS收集器(-XX:+UseConcMarkSweepGC(old))</h3><p><strong>CMS(Concurrent Mark Sweep)收集器是一种以获取最短回收停顿时间为目标的收集器.它非常符合在注重用户体验的应用上使用,它是HotSpot虚拟机第一款真正意义上的并发收集器,它第一次实现了让垃圾收集器与用户线程(基本上)同时工作.</strong></p>
<p>从名字中的<strong>Mark Sweep</strong>这两个词可以看出，CMS收集器是一种 <strong>“标记-清除”算法</strong>实现的，它的运作过程相比于前面几种垃圾收集器来说更加复杂一些。整个过程分为四个步骤：</p>
<ul>
<li><strong>初始标记</strong>:暂停所有的其他线程(STW),并记录下<strong>GC Roots直接能引用的对象,速度很快.</strong></li>
<li><strong>并发标记</strong>:并发标记阶段就是从<strong>GC Roots的直接关联对象开始遍历整个对象图的过程</strong>,这个过程耗时较长但是不需要停顿用户线程,可以<strong>与垃圾收集线程一起并发运行</strong>.因为用户程序继续运行,可能会有导致已经标记过的对象状态发生改变.</li>
<li><strong>重新标记</strong>:重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录(<strong>主要是处理漏标问题</strong>),这个阶段的停顿时间一般会比初始标记阶段时间稍长,远远比并发标记阶段时间短.<strong>主要用到三色标记里的增量更新算法做重新标记</strong>.</li>
<li><strong>并发清理</strong>:开启用户线程,同时GC线程开始对未标记的区域做清扫.这个阶段如果有新增对象会被标记为黑色不做任何处理(<strong>三色标记算法</strong>)</li>
<li><strong>并发重置</strong>:重置本次GC过程中的标记数据.</li>
</ul>
<p><img data-src="CMS%E7%AE%97%E6%B3%95.jpeg" alt="CMS算法"></p>
<p>从它的名字就可以看出它是一款优秀的垃圾收集器，主要优点：<strong>并发收集、低停顿</strong>。但是它有下面几个明显的缺点：</p>
<ul>
<li><p>对CPU资源敏感（会和服务抢资源）；</p>
</li>
<li><p>无法处理<strong>浮动垃圾</strong>(在并发标记和并发清理阶段又产生垃圾，这种浮动垃圾只能等到下一次gc再清理了)；</p>
</li>
<li><p>它使用的回收算法-<strong>“标记-清除”算法</strong>会导致收集结束时会有<strong>大量空间碎片</strong>产生，当然通过参数-XX:+UseCMSCompactAtFullCollection可以让jvm在执行完标记清除后再做整理</p>
</li>
<li><p>执行过程中的不确定性，会存在上一次垃圾回收还没执行完，然后垃圾回收又被触发的情况，<strong>特别是在并发标记和并发清理阶段会出现</strong>，一边回收，系统一边运行，也许没回收完就再次触发full gc，也就是”<strong>concurrent mode failure</strong>“，<strong>此时会进入stop the world，用serial old垃圾收集器来回收</strong></p>
</li>
</ul>
<p>CMS的相关核心参数:</p>
<ol>
<li>-XX:+UseConcMarkSeepGC:启用CMS</li>
<li>-XX:ConcGCThread:并发的GC线程数</li>
<li>-XX:+UseCMSCompactAtFullCollection:FullGC之后做压缩整理(减少碎片)</li>
<li>-XX:CMSFullGCsBeforeCompaction:多少次FullGC之后压缩一次,默认是0,代表每次FullGC后压缩一次</li>
<li>-XX:CMSInitiatingOccupancyFraction:当老年代使用达到该比例时会触发FullGC(默认时92,单位百分比)</li>
<li>-XX:+UseCMSInitatingOccupancyOnly:只使用设定的回收阈值(-XX:CMSInitiatingOccupancyFraction设定的值),如果不指定,JVM仅在第一次使用设定值,后续则会自动调整</li>
<li>-XX:+CMSScavengeBeforeRemork:在CMS GC前启动一次minor gc,降低CMS GC标记阶段(也会对很多年轻代一起做标记,如果在minor gc就干掉了很多垃圾对象,标记阶段就会减少一些标记时间)时的开销,一般CMS的GC耗时80%都在标记阶段</li>
<li>-XX:+CMSParallelInitalMarkEnabled:表示在初始化标记的时候多线程执行,缩短STW</li>
<li>-XX:+CMSParallelRemarkEnabled:在重新标记的时候多线程执行,缩短STW</li>
</ol>
<h2 id="亿级流量电商系统如何优化JVM参数设置-ParNew-CMS"><a href="#亿级流量电商系统如何优化JVM参数设置-ParNew-CMS" class="headerlink" title="亿级流量电商系统如何优化JVM参数设置(ParNew + CMS)"></a>亿级流量电商系统如何优化JVM参数设置(ParNew + CMS)</h2><p>大型电商系统后端现在一般都是拆分为多个子系统部署的，比如，商品系统，库存系统，订单系统，促销系统，会员系统等等。</p>
<p>我们这里以比较核心的订单系统为例 </p>
<p><img data-src="%E7%94%B5%E5%95%86%E8%AE%A2%E5%8D%95%E7%B3%BB%E7%BB%9F.png" alt="电商订单系统"></p>
<p><strong>对于8G内存，我们一般是分配4G内存给JVM，正常的JVM参数配置如下：</strong></p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">-Xms3072M</span> <span class="string">-Xmx3072M -Xss1M -XX:MetaspaceSize=256M -XX:MaxMetaspaceSize=256M  -XX:SurvivorRatio=8</span></span><br></pre></td></tr></table></figure>

<p>之前说过，这样设置可能会由于动态对象年龄判断原则导致频繁full gc。</p>
<p>于是更新JVM参数设置:</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">-Xms3072M</span> <span class="string">-Xmx3072M -Xmn2048M -Xss1M -XX:MetaspaceSize=256M -XX:MaxMetaspaceSize=256M  -XX:SurvivorRatio=8</span></span><br></pre></td></tr></table></figure>

<img data-src="运行时内存模型.png" alt="运行时内存模型" style="zoom:80%;" />

<p>这样就降低了因为对象动态年龄判断原则导致的对象频繁进入老年代的问题，其实<strong>很多优化无非就是让短期存活的对象尽量都留在survivor里，不要进入老年代，这样在minor gc的时候这些对象都会被回收，不会进到老年代从而导致full gc</strong>。</p>
<p>对于对象年龄应该为多少才移动到老年代比较合适，本例中一次minor gc要间隔二三十秒，大多数对象一般在几秒内就会变为垃圾，完全可以将默认的15岁改小一点，比如改为5，那么意味着对象要经过5次minor gc才会进入老年代，整个时间也有一两分钟了，如果对象这么长时间都没被回收，完全可以认为这些对象是会存活的比较长的对象，可以移动到老年代，而不是继续一直占用survivor区空间。</p>
<p>对于多大的对象直接进入老年代(参数-XX:PretenureSizeThreshold)，这个一般可以结合系统看下有没有什么大对象生成，预估下大对象的大小，一般来说设置为1M就差不多了，很少有超过1M的大对象，这些对象一般就是你系统初始化分配的缓存对象，比如大的缓存List，Map之类的对象。</p>
<p>可以适当调整JVM参数如下：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">-Xms3072M</span> <span class="string">-Xmx3072M -Xmn2048M -Xss1M  -XX:MetaspaceSize=256M -XX:MaxMetaspaceSize=256M  -XX:SurvivorRatio=8  </span></span><br><span class="line"><span class="meta">-XX</span>:<span class="string">MaxTenuringThreshold=5 -XX:PretenureSizeThreshold=1M</span></span><br></pre></td></tr></table></figure>

<p>对于JDK8默认的垃圾回收器是-XX:+UseParallelGC(年轻代)和-XX:+UseParallelOldGC(老年代)，如果内存较大(超过4个G，只是经验值)，系统对停顿时间比较敏感，我们可以使用<strong>ParNew+CMS(</strong>-XX:+UseParNewGC -XX:+UseConcMarkSweepGC<strong>)</strong></p>
<p>对于老年代CMS的参数如何设置我们可以思考下，首先我们想下当前这个系统有哪些对象可能会长期存活躲过5次以上minor gc最终进入老年代。</p>
<p>无非就是那些Spring容器里的Bean，线程池对象，一些初始化缓存数据对象等，这些加起来充其量也就几十MB。</p>
<p>还有就是某次minor gc完了之后还有超过一两百M的对象存活，那么就会直接进入老年代，比如突然某一秒瞬间要处理五六百单，那么每秒生成的对象可能有一百多M，再加上整个系统可能压力剧增，一个订单要好几秒才能处理完，下一秒可能又有很多订单过来。</p>
<p>我们可以估算下大概每隔五六分钟出现一次这样的情况，那么大概半小时到一小时之间就可能因为老年代满了触发一次Full GC，Full GC的触发条件还有我们之前说过的<strong>老年代空间分配担保机制</strong>，历次的minor gc挪动到老年代的对象大小肯定是非常小的，所以几乎不会在minor gc触发之前由于老年代空间分配担保失败而产生full gc，其实在半小时后发生full gc，这时候已经过了抢购的最高峰期，后续可能几小时才做一次FullGC。</p>
<p>对于碎片整理，因为都是1小时或几小时才做一次FullGC，是可以每做完一次就开始碎片整理，或者两到三次之后再做一次也行。</p>
<p>综上，只要年轻代参数设置合理，老年代CMS的参数设置基本都可以用默认值，如下所示：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">-Xms3072M</span> <span class="string">-Xmx3072M -Xmn2048M -Xss1M  -XX:MetaspaceSize=256M -XX:MaxMetaspaceSize=256M  -XX:SurvivorRatio=8 </span></span><br><span class="line"><span class="meta">-XX</span>:<span class="string">MaxTenuringThreshold=5 -XX:PretenureSizeThreshold=1M -XX:+UseParNewGC -XX:+UseConcMarkSweepGC </span></span><br><span class="line"><span class="meta">-XX</span>:<span class="string">CMSInitiatingOccupancyFraction=92 -XX:+UseCMSCompactAtFullCollection -XX:CMSFullGCsBeforeCompaction=3</span></span><br></pre></td></tr></table></figure>

<h2 id="垃圾收集底层算法实现"><a href="#垃圾收集底层算法实现" class="headerlink" title="垃圾收集底层算法实现"></a>垃圾收集底层算法实现</h2><h3 id="三色标记"><a href="#三色标记" class="headerlink" title="三色标记"></a>三色标记</h3><p><strong>在并发标记的过程中,因为标记期间应用线程还在继续跑,对象间的引用可能发生变化,多标和漏标的情况就有可能发生.漏标的问题主要引入了三色标记算法来解决.</strong></p>
<p><strong>三色标记算法是把Gc roots可达性分析遍历对象过程中遇到的对象， 按照“是否访问过”这个条件标记成以下三种颜色：</strong></p>
<ul>
<li><p><strong>黑色</strong>： 表示对象已经被垃圾收集器访问过， 且这个对象的所有引用都已经扫描过。 黑色的对象代表已经扫描过， 它是安全存活的， 如果有其他对象引用指向了黑色对象， 无须重新扫描一遍。 黑色对象不可能直接（不经过灰色对象） 指向某个白色对象。</p>
</li>
<li><p><strong>灰色</strong>： 表示对象已经被垃圾收集器访问过， 但这个对象上至少存在一个引用还没有被扫描过。</p>
</li>
<li><p><strong>白色</strong>： 表示对象尚未被垃圾收集器访问过。 显然在可达性分析刚刚开始的阶段， 所有的对象都是白色的， 若在分析结束的阶段， 仍然是白色的对象， 即代表不可达。</p>
<p><img data-src="%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0.png" alt="三色标记"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 垃圾收集算法细节之三色标记</span></span><br><span class="line"><span class="comment"> * 为了简化例子，代码写法可能不规范，请忽略</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreeColorRemark</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        A a = <span class="keyword">new</span> A();</span><br><span class="line">        <span class="comment">//开始做并发标记</span></span><br><span class="line">        D d = a.b.d;  <span class="comment">//1.读</span></span><br><span class="line">        a.b.d = <span class="keyword">null</span>;   <span class="comment">//2.写</span></span><br><span class="line">        a.d = d;   <span class="comment">//3.写</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    B b = <span class="keyword">new</span> B();</span><br><span class="line">    D d = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">    C c = <span class="keyword">new</span> C();</span><br><span class="line">    D d = <span class="keyword">new</span> D();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="多标-浮动垃圾"><a href="#多标-浮动垃圾" class="headerlink" title="多标-浮动垃圾"></a>多标-浮动垃圾</h3><p>在并发标记过程中，如果由于方法运行结束导致部分局部变量(gcroot)被销毁，这个gcroot引用的对象之前又被扫描过(被标记为非垃圾对象)，那么本轮GC不会回收这部分内存。这部分本应该回收但是没有回收到的内存，被称之为“<strong>浮动垃圾</strong>”。浮动垃圾并不会影响垃圾回收的正确性，只是需要等到下一轮垃圾回收中才被清除。</p>
<p>另外，<strong>针对并发标记(还有并发清理)开始后产生的新对象，通常的做法是直接全部当成黑色</strong>，本轮不会进行清除。这部分对象期间可能也会变为垃圾，这也算是浮动垃圾的一部分。</p>
<p><img data-src="%E5%A4%9A%E6%A0%87.webp" alt="多标"></p>
<h3 id="漏标-读写屏障"><a href="#漏标-读写屏障" class="headerlink" title="漏标-读写屏障"></a>漏标-读写屏障</h3><p>漏标会导致被引用的对象被当成垃圾误删除，这是严重bug，必须解决，有两种解决方案： <strong>增量更新（Incremental Update） 和原始快照（Snapshot At The Beginning，SATB） 。</strong></p>
<p>漏标必须要同时满足以下两个条件：</p>
<ol>
<li>赋值器插入了一条或者多条从黑色对象到白色对象的新引用；</li>
<li>赋值器删除了全部从灰色对象到该白色对象的直接或间接引用。</li>
</ol>
<p><img data-src="%E6%BC%8F%E6%A0%87.webp" alt="漏标"></p>
<h4 id="增量更新"><a href="#增量更新" class="headerlink" title="增量更新"></a>增量更新</h4><p>当黑色对象插入新的指向白色对象的引用关系时， 就将这个新插入的引用记录下来，等并发扫描结束之后， 再将这些记录过的引用关系中的黑色对象为根，重新扫描一次。 这可以简化理解为， <strong>黑色对象一旦新插入了指向白色对象的引用之后， 就把发出引用的对象涂成灰色</strong>。</p>
<img data-src="增量更新.png" alt="增量更新" style="zoom:67%;" />

<h4 id="原始快照"><a href="#原始快照" class="headerlink" title="原始快照"></a>原始快照</h4><p>当灰色对象要删除指向白色对象的引用关系时， 就将这个要删除的引用记录下来， 在并发扫描结束之后， 再将这些记录过的引用关系中的灰色对象为根，重新扫描一次，这样就能扫描到白色的对象，将白色对象直接标记为灰色(<strong>目的就是让这种对象在本轮gc清理中能存活下来，待下一轮gc的时候重新扫描，这个对象也有可能是浮动垃圾</strong>)</p>
<img data-src="原始快照.png" alt="原始快照" style="zoom:67%;" />

<h4 id="写屏障"><a href="#写屏障" class="headerlink" title="写屏障"></a>写屏障</h4><p>以上无论是对引用关系记录的插入还是删除， 虚拟机的记录操作都是通过<strong>写屏障</strong>实现的。 </p>
<p>给某个对象的成员变量赋值时，其底层代码大概长这样：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* @param field 某对象的成员变量，如 a.b.d </span></span><br><span class="line"><span class="comment">* @param new_value 新值，如 null</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">oop_field_store</span><span class="params">(oop* field, oop new_value)</span> </span>&#123; </span><br><span class="line">    *field = new_value; <span class="comment">// 赋值操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所谓的写屏障，其实就是指在赋值操作前后，加入一些处理（可以参考AOP的概念）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">oop_field_store</span><span class="params">(oop* field, oop new_value)</span> </span>&#123;  </span><br><span class="line">    pre_write_barrier(field);          <span class="comment">// 写屏障-写前操作</span></span><br><span class="line">    *field = new_value; </span><br><span class="line">    post_write_barrier(field, value);  <span class="comment">// 写屏障-写后操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="写屏障实现增量更新"><a href="#写屏障实现增量更新" class="headerlink" title="写屏障实现增量更新"></a>写屏障实现增量更新</h5><p>当对象A的成员变量的引用发生变化时，比如新增引用（a.d = d），我们可以利用写屏障，将A<strong>新的成员变量引用</strong>对象D记录下来：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">post_write_barrier</span><span class="params">(oop* field, oop new_value)</span> </span>&#123;  </span><br><span class="line">    remark_set.add(new_value);  <span class="comment">// 记录新引用的对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="写屏障实现SATB"><a href="#写屏障实现SATB" class="headerlink" title="写屏障实现SATB"></a>写屏障实现SATB</h5><p>当对象B的成员变量的引用发生变化时，比如引用消失（a.b.d = null），我们可以利用写屏障，将B<strong>原来成员变量的引用</strong>对象D记录下来：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pre_write_barrier</span><span class="params">(oop* field)</span> </span>&#123;</span><br><span class="line">    oop old_value = *field;    <span class="comment">// 获取旧值</span></span><br><span class="line">    remark_set.add(old_value); <span class="comment">// 记录原来的引用对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="读屏障"><a href="#读屏障" class="headerlink" title="读屏障"></a>读屏障</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">oop <span class="title">oop_field_load</span><span class="params">(oop* field)</span> </span>&#123;</span><br><span class="line">    pre_load_barrier(field); <span class="comment">// 读屏障-读取前操作</span></span><br><span class="line">    <span class="keyword">return</span> *field;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>读屏障是直接针对第一步：D d = a.b.d，当读取成员变量时，一律记录下来：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pre_load_barrier</span><span class="params">(oop* field)</span> </span>&#123;  </span><br><span class="line">    oop old_value = *field;</span><br><span class="line">    remark_set.add(old_value); <span class="comment">// 记录读取到的对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>现代追踪式（可达性分析）的垃圾回收器几乎都借鉴了三色标记的算法思想，尽管实现的方式不尽相同：比如白色/黑色集合一般都不会出现（但是有其他体现颜色的地方）、灰色集合可以通过栈/队列/缓存日志等方式进行实现、遍历方式可以是广度/深度遍历等等。</p>
<p>对于读写屏障，以Java HotSpot VM为例，其并发标记时对漏标的处理方案如下：</p>
<ul>
<li><strong>CMS：写屏障 + 增量更新</strong></li>
<li><strong>G1，Shenandoah：写屏障 + SATB</strong></li>
<li><strong>ZGC：读屏障</strong></li>
</ul>
<p>工程实现中，读写屏障还有其他功能，比如写屏障可以用于记录跨代/区引用的变化，读屏障可以用于支持移动对象的并发执行等。功能之外，还有性能的考虑，所以对于选择哪种，每款垃圾回收器都有自己的想法。</p>
<h4 id="为什么G1用SATB？CMS用增量更新？"><a href="#为什么G1用SATB？CMS用增量更新？" class="headerlink" title="为什么G1用SATB？CMS用增量更新？"></a>为什么G1用SATB？CMS用增量更新？</h4><p><strong>我的理解</strong>：SATB相对增量更新效率会高(当然SATB可能造成更多的浮动垃圾)，因为不需要在重新标记阶段再次深度扫描被删除引用对象，而CMS对增量引用的根对象会做深度扫描，G1因为很多对象都位于不同的region，CMS就一块老年代区域，重新深度扫描对象的话G1的代价会比CMS高，所以G1选择SATB不深度扫描对象，只是简单标记，等到下一轮GC再深度扫描。</p>
<h2 id="记忆集与卡表"><a href="#记忆集与卡表" class="headerlink" title="记忆集与卡表"></a>记忆集与卡表</h2><p>在新生代做GCRoots可达性扫描过程中可能会碰到跨代引用的对象，这种如果又去对老年代再去扫描效率太低了。</p>
<p>为此，在新生代可以引入记录集（<strong>Remember Set</strong>）的数据结构（记录从非收集区到收集区的指针集合），避免把整个老年代加入GCRoots扫描范围。事实上并不只是新生代、 老年代之间才有跨代引用的问题， 所有涉及部分区域收集（Partial GC） 行为的垃圾收集器， 典型的如G1、 ZGC和Shenandoah收集器， 都会面临相同的问题。</p>
<p>垃圾收集场景中，收集器只需通过记忆集判断出某一块非收集区域是否存在指向收集区域的指针即可，无需了解跨代引用指针的全部细节。</p>
<h3 id="跨代引用"><a href="#跨代引用" class="headerlink" title="跨代引用"></a>跨代引用</h3><p>所谓跨代引用就是老年代的对象引用了新生代的对象，或者新生代的对象引用了老年代的对象。那对于这种情况我们的GC在进行扫描的时候不可能直接把我们的整个堆都扫描完，那这样效率也太低了。所以这时候就需要开辟了一小块空间，维护这种引用，而不必让GC扫描整个堆区域。</p>
<h3 id="记忆集"><a href="#记忆集" class="headerlink" title="记忆集"></a>记忆集</h3><p>记忆集也叫rememberSet，垃圾收集器在新生代中建立了记忆集这样的数据结构，用来避免把整个老年代加入到GC ROOTS的扫描范围中。对于记忆集来说，我们可以理解为他是一个抽象类，那么具体实现它的方法将由子类去完成。这里我们简单列举一下实现记忆集的三种方式：<br>1.字长精度<br>2.对象精度<br>3.卡精度（卡表）</p>
<h3 id="卡表"><a href="#卡表" class="headerlink" title="卡表"></a>卡表</h3><p>HotSpot使用一种叫做“卡表”(<strong>Cardtable</strong>)的方式实现记忆集，也是目前最常用的一种方式。关于卡表与记忆集的关系， 可以类比为Java语言中HashMap与Map的关系。</p>
<p>卡表是使用一个字节数组实现：CARD_TABLE[ ]，每个元素对应着其标识的内存区域一块特定大小的内存块，称为“卡页”。</p>
<p>HotSpot使用的卡页是2^9大小，即512字节</p>
<img data-src="记忆集与卡表.png" alt="记忆集与卡表" style="zoom:67%;" />

<p>一个卡页中可包含多个对象，只要有一个对象的字段存在跨代指针，其对应的卡表的元素标识就变成1，表示该元素变脏，否则为0.</p>
<p>GC时，只要筛选本收集区的卡表中变脏的元素加入GCRoots里。</p>
<p><strong>卡表的维护</strong></p>
<p>卡表变脏上面已经说了，但是需要知道如何让卡表变脏，即发生引用字段赋值时，如何更新卡表对应的标识为1。</p>
<p>Hotspot使用<strong>写屏障</strong>维护卡表状态。</p>

    </div>

    
    
    <div>
    
        <div class="end-slogan" style="text-align:center;font-size:13px;letter-spacing:10px;user-select:none;color:#bbb;"><br/>本文结束啦<i class="fa fa-star"></i>感谢您阅读<br/><br/></div>
    
</div> 


<div class="post-body">
  <div class="note primary">
    <div class="recommended_posts">
      
      
        <h4>推荐文章</h4>
        <ul>
          
            <li><a href="https://flyoptimistic.github.io/blog/2022/08/01/JVM%E7%B3%BB%E5%88%97(%E4%BA%94)%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8G1%E5%92%8CZGC/">JVM系列(五)垃圾收集器G1和ZGC</a></li>
          
            <li><a href="https://flyoptimistic.github.io/blog/2022/08/01/JVM%E7%B3%BB%E5%88%97(%E4%B8%89)JVM%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E6%9C%BA%E5%88%B6%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90/">JVM系列(三)JVM对象创建与内存分配机制深度剖析</a></li>
          
            <li><a href="https://flyoptimistic.github.io/blog/2022/05/01/Bloom%20Filter/">Bloom Filter</a></li>
          
            <li><a href="https://flyoptimistic.github.io/blog/2022/05/01/Redis/">Redis</a></li>
          
        </ul>
       
    </div> 
  </div>
</div>





      <footer class="post-footer">
          <div class="post-tags">
              <a href="/blog/tags/JVM/" rel="tag"><i class="fa fa-tag"></i> JVM</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/blog/2022/05/01/Bloom%20Filter/" rel="prev" title="Bloom Filter">
      <i class="fa fa-chevron-left"></i> Bloom Filter
    </a></div>
      <div class="post-nav-item">
    <a href="/blog/2022/08/01/JVM%E7%B3%BB%E5%88%97(%E4%B8%89)JVM%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E6%9C%BA%E5%88%B6%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90/" rel="next" title="JVM系列(三)JVM对象创建与内存分配机制深度剖析">
      JVM系列(三)JVM对象创建与内存分配机制深度剖析 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#垃圾收集算法"><span class="nav-number">1.</span> <span class="nav-text">垃圾收集算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#分代收集理论"><span class="nav-number">1.1.</span> <span class="nav-text">分代收集理论</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#标记-复制算法"><span class="nav-number">1.2.</span> <span class="nav-text">标记-复制算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#标记-清除算法"><span class="nav-number">1.3.</span> <span class="nav-text">标记-清除算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#标记-整理算法"><span class="nav-number">1.4.</span> <span class="nav-text">标记-整理算法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#垃圾收集器"><span class="nav-number">2.</span> <span class="nav-text">垃圾收集器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Serial收集器-XX-UseSerialGC-XX-UseSerialOldGC"><span class="nav-number">2.1.</span> <span class="nav-text">Serial收集器(-XX:+UseSerialGC -XX:+UseSerialOldGC)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Parallel-Scavenge收集器-XX-UseParallelGC-年轻代-XX-UseParallelOldGC-老年代"><span class="nav-number">2.2.</span> <span class="nav-text">Parallel Scavenge收集器(-XX:+UseParallelGC(年轻代) -XX:+UseParallelOldGC(老年代))</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ParNew收集器-XX-UseParNewGC"><span class="nav-number">2.3.</span> <span class="nav-text">ParNew收集器(-XX:+UseParNewGC)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CMS收集器-XX-UseConcMarkSweepGC-old"><span class="nav-number">2.4.</span> <span class="nav-text">CMS收集器(-XX:+UseConcMarkSweepGC(old))</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#亿级流量电商系统如何优化JVM参数设置-ParNew-CMS"><span class="nav-number">3.</span> <span class="nav-text">亿级流量电商系统如何优化JVM参数设置(ParNew + CMS)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#垃圾收集底层算法实现"><span class="nav-number">4.</span> <span class="nav-text">垃圾收集底层算法实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#三色标记"><span class="nav-number">4.1.</span> <span class="nav-text">三色标记</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#多标-浮动垃圾"><span class="nav-number">4.2.</span> <span class="nav-text">多标-浮动垃圾</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#漏标-读写屏障"><span class="nav-number">4.3.</span> <span class="nav-text">漏标-读写屏障</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#增量更新"><span class="nav-number">4.3.1.</span> <span class="nav-text">增量更新</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#原始快照"><span class="nav-number">4.3.2.</span> <span class="nav-text">原始快照</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#写屏障"><span class="nav-number">4.3.3.</span> <span class="nav-text">写屏障</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#写屏障实现增量更新"><span class="nav-number">4.3.3.1.</span> <span class="nav-text">写屏障实现增量更新</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#写屏障实现SATB"><span class="nav-number">4.3.3.2.</span> <span class="nav-text">写屏障实现SATB</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#读屏障"><span class="nav-number">4.3.4.</span> <span class="nav-text">读屏障</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#总结"><span class="nav-number">4.3.5.</span> <span class="nav-text">总结</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#为什么G1用SATB？CMS用增量更新？"><span class="nav-number">4.3.6.</span> <span class="nav-text">为什么G1用SATB？CMS用增量更新？</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#记忆集与卡表"><span class="nav-number">5.</span> <span class="nav-text">记忆集与卡表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#跨代引用"><span class="nav-number">5.1.</span> <span class="nav-text">跨代引用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#记忆集"><span class="nav-number">5.2.</span> <span class="nav-text">记忆集</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#卡表"><span class="nav-number">5.3.</span> <span class="nav-text">卡表</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="北木南"
      src="/blog/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">北木南</p>
  <div class="site-description" itemprop="description">心有猛虎，细嗅蔷薇</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/blog/archives/">
        
          <span class="site-state-item-count">21</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/blog/categories/">
          
        <span class="site-state-item-count">16</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/blog/tags/">
          
        <span class="site-state-item-count">24</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/flyoptimistic" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;flyoptimistic" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



      </div>
        
      <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=425065829&auto=1&height=66"></iframe>
    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">北木南</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">166k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">2:31</span>
</div>
  <div class="addthis_inline_share_toolbox">
    <script src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5eeb31b88c2ca90e" async="async"></script>
  </div>
<!-- 网站运行时间的设置 -->
<span id="timeDate">载入天数...</span>
<span id="times">载入时分秒...</span> 
<script>
    var now = new Date();
    function createtime() {
        var grt= new Date("06/06/2020 00:00:00");//此处修改你的建站时间或者网站上线时间
        now.setTime(now.getTime()+250);
        days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days);
        hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours);
        if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);
        mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;}
        seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);
        snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;}
        document.getElementById("timeDate").innerHTML = "本站已安全运行 "+dnum+" 天 ";
        document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒";
}
setInterval("createtime()",250);
</script>

        
<div class="busuanzi-count">
  <script type="text/javascript" src="/blog/js/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/blog/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/medium-zoom@1/dist/medium-zoom.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/lozad@1/dist/lozad.min.js"></script>
  <script src="/blog/lib/velocity/velocity.min.js"></script>
  <script src="/blog/lib/velocity/velocity.ui.min.js"></script>

<script src="/blog/js/utils.js"></script>

<script src="/blog/js/motion.js"></script>


<script src="/blog/js/schemes/pisces.js"></script>


<script src="/blog/js/next-boot.js"></script>




  




  
<script src="/blog/js/local-search.js"></script>













  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/valine@1/dist/Valine.min.js', () => {
    new Valine(Object.assign({
      el  : '#valine-comments',
      path: location.pathname,
    }, {"enable":true,"appId":"fsagXprAM5QyVKnRG1Jxjf1R-MdYXbMMI","appKey":"AN87Gpbv5TwPut3dUmPWjEnQ","placeholder":"来都来了，留下点宝贵建议吧！","avatar":"mm","meta":["nick","mail","link"],"pageSize":10,"language":null,"visitor":false,"comment_count":true,"recordIP":false,"serverURLs":null}
    ));
  }, window.Valine);
});
</script>

  
<script src="/blog/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/blog/live2dw/assets/z16.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":false},"react":{"opacity":0.7},"log":false});</script></body>
</html>
<script type="text/javascript" src="/blog/js/clicklove.js"></script>

<script type="text/javascript" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>


