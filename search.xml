<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Bloom Filter</title>
    <url>/blog/2022/05/01/Bloom%20Filter/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/blog/assets/css/APlayer.min.css"><script src="/blog/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Bloom-Filter"><a href="#Bloom-Filter" class="headerlink" title="Bloom Filter"></a>Bloom Filter</h1><p>布隆过滤器（英语：Bloom Filter）是1970年由一个叫布隆的小伙子提出的。它实际上是一个很长的二进制向量和一系列随机映射函数。布隆过滤器可以用于检索一个元素是否在一个集合中。它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难。</p>
<a id="more"></a>

<h2 id="Bloom-Filter-原理"><a href="#Bloom-Filter-原理" class="headerlink" title="Bloom Filter 原理"></a>Bloom Filter 原理</h2><p>布隆过滤器的原理是，当一个元素被加入集合时，通过K个散列函数将这个元素映射成一个位数组中的K个点，把它们置为1。检索时，我们只要看看这些点是不是都是1就（大约）知道集合中有没有它了：如果这些点有任何一个0，则被检元素一定不在；如果都是1，则被检元素很可能在。这就是布隆过滤器的基本思想。</p>
<p>Bloom Filter跟单哈希函数Bit-Map不同之处在于：Bloom Filter使用了k个哈希函数，每个字符串跟k个bit对应。从而降低了冲突的概率。<img data-src="%E8%BF%87%E6%BB%A4%E5%99%A8%E5%8E%9F%E7%90%86.jpg" alt="过滤器原理"></p>
<p>简单的说一下就是我们先把我们数据库的数据都加载到我们的过滤器中，比如数据库的id现在有：1、2、3</p>
<p>那就用id：1 为例子他在上图中经过三次hash之后，把三次原本值0的地方改为1</p>
<p>下次我进来查询如果id也是1 那我就把1拿去三次hash 发现跟上面的三个位置完全一样，那就能证明过滤器中有1的</p>
<p>反之如果不一样就说明不存在了</p>
<p>那应用的场景在哪里呢？一般我们都会用来防止缓存击穿。</p>
<p>简单来说就是你数据库的id都是1开始然后自增的，那我知道你接口是通过id查询的，我就拿负数去查询，这个时候，会发现缓存里面没这个数据，我又去数据库查也没有，一个请求这样，100个，1000个，10000个呢？你的DB基本上就扛不住了，如果在缓存里面加上这个，是不是就不存在了，你判断没这个数据就不去查了，直接return一个数据为空不就好了嘛。</p>
<p>这玩意这么好使那有啥缺点么？有的，我们接着往下看</p>
<h2 id="Bloom-Filter的缺点"><a href="#Bloom-Filter的缺点" class="headerlink" title="Bloom Filter的缺点"></a>Bloom Filter的缺点</h2><p>bloom filter之所以能做到在时间和空间上的效率比较高，是因为牺牲了判断的准确率、删除的便利性</p>
<ul>
<li>存在误判，可能要查到的元素并没有在容器中，但是hash之后得到的k个位置上值都是1。如果bloom filter中存储的是黑名单，那么可以通过建立一个白名单来存储可能会误判的元素。</li>
<li>删除困难。一个放入容器的元素映射到bit数组的k个位置上是1，删除的时候不能简单的直接置为0，可能会影响其他元素的判断。可以采用<a href="http://wiki.corp.qunar.com/confluence/download/attachments/199003276/US9740797.pdf?version=1&modificationDate=1526538500000&api=v2" target="_blank" rel="noopener">Counting Bloom Filter</a></li>
</ul>
<h2 id="Bloom-Filter-实现"><a href="#Bloom-Filter-实现" class="headerlink" title="Bloom Filter 实现"></a>Bloom Filter 实现</h2><p>布隆过滤器有许多实现与优化，Guava中就提供了一种Bloom Filter的实现。</p>
<p>在使用bloom filter时，绕不过的两点是预估数据量n以及期望的误判率fpp，</p>
<p>在实现bloom filter时，绕不过的两点就是hash函数的选取以及bit数组的大小。</p>
<p>对于一个确定的场景，我们预估要存的数据量为n，期望的误判率为fpp，然后需要计算我们需要的Bit数组的大小m，以及hash函数的个数k，并选择hash函数</p>
<h3 id="Bit数组大小选择"><a href="#Bit数组大小选择" class="headerlink" title="Bit数组大小选择"></a>Bit数组大小选择</h3><p>根据预估数据量n以及误判率fpp，bit数组大小的m的计算方式：<img data-src="bit%E6%95%B0%E7%BB%84.png" alt="bit数组"></p>
<h3 id="哈希函数选择"><a href="#哈希函数选择" class="headerlink" title="哈希函数选择"></a>哈希函数选择</h3><p>由预估数据量n以及bit数组长度m，可以得到一个hash函数的个数k：<img data-src="hash%E6%95%B0%E7%BB%84.png" alt="hash数组"></p>
<p>哈希函数的选择对性能的影响应该是很大的，一个好的哈希函数要能近似等概率的将字符串映射到各个Bit。选择k个不同的哈希函数比较麻烦，一种简单的方法是选择一个哈希函数，然后送入k个不同的参数。</p>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">BloomFilter&lt;T&gt; <span class="title">create</span><span class="params">(Funnel&lt;? <span class="keyword">super</span> T&gt; funnel, <span class="keyword">int</span> expectedInsertions)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> create(funnel, (<span class="keyword">long</span>) expectedInsertions);</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">BloomFilter&lt;T&gt; <span class="title">create</span><span class="params">(Funnel&lt;? <span class="keyword">super</span> T&gt; funnel, <span class="keyword">long</span> expectedInsertions)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> create(funnel, expectedInsertions, <span class="number">0.03</span>); <span class="comment">// FYI, for 3%, we always get 5 hash functions</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">BloomFilter&lt;T&gt; <span class="title">create</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    Funnel&lt;? <span class="keyword">super</span> T&gt; funnel, <span class="keyword">long</span> expectedInsertions, <span class="keyword">double</span> fpp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> create(funnel, expectedInsertions, fpp, BloomFilterStrategies.MURMUR128_MITZ_64);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &lt;T&gt; <span class="function">BloomFilter&lt;T&gt; <span class="title">create</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    Funnel&lt;? <span class="keyword">super</span> T&gt; funnel, <span class="keyword">long</span> expectedInsertions, <span class="keyword">double</span> fpp, Strategy strategy)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>BloomFilter一共四个create方法，不过最终都是走向第四个。看一下每个参数的含义：</p>
<p>funnel：数据类型(一般是调用Funnels工具类中的)</p>
<p>expectedInsertions：期望插入的值的个数</p>
<p>fpp 错误率(默认值为0.03)</p>
<p>strategy 哈希算法</p>
<h3 id="错误率越大，所需空间和时间越小，错误率越小，所需空间和时间约大"><a href="#错误率越大，所需空间和时间越小，错误率越小，所需空间和时间约大" class="headerlink" title="错误率越大，所需空间和时间越小，错误率越小，所需空间和时间约大"></a>错误率越大，所需空间和时间越小，错误率越小，所需空间和时间约大</h3><h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><ul>
<li>cerberus在收集监控数据的时候, 有的系统的监控项量会很大, 需要检查一个监控项的名字是否已经被记录到db过了, 如果没有的话就需要写入db.</li>
<li>爬虫过滤已抓到的url就不再抓，可用bloom filter过滤</li>
<li>垃圾邮件过滤。如果用哈希表，每存储一亿个 email地址，就需要 1.6GB的内存（用哈希表实现的具体办法是将每一个 email地址对应成一个八字节的信息指纹，然后将这些信息指纹存入哈希表，由于哈希表的存储效率一般只有 50%，因此一个 email地址需要占用十六个字节。一亿个地址大约要 1.6GB，即十六亿字节的内存）。因此存贮几十亿个邮件地址可能需要上百 GB的内存。而Bloom Filter只需要哈希表 1/8到 1/4 的大小就能解决同样的问题。</li>
</ul>
]]></content>
      <categories>
        <category>数据库</category>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>GitPages和Hexo搭建个人博客</title>
    <url>/blog/2020/06/17/GitPages%E5%92%8CHexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/blog/assets/css/APlayer.min.css"><script src="/blog/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="为什么要写个人博客？"><a href="#为什么要写个人博客？" class="headerlink" title="为什么要写个人博客？"></a>为什么要写个人博客？</h2><ul>
<li><strong>个人空间</strong>：科技发展迅猛的情况下，网民日益增加，在这个流量为王的时代，通过个人博客来提高自己的知名度，打造个人品牌能为自己带来更多的益处。</li>
<li><strong>学无止境</strong>：学如逆水行舟，不进则退。在行业竞争力日益激烈的情况下，通过运营个人博客来让自己的知识不断增长，避免成为时代落伍，淘汰的那部分人。通过记录博客让自己对知识的理解更加深刻,同时可以当做备忘录的存在，好记性不如写博客。</li>
</ul>
<a id="more"></a>

<ul>
<li><strong>增强文采</strong>：作为IT行业的猿类已经日益被社会绝大多数人冠上”人傻“，”直男“的称号，通过文字记录博客，能加强自己的文采，同时一定会有各行各业大佬提出不同的质疑，正是这个不断沟通交流思考的过程增强自己的沟通能力，有可能让自己成为所谓的”暖(zha)男“.</li>
<li><strong>工作机会</strong>：求职前一定会准备一份由自己精心打造的简历，简历决定了第一印象，简历中加入自己的博客无疑会为自己加分不少。</li>
</ul>
<h2 id="个人博客到底是什么？"><a href="#个人博客到底是什么？" class="headerlink" title="个人博客到底是什么？"></a>个人博客到底是什么？</h2><ul>
<li><p><strong>域名</strong>：地址，因为ip地址是一长串数字且不直观所以为了方便记忆发明一套字符型地址方案。描述网站具体位置。</p>
</li>
<li><p><strong>服务器</strong>：存储网站资源的容器。</p>
</li>
<li><p><strong>博客系统</strong>:让用户在互联网上建立个人博客的系统，包含了构建，发布，管理等一系列操作。</p>
<p>博客本质是一个web网站，大致流程为：客户端通过浏览器中输入地址发起请求，根据地址去请求资源，并在获取到资源后展示在当前浏览器。</p>
<ol>
<li><strong>DNS域名解析</strong>：客户端去解析域名，确认对应服务器。</li>
<li><strong>建立连接</strong>：客户端与服务器连接。<a href="https://baike.baidu.com/item/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B/5111559?fr=aladdin" target="_blank" rel="noopener">三次握手</a></li>
<li><strong>发送请求</strong>：客户端发送请求报文。</li>
<li><strong>服务器处理请求</strong>：服务器处理请求，查询数据，获取到相应资源。</li>
<li><strong>返回响应结果</strong>：服务器返回响应结果给客户端。</li>
<li><strong>关闭连接</strong></li>
<li><strong>浏览器解析HTML</strong>：浏览器解析html，css，js。加载静态资源（图片，视频等）。</li>
<li><strong>浏览器布局渲染</strong>：展示给用户。</li>
</ol>
</li>
</ul>
<p>​     具体流程请自行查看 <a href="https://zhuanlan.zhihu.com/p/31311964" target="_blank" rel="noopener">细说浏览器输入URL后发生了什么</a>，此处不过多赘述。</p>
<h2 id="怎么搭建个人博客？"><a href="#怎么搭建个人博客？" class="headerlink" title="怎么搭建个人博客？"></a>怎么搭建个人博客？</h2><h3 id="搭建环境"><a href="#搭建环境" class="headerlink" title="搭建环境"></a>搭建环境</h3><h4 id="Git：下载地址"><a href="#Git：下载地址" class="headerlink" title="Git：下载地址"></a><strong>Git</strong>：<a href="https://git-scm.com/download/win" target="_blank" rel="noopener">下载地址</a></h4><h4 id="NodeJs：下载地址"><a href="#NodeJs：下载地址" class="headerlink" title="NodeJs：下载地址"></a><strong>NodeJs</strong>：<a href="http://nodejs.cn/download/" target="_blank" rel="noopener">下载地址</a></h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">检查是否安装成功</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> node —version</span></span><br></pre></td></tr></table></figure>

<h4 id="Hexo：中文文档"><a href="#Hexo：中文文档" class="headerlink" title="Hexo：中文文档"></a><strong>Hexo</strong>：<a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">中文文档</a></h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">安装</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> npm install -g hexo-cli</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看是否安装成功，查看版本号</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> hexo -v</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 安装 Hexo 完成后，请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> hexo init &lt;folder&gt;</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> &lt;folder&gt;</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> npm install</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 清除缓存，和已生成的静态文件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> hexo clean</span></span><br><span class="line"><span class="meta">#</span><span class="bash">生成静态文件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> hexo generate</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动,默认访问：http://localhost:4000/</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> hexo server</span></span><br></pre></td></tr></table></figure>

<h4 id="GithubPages：Github提供的免费站点服务，自带域名和1G免费空间"><a href="#GithubPages：Github提供的免费站点服务，自带域名和1G免费空间" class="headerlink" title="GithubPages：Github提供的免费站点服务，自带域名和1G免费空间"></a>GithubPages：Github提供的免费站点服务，自带域名和1G免费空间</h4><h5 id="新建博客仓库：github新建一个名为你的用户名-github-io的repository，这样做的好处是避免生成的域名太长-具体可执行："><a href="#新建博客仓库：github新建一个名为你的用户名-github-io的repository，这样做的好处是避免生成的域名太长-具体可执行：" class="headerlink" title="新建博客仓库：github新建一个名为你的用户名.github.io的repository，这样做的好处是避免生成的域名太长,具体可执行："></a><strong>新建博客仓库</strong>：github新建一个名为<code>你的用户名.github.io</code>的repository，这样做的好处是避免生成的域名太长,具体可执行：<img data-src="%E6%96%B0%E5%BB%BAGitPages%E4%BB%93%E5%BA%93.png" alt="image-20200610180036253"></h5><h5 id="部署到GitPages"><a href="#部署到GitPages" class="headerlink" title="部署到GitPages"></a><strong>部署到GitPages</strong></h5><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#修改hexo子目录中config.yml</span></span><br><span class="line"><span class="attr">deploy</span>:<span class="string"></span></span><br><span class="line">   <span class="attr">type</span>: <span class="string">git</span></span><br><span class="line">   <span class="attr">repository</span>: <span class="string">https://github.com/flyoptimistic/.github.io.git</span></span><br><span class="line">   <span class="attr">branch</span>: <span class="string">master   </span></span><br><span class="line"><span class="comment">#安装插件</span></span><br><span class="line"><span class="meta">$</span> <span class="string">npm install hexo-deployer-git —save</span></span><br><span class="line"><span class="comment">#执行以下命令发布本地博客到远程仓库</span></span><br><span class="line"><span class="meta">$</span> <span class="string">hexo deploy</span></span><br></pre></td></tr></table></figure>

<h2 id="怎么优化Hexo博客页面？"><a href="#怎么优化Hexo博客页面？" class="headerlink" title="怎么优化Hexo博客页面？"></a>怎么优化Hexo博客页面？</h2><p>此处都以next主题为例，如需别的主题可以点击<a href="https://hexo.io/themes/" target="_blank" rel="noopener">这里</a></p>
<h3 id="了解文件目录"><a href="#了解文件目录" class="headerlink" title="了解文件目录"></a>了解文件目录</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── _config.yml   	#配置文件</span><br><span class="line">├── package.json	#应用程序的信息</span><br><span class="line">├── scaffolds		#模版 文件夹</span><br><span class="line">├── source  		#资源文件夹是存放用户资源的地方</span><br><span class="line">|   ├── _drafts</span><br><span class="line">|   └── _posts		#生成的文章</span><br><span class="line">└── themes			#主题 文件夹</span><br></pre></td></tr></table></figure>

<h3 id="安装Next主题：官网"><a href="#安装Next主题：官网" class="headerlink" title="安装Next主题：官网"></a>安装Next主题：<a href="https://theme-next.org/" target="_blank" rel="noopener">官网</a></h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">切换到blog文件夹下（就是hexo init的文件夹）</span></span><br><span class="line">cd [blog]</span><br><span class="line"><span class="meta">#</span><span class="bash">通过git安装 注意：此处next版本为8.0,如需别的版本请自行去github上查找。</span></span><br><span class="line">git clone https://github.com/next-theme/hexo-theme-next.git themes/next</span><br><span class="line"><span class="meta">#</span><span class="bash">切换到next主题：hexo根目录下编辑_config.yml文件</span></span><br><span class="line">theme: next</span><br><span class="line"><span class="meta">#</span><span class="bash">切换后，用命令清除下缓存</span></span><br><span class="line">hexo clean</span><br><span class="line">hexo generate</span><br><span class="line"><span class="meta">#</span><span class="bash">执行hexo s本地产看NexT主题效果</span></span><br><span class="line">hexo server</span><br></pre></td></tr></table></figure>

<h3 id="主题设定"><a href="#主题设定" class="headerlink" title="主题设定"></a>主题设定</h3><p>next目录下<strong>_config.yml</strong>文件 ：选择 Scheme</p>
<p>Scheme 是 NexT 提供的一种特性，借助于 Scheme，NexT 为你提供多种不同的外观。</p>
<ul>
<li>Muse - 默认 Scheme，这是 NexT 最初的版本，黑白主调，大量留白</li>
<li>Mist - Muse 的紧凑版本，整洁有序的单栏外观</li>
<li>Pisces - 双栏 Scheme，小家碧玉似的清新</li>
</ul>
<p>Scheme 的切换通过更改 <strong>主题配置文件</strong>，搜索 scheme 关键字。 你会看到有三行 scheme 的配置，将你需用启用的 scheme 前面注释 <code>#</code> 去除即可。</p>
<h3 id="站点配置文件：文件位置：-config-yml-官网文档"><a href="#站点配置文件：文件位置：-config-yml-官网文档" class="headerlink" title="站点配置文件：文件位置：~/_config.yml 官网文档"></a>站点配置文件：文件位置：~/_config.yml <a href="https://hexo.io/docs/configuration.html" target="_blank" rel="noopener">官网文档</a></h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 网站标题、副标题、网站描述、关键词、作者、语言等基本信息的配置</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">北木南的博客</span></span><br><span class="line"><span class="attr">subtitle:</span> <span class="string">''</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">'心有猛虎，细嗅蔷薇'</span></span><br><span class="line"><span class="attr">keywords:</span></span><br><span class="line"><span class="attr">author:</span> <span class="string">北木南</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">zh-CN</span>  </span><br><span class="line"><span class="attr">timezone:</span> <span class="string">Asia/Shanghai</span></span><br><span class="line"><span class="comment"># 博客的网址及文章 URL 结构，默认在根目录</span></span><br><span class="line"><span class="comment"># 如果你想要将博客设定在一个子目录，如 'http://yoursite.com/blog'，则将 root 设定为该子目录的名称 '/child/'</span></span><br><span class="line"><span class="comment"># 建议博客的 URL 结构在博客建立初期就规划好，因为当你写的文章被搜索引擎收录以及被读者收藏后，再更改结构，会对你的网站访问造成一定影响</span></span><br><span class="line"><span class="attr">url:</span> <span class="string">https://github.com/flyoptimistic/flyoptimistic.github.io.git</span></span><br><span class="line"><span class="attr">root:</span> <span class="string">/blog</span></span><br><span class="line"><span class="attr">permalink:</span> <span class="string">:year/:month/:day/:title/</span></span><br><span class="line"><span class="attr">permalink_defaults:</span></span><br><span class="line"><span class="attr">pretty_urls:</span></span><br><span class="line">  <span class="attr">trailing_index:</span> <span class="literal">true</span> <span class="comment"># Set to false to remove trailing 'index.html' from permalinks</span></span><br><span class="line">  <span class="attr">trailing_html:</span> <span class="literal">true</span> <span class="comment"># Set to false to remove trailing '.html' from permalinks</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 这里是设定一些基本文件夹的名称，如资源文件夹等。</span></span><br><span class="line"><span class="attr">source_dir:</span> <span class="string">source</span></span><br><span class="line"><span class="attr">public_dir:</span> <span class="string">public</span></span><br><span class="line"><span class="attr">tag_dir:</span> <span class="string">tags</span></span><br><span class="line"><span class="attr">archive_dir:</span> <span class="string">archives</span></span><br><span class="line"><span class="attr">category_dir:</span> <span class="string">categories</span></span><br><span class="line"><span class="attr">code_dir:</span> <span class="string">downloads/code</span></span><br><span class="line"><span class="attr">i18n_dir:</span> <span class="string">:lang</span></span><br><span class="line"><span class="comment">## skip_render 是为了避免在执行 'hexo generate' 命令后将一些你不想转义的文件转成 HTML 格式。</span></span><br><span class="line"><span class="comment">## 比如 README.md，你可以将这些文件名填写在括号内，格式为 [README.md, Post1.md, Post2.md]</span></span><br><span class="line"><span class="attr">skip_render:</span> <span class="string">[README.md]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Writing</span></span><br><span class="line"><span class="attr">new_post_name:</span> <span class="string">:title.md</span> <span class="comment"># File name of new posts</span></span><br><span class="line"><span class="attr">default_layout:</span> <span class="string">post</span></span><br><span class="line"><span class="attr">titlecase:</span> <span class="literal">false</span> <span class="comment"># Transform title into titlecase</span></span><br><span class="line"><span class="attr">external_link:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span> <span class="comment"># Open external links in new tab</span></span><br><span class="line">  <span class="attr">field:</span> <span class="string">site</span> <span class="comment"># Apply to the whole site</span></span><br><span class="line">  <span class="attr">exclude:</span> <span class="string">''</span></span><br><span class="line"><span class="attr">filename_case:</span> <span class="number">0</span></span><br><span class="line"><span class="attr">render_drafts:</span> <span class="literal">false</span></span><br><span class="line"><span class="comment">## post_asset_folder 设置为 true 后，当你新建一个 post 的时候，会在同级目录生成一个相同名字的文件夹</span></span><br><span class="line"><span class="attr">post_asset_folder:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">relative_link:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">future:</span> <span class="literal">true</span></span><br><span class="line"><span class="comment">## 代码高亮设置</span></span><br><span class="line"><span class="attr">highlight:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">line_number:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">auto_detect:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">tab_replace:</span> <span class="string">''</span></span><br><span class="line">  <span class="attr">wrap:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">hljs:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Home page setting</span></span><br><span class="line"><span class="comment"># path: Root path for your blogs index page. (default = '')</span></span><br><span class="line"><span class="comment"># per_page: Posts displayed per page. (0 = disable pagination)</span></span><br><span class="line"><span class="comment"># order_by: Posts order. (Order by date descending by default)</span></span><br><span class="line"><span class="attr">index_generator:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">''</span></span><br><span class="line">  <span class="attr">per_page:</span> <span class="number">10</span></span><br><span class="line">  <span class="attr">order_by:</span> <span class="string">-date</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Category &amp; Tag</span></span><br><span class="line"><span class="attr">default_category:</span> <span class="string">uncategorized</span></span><br><span class="line"><span class="comment">## URL 中的分类和标签「翻译」成英文 参见：https://github.com/hexojs/hexo/issues/1162</span></span><br><span class="line"><span class="attr">category_map:</span></span><br><span class="line"><span class="attr">tag_map:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Metadata elements</span></span><br><span class="line"><span class="comment">## https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta</span></span><br><span class="line"><span class="attr">meta_generator:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Date / Time format</span></span><br><span class="line"><span class="comment">## Hexo uses Moment.js to parse and display date</span></span><br><span class="line"><span class="comment">## You can customize the date format as defined in</span></span><br><span class="line"><span class="comment">## http://momentjs.com/docs/#/displaying/format/</span></span><br><span class="line"><span class="attr">date_format:</span> <span class="string">YYYY-MM-DD</span></span><br><span class="line"><span class="attr">time_format:</span> <span class="string">HH:mm:ss</span></span><br><span class="line"><span class="comment">## Use post's date for updated date unless set in front-matter</span></span><br><span class="line"><span class="attr">use_date_for_updated:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Pagination</span></span><br><span class="line"><span class="comment">## Set per_page to 0 to disable pagination</span></span><br><span class="line"><span class="attr">per_page:</span> <span class="number">10</span></span><br><span class="line"><span class="attr">pagination_dir:</span> <span class="string">page</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Include / Exclude file(s)</span></span><br><span class="line"><span class="comment">## include:/exclude: options only apply to the 'source/' folder</span></span><br><span class="line"><span class="attr">include:</span></span><br><span class="line"><span class="attr">exclude:</span></span><br><span class="line"><span class="attr">ignore:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Extensions</span></span><br><span class="line"><span class="comment">## Plugins: https://hexo.io/plugins/</span></span><br><span class="line"><span class="comment">## Themes: https://hexo.io/themes/</span></span><br><span class="line"><span class="comment">## 切换主题</span></span><br><span class="line"><span class="attr">theme:</span> <span class="string">next</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Deployment</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/deployment.html</span></span><br><span class="line"><span class="comment">## 设定执行 'hexo deploy' 命令后提交的代码仓库地址</span></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line">   <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">   <span class="attr">repository:</span> <span class="string">https://github.com/flyoptimistic/flyoptimistic.github.io.git</span></span><br><span class="line">   <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure>

<h3 id="主题配置文件"><a href="#主题配置文件" class="headerlink" title="主题配置文件"></a>主题配置文件</h3><h4 id="页脚信息"><a href="#页脚信息" class="headerlink" title="页脚信息"></a>页脚信息</h4><p>在网页的底部显示版权信息，包括年份、图标、作者信息，是否显示 Hexo 及其版本、NexT 及其版本，还有备案信息。图标名称需要填写 <a href="https://fontawesome.com/" target="_blank" rel="noopener">Font Awesome</a> 中提供的图标名称。如果你想要添加任何自定义内容，比如添加一句话，可以考虑在 <code>~/source/_data/</code> 路径下建立 <code>footer.swig</code> 文件，在该文件下添加内容。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">footer:</span></span><br><span class="line">    <span class="attr">icon:</span></span><br><span class="line">    <span class="comment"># 设置图标，如需要别的请自行查找 https://fontawesome.com/icons</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">fa</span> <span class="string">fa-heart</span></span><br><span class="line">    <span class="comment"># 设置动画效果</span></span><br><span class="line">    <span class="attr">animated:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># 颜色</span></span><br><span class="line">    <span class="attr">color:</span> <span class="string">"#ff0000"</span></span><br><span class="line">    <span class="comment"># If not defined, `author` from Hexo `_config.yml` will be used.</span></span><br><span class="line">    <span class="attr">copyright:</span></span><br><span class="line">    <span class="comment"># 修改为false，去除hexo和next页脚链接</span></span><br><span class="line">    <span class="attr">powered:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<h4 id="导航目录"><a href="#导航目录" class="headerlink" title="导航目录"></a>导航目录</h4><h5 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h5><p>你可以在此处设置目录选项的名称和所在文件夹的位置，以及对应的图标，这里的图标同样需要对应 <a href="https://fontawesome.com/" target="_blank" rel="noopener">Font Awesome</a>  中图标的名称。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="attr">home:</span> <span class="string">/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-home</span></span><br><span class="line">  <span class="attr">about:</span> <span class="string">/about/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-user</span></span><br><span class="line">  <span class="attr">tags:</span> <span class="string">/tags/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-tags</span></span><br><span class="line">  <span class="attr">categories:</span> <span class="string">/categories/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-th</span></span><br><span class="line">  <span class="attr">archives:</span> <span class="string">/archives/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-archive</span></span><br><span class="line">  <span class="comment">#schedule: /schedule/ || fa fa-calendar</span></span><br><span class="line">  <span class="comment">#sitemap: /sitemap.xml || fa fa-sitemap</span></span><br><span class="line">  <span class="comment">#commonweal: /404/ || fa fa-heartbeat</span></span><br><span class="line"></span><br><span class="line"><span class="attr">menu_settings:</span></span><br><span class="line">  <span class="attr">icons:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">badges:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>home:</code> 该目录名称，对应<code>~/themes/next/languages/zh-CN.yml</code> 下对应的 <code>menu:</code> 下添加对应的中文，格式为 <code>home: 首页</code>。</li>
<li><code>/</code> 即为网站的根目录。</li>
<li><code>||</code> 后的 <code>home</code> 即为图标名称。</li>
</ul>
<h5 id="创建目录页面"><a href="#创建目录页面" class="headerlink" title="创建目录页面"></a>创建目录页面</h5><ul>
<li><p>建立标签页面和分类页面，首先需要去掉 <code>tags</code> 和 <code>categories</code> 前的注释，然后在 <code>~/source/</code> 文件夹下建立该页面，对应名称为 <code>tags</code> 和 <code>categories</code>。可以执行以下命令生成：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> hexo new page tags</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> hexo new page categories</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>执行上述命令后会在 <code>~/source/</code> 文件夹中生成了对应名称的文件夹，在该文件夹下有一个 <code>index.md</code> 文件，打开该文件，在如下所示位置添加内容：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">title:</span> <span class="string">about</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2020</span><span class="number">-06</span><span class="number">-12</span> <span class="number">15</span><span class="string">:36:24</span></span><br><span class="line"><span class="comment">#添加type</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">"about"</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="设置侧栏阅读进度百分比"><a href="#设置侧栏阅读进度百分比" class="headerlink" title="设置侧栏阅读进度百分比"></a>设置侧栏阅读进度百分比</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">back2top:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment">#侧边栏回到顶部</span></span><br><span class="line">  <span class="attr">sidebar:</span> <span class="literal">false</span></span><br><span class="line">  <span class="comment">#百分比</span></span><br><span class="line">  <span class="attr">scrollpercent:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h4 id="设置头像"><a href="#设置头像" class="headerlink" title="设置头像"></a>设置头像</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">avatar:</span></span><br><span class="line">  <span class="comment"># 替换掉默认路径并设置头像路径</span></span><br><span class="line">  <span class="attr">url:</span> <span class="string">/images/avatar.jpg</span> </span><br><span class="line">  <span class="comment"># 圆形</span></span><br><span class="line">  <span class="attr">rounded:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># 旋转</span></span><br><span class="line">  <span class="attr">rotated:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<h4 id="设置网页标签图标"><a href="#设置网页标签图标" class="headerlink" title="设置网页标签图标"></a>设置网页标签图标</h4><p><a href="http://www.ico51.cn/" target="_blank" rel="noopener">制作icon链接</a></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">favicon:</span></span><br><span class="line">  <span class="attr">small:</span> <span class="string">/images/favicon_16.ico</span>  <span class="comment">#此处放制作好的链接</span></span><br><span class="line">  <span class="attr">medium:</span> <span class="string">/images/favicon_32.ico</span></span><br><span class="line">  <span class="comment">#apple_touch_icon: /images/apple-touch-icon-next.png</span></span><br><span class="line">  <span class="comment">#safari_pinned_tab: /images/logo.svg</span></span><br><span class="line">  <span class="comment">#android_manifest: /images/manifest.json</span></span><br><span class="line">  <span class="comment">#ms_browserconfig: /images/browserconfig.xml</span></span><br></pre></td></tr></table></figure>



<h4 id="设置github图标"><a href="#设置github图标" class="headerlink" title="设置github图标"></a>设置github图标</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">github_banner:</span> <span class="comment"># 开启github</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">permalink:</span> <span class="string">https://github.com/flyoptimistic</span> <span class="comment">#跳转自己的仓库链接</span></span><br><span class="line">  <span class="attr">title:</span> <span class="string">Follow</span> <span class="string">me</span> <span class="string">on</span> <span class="string">GitHub</span></span><br></pre></td></tr></table></figure>

<h4 id="图片浏览"><a href="#图片浏览" class="headerlink" title="图片浏览"></a>图片浏览</h4><p>实现该功能的基础是在文章中插入图片。该项功能的效果是：点击文中插图，图片能够放大，有幻灯片的效果。目前 NexT 提供了两款插件 fancybox 和 mediumzoom，两款插件开启一个即可。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">fancybox:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">mediumzoom:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h4 id="数学公式"><a href="#数学公式" class="headerlink" title="数学公式"></a>数学公式</h4><p>支持 MathJax 和 KaTeX 两种加载数学公式的方法，使用语法都是 LaTeX 语法。不过 MathJax 的功能比较全面，KaTeX 的加载速度比较快。不过有一点要注意，不论是用哪一个方式，我都推荐替换默认渲染器。</p>
<p>MathJax 使用 hexo-renderer-pandoc 或者 hexo-renderer-kramed；KaTeX 使用 hexo-renderer-markdown-it-plus 或者 hexo-renderer-markdown-it。</p>
<p>默认的 <code>per_page: true</code> 的意思是，只用当你在文章设定中添加 <code>mathjax: ture</code>，才会在当前页面中加载公式渲染。如果你使用的是 KaTeX，还要注意，过长的公式会超出页面边框，可能需要自行添加 CSS 样式对长公式进行滚动浏览。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">math:</span></span><br><span class="line">  <span class="comment"># 只渲染前面有 `mathjax: true` 的页面.</span></span><br><span class="line">  <span class="attr">per_page:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># hexo-renderer-pandoc (or hexo-renderer-kramed) required for full MathJax support.</span></span><br><span class="line">  <span class="attr">mathjax:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># See: https://mhchem.github.io/MathJax-mhchem/</span></span><br><span class="line">    <span class="attr">mhchem:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">katex:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">    <span class="comment"># See: https://github.com/KaTeX/KaTeX/tree/master/contrib/copy-tex</span></span><br><span class="line">    <span class="attr">copy_tex:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>



<h4 id="访客统计"><a href="#访客统计" class="headerlink" title="访客统计"></a>访客统计</h4><p><a href="http://ibruce.info/2015/04/04/busuanzi" target="_blank" rel="noopener">卜算子统计官网</a></p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">busuanzi_count:</span></span><br><span class="line">  <span class="comment">#开启</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">total_visitors:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">total_visitors_icon:</span> <span class="string">fa</span> <span class="string">fa-user</span></span><br><span class="line">  <span class="attr">total_views:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">total_views_icon:</span> <span class="string">fa</span> <span class="string">fa-eye</span></span><br><span class="line">  <span class="attr">post_views:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">post_views_icon:</span> <span class="string">fa</span> <span class="string">fa-eye</span></span><br></pre></td></tr></table></figure>

<h4 id="评论功能"><a href="#评论功能" class="headerlink" title="评论功能"></a>评论功能</h4><h5 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h5><p><a href="https://valine.js.org/" target="_blank" rel="noopener">Valine</a> 评论系统是我认为的在国内网络环境下最好用的评论系统，可通过 Leancloud 管理评论，无广告，简洁美观。不过缺点就是，Leancloud 平台的不稳定性，在 2019 年夏季的时候，出现了一次域名停止解析的事故，原因是有人利用 Leancloud 进行一些非法行为，而平台管理人员并没有监管到位。在那次事故之后，Leancloud 加强了监管，国内用户必须进行实名注册，每一个服务器必须绑定一个备案的域名。如果你不想备案，可以选择使用 Leancloud 国际版。但谁也无法确保 Leancloud 国际版会发生什么事情。</p>
<p>Leancloud 国内版和国际版的配置相同，这里以国际版为例进行说明。首先进入<a href="https://leancloud.app/" target="_blank" rel="noopener">官网</a>进行用户注册，注册完成后点击「创建应用」，填写应用的名称，选择「开发版」进行创建。</p>
<h6 id="创建应用"><a href="#创建应用" class="headerlink" title="创建应用"></a>创建应用</h6><p><img data-src="%E5%88%9B%E5%BB%BAleancloud%E5%BA%94%E7%94%A8.png" alt="创建leancloud应用"></p>
<h6 id="创建class"><a href="#创建class" class="headerlink" title="创建class"></a>创建class</h6><p><img data-src="leancloud_%E5%88%9B%E5%BB%BAclass.png" alt="leancloud_创建class"></p>
<h6 id="获取appid和appkey"><a href="#获取appid和appkey" class="headerlink" title="获取appid和appkey"></a>获取appid和appkey</h6><p><img data-src="leancloud_%E8%8E%B7%E5%8F%96%E4%BF%A1%E6%81%AF.png" alt="leancloud_获取信息"></p>
<h5 id="修改主题配置文件"><a href="#修改主题配置文件" class="headerlink" title="修改主题配置文件"></a>修改主题配置文件</h5><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Valine</span></span><br><span class="line"><span class="comment"># 更多信息: https://valine.js.org, https://github.com/xCss/Valine</span></span><br><span class="line"><span class="attr">valine:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">appId:</span>  <span class="comment"># leancloud 应用 appid</span></span><br><span class="line">  <span class="attr">appKey:</span> <span class="comment"># leancloud 应用 appkey</span></span><br><span class="line">  <span class="attr">placeholder:</span> <span class="string">来都来了，留下点宝贵建议吧！</span> <span class="comment"># Comment box placeholder</span></span><br><span class="line">  <span class="attr">avatar:</span> <span class="string">mm</span> <span class="comment"># Gravatar style</span></span><br><span class="line">  <span class="attr">meta:</span> <span class="string">[nick,</span> <span class="string">mail,</span> <span class="string">link]</span> <span class="comment"># Custom comment header</span></span><br><span class="line">  <span class="attr">pageSize:</span> <span class="number">10</span> <span class="comment"># Pagination size</span></span><br><span class="line">  <span class="attr">language:</span> <span class="comment"># Language, available values: en, zh-cn</span></span><br><span class="line">  <span class="attr">visitor:</span> <span class="literal">false</span> <span class="comment"># Article reading statistic</span></span><br><span class="line">  <span class="attr">comment_count:</span> <span class="literal">true</span> <span class="comment"># If false, comment count will only be displayed in post page, not in home page</span></span><br><span class="line">  <span class="attr">recordIP:</span> <span class="literal">false</span> <span class="comment"># Whether to record the commenter IP</span></span><br><span class="line">  <span class="attr">serverURLs:</span> <span class="comment"># When the custom domain name is enabled, fill it in here (it will be detected automatically by default, no need to fill in)</span></span><br><span class="line">  <span class="comment">#post_meta_order: 0</span></span><br></pre></td></tr></table></figure>

<h4 id="本地搜索"><a href="#本地搜索" class="headerlink" title="本地搜索"></a>本地搜索</h4><h5 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure>

<h5 id="站点配置文件-config-yml添加"><a href="#站点配置文件-config-yml添加" class="headerlink" title="站点配置文件_config.yml添加"></a>站点配置文件<code>_config.yml</code>添加</h5><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">search:</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">search.xml</span></span><br><span class="line">    <span class="attr">field:</span> <span class="string">post</span></span><br><span class="line">    <span class="attr">format:</span> <span class="string">html</span></span><br><span class="line">    <span class="attr">limit:</span> <span class="number">5000</span></span><br></pre></td></tr></table></figure>

<h5 id="主题配置文件-1"><a href="#主题配置文件-1" class="headerlink" title="主题配置文件"></a>主题配置文件</h5><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">local_search:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>



<h4 id="添加分享"><a href="#添加分享" class="headerlink" title="添加分享"></a>添加分享</h4><h5 id="打开addthis官网"><a href="#打开addthis官网" class="headerlink" title="打开addthis官网"></a>打开<a href="https://www.addthis.com/dashboard#tool-config/pub/ra-5eeb31b88c2ca90e" target="_blank" rel="noopener">addthis官网</a></h5><h5 id="注册-1"><a href="#注册-1" class="headerlink" title="注册"></a>注册</h5><h5 id="选择分享工具"><a href="#选择分享工具" class="headerlink" title="选择分享工具"></a>选择分享工具</h5><img data-src="/blog/2020/06/17/GitPages%E5%92%8CHexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/%E5%88%86%E4%BA%AB%E9%80%89%E6%8B%A9%E6%8C%89%E9%92%AE.png" class="" title="分享选择按钮">

<h5 id="生成代码"><a href="#生成代码" class="headerlink" title="生成代码"></a>生成代码</h5><h5 id="获取pubid"><a href="#获取pubid" class="headerlink" title="获取pubid"></a>获取pubid</h5><img data-src="/blog/2020/06/17/GitPages%E5%92%8CHexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/%E7%94%9F%E6%88%90%E5%88%86%E4%BA%ABid.png" class="" title="生成分享id">

<h5 id="修改主题配置文件-config-yml"><a href="#修改主题配置文件-config-yml" class="headerlink" title="修改主题配置文件 _config.yml_"></a>修改主题配置文件 <code>_config.yml</code>_</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">add_this_id:  #设置为你的id</span><br></pre></td></tr></table></figure>

<h3 id="网页样式布局"><a href="#网页样式布局" class="headerlink" title="网页样式布局"></a>网页样式布局</h3><p>在对 NexT 主题的个性优化中，如果想要添加一些个性化的内容，就需要对内部代码进行修改。主题提供了许多注入点，可以通过注入点插入自己想要的东西，而不会对原有的主题内部文件进行大量的修改。这样便于以后主题的升级，避免一系列的错误发生。NexT 主题更新到 v7.2.0 后，<a href="https://github.com/theme-next/hexo-theme-next/pull/868">PR #868</a> 简化了自定义内容的添加方法，删除了以前版本中所用的 <code>css/_custom.styl</code> 自定义 CSS 样式文件。如果想要修改样式或者在 HTML 中的 <code>、</code> 等部位插入代码。即直接在博客 <code>sourse</code> 资源文件夹下新建自定义文件 <code>_data/xxx</code> 实现该功能。</p>
<p>主题配置文件 <code>_config.yml</code> 中：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 自定义文件路径</span></span><br><span class="line"><span class="comment"># 在`source/_data` 创建自定义文件，并打开需要的注释.</span></span><br><span class="line"><span class="attr">custom_file_path:</span></span><br><span class="line">  <span class="comment">#head: source/_data/head.njk</span></span><br><span class="line">  <span class="comment">#header: source/_data/header.njk</span></span><br><span class="line">  <span class="comment">#sidebar: source/_data/sidebar.njk</span></span><br><span class="line">  <span class="comment">#postMeta: source/_data/post-meta.njk</span></span><br><span class="line">  <span class="comment">#postBodyEnd: source/_data/post-body-end.njk</span></span><br><span class="line">  <span class="comment">#footer: source/_data/footer.njk</span></span><br><span class="line">  <span class="comment">#bodyEnd: source/_data/body-end.njk</span></span><br><span class="line">  <span class="comment">#variable: source/_data/variables.styl</span></span><br><span class="line">  <span class="comment">#mixin: source/_data/mixins.styl</span></span><br><span class="line">  <span class="comment">#style: source/_data/styles.styl</span></span><br></pre></td></tr></table></figure>

<h4 id="基本修改方法"><a href="#基本修改方法" class="headerlink" title="基本修改方法"></a>基本修改方法</h4><p>NexT 主题最大的特点就是主题基础颜色简单，白加黑的简单组合为我们提供了能够随心所欲进行自定义的空间。修改颜色、修改图形、修改动画……这些都能够实现。控制这些自定义样式布局的文件即为 <code>styles.styl</code>。该文件在主题安装后并不存在，需要你自己建立。首先，你需要在主题配置文件 <code>_config.yml</code> 中，将下面一栏的注释删除：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">custom_file_path:</span></span><br><span class="line">    <span class="attr">style:</span> <span class="string">source/_data/styles.styl</span></span><br></pre></td></tr></table></figure>

<p>然后在你的在博客根目录下的 <code>source</code> 文件夹下新建 <code>_data</code> 文件夹，在该文件夹下创建名为 <code>styles.styl</code> 的文件。这里需要注意，不要将 <code>source</code> 文件夹创建在主题文件夹中。</p>
<p>该文件有什么作用呢？你可以将自定义的 CSS 样式写入该文件中，这些自定义样式会覆盖主题原有的样式设定。那么该如何自定义样式呢？你只需要一个工具——浏览器。这里我推荐使用 Google 的 Chrome 浏览器，通过浏览器打开你的网站，右键，点击「检查」或者按键盘上的「F12」键，进入<a href="https://developers.google.com/web/tools/chrome-devtools/" target="_blank" rel="noopener">调试模式</a>。然后点击窗口右上角的小箭头定位元素，定位到你需要修改的元素区域，调试台就会显示这一元素的 CSS 代码，在这里修改你想要的样式，再将其 Copy 到 <code>styles.styl</code> 中就可以了。</p>
<h4 id="添加顶部加载"><a href="#添加顶部加载" class="headerlink" title="添加顶部加载"></a>添加顶部加载</h4><p>在<code>~\themes\next\layout\_partials\head\head.njk</code>文件中添加如下代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script src=<span class="string">"//cdn.bootcss.com/pace/1.0.2/pace.min.js"</span>&gt;&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;link href="/</span><span class="regexp">/cdn.bootcss.com/</span>pace/<span class="number">1.0</span><span class="number">.2</span>/themes/pink/pace-theme-flash.css<span class="string">" rel="</span>stylesheet<span class="string">"&gt;</span></span><br><span class="line"><span class="string">&lt;style&gt;</span></span><br><span class="line"><span class="string">  .pace .pace-progress &#123;</span></span><br><span class="line"><span class="string">	  background: #1E92FB; /*进度条颜色*/</span></span><br><span class="line"><span class="string">	  height: 3px;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">  .pace .pace-progress-inner &#123;</span></span><br><span class="line"><span class="string">	   box-shadow: 0 0 10px #1E92FB, 0 0 5px     #1E92FB; /*阴影颜色*/</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">  .pace .pace-activity &#123;</span></span><br><span class="line"><span class="string">	  border-top-color: #1E92FB;    /*上边框颜色*/</span></span><br><span class="line"><span class="string">	  border-left-color: #1E92FB;    /*左边框颜色*/</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&lt;/style&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="修改标签样式"><a href="#修改标签样式" class="headerlink" title="修改标签样式"></a>修改标签样式</h4><p>修改<code>~\themes\next\_config.yml</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用图标代替#</span></span><br><span class="line"><span class="attr">tag_icon:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h4 id="添加球形标签云样式"><a href="#添加球形标签云样式" class="headerlink" title="添加球形标签云样式"></a>添加球形标签云样式</h4><p><img data-src="%E6%A0%87%E7%AD%BE%E4%BA%91.gif" alt="标签云"></p>
<p>首先要确保你已经开启标签功能。目前有一个标签云插件可以提供这样的效果：<a href="https://github.com/MikeCoder/hexo-tag-cloud/blob/master/README.ZH.md">hexo-tag-cloud</a>。执行 <code>npm install hexo-tag-cloud --save</code> 进行安装。插件安装完成后，你可以自定义标签云的位置，比如显示在侧栏，或者显示在标签页面。比如选择显示在标签页面，则在 <code>~/themes/next/layout/page.njk</code> 中，添加如下所示代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;% <span class="keyword">if</span> site.tags.length &gt; <span class="number">1</span> %&#125;</span><br><span class="line">&lt;script type=<span class="string">"text/javascript"</span> charset=<span class="string">"utf-8"</span> src=<span class="string">"&#123;&#123; url_for('/js/tagcloud.js') &#125;&#125;"</span>&gt;&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;script type="text/</span>javascript<span class="string">" charset="</span>utf<span class="number">-8</span><span class="string">" src="</span>&#123;&#123; url_for(<span class="string">'/js/tagcanvas.js'</span>) &#125;&#125;<span class="string">"&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="string">&lt;div class="</span>widget-wrap<span class="string">"&gt;</span></span><br><span class="line"><span class="string">    &lt;h3 class="</span>widget-title<span class="string">"&gt;Tag Cloud&lt;/h3&gt;</span></span><br><span class="line"><span class="string">    &lt;div id="</span>myCanvasContainer<span class="string">" class="</span>widget tagcloud<span class="string">"&gt;</span></span><br><span class="line"><span class="string">        &lt;canvas width="</span><span class="number">250</span><span class="string">" height="</span><span class="number">250</span><span class="string">" id="</span>resCanvas<span class="string">" style="</span>width:<span class="number">100</span>%<span class="string">"&gt;</span></span><br><span class="line"><span class="string">            &#123;&#123; list_tags() &#125;&#125;</span></span><br><span class="line"><span class="string">        &lt;/canvas&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">&lt;/div&gt;</span></span><br><span class="line"><span class="string">&#123;% endif %&#125;</span></span><br></pre></td></tr></table></figure>

<p>最后，你可以选择在博客根目录配置文件 <code>_config.yml</code> 中添加如下的配置项进行更细致的设定:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#球形标签云</span></span><br><span class="line"><span class="attr">tag_cloud:</span></span><br><span class="line">    <span class="attr">textFont:</span> <span class="string">Trebuchet</span> <span class="string">MS,</span> <span class="string">Helvetica</span></span><br><span class="line">    <span class="attr">textColor:</span> <span class="string">'#333'</span></span><br><span class="line">    <span class="attr">textHeight:</span> <span class="number">25</span></span><br><span class="line">    <span class="attr">outlineColor:</span> <span class="string">'#E2E1D1'</span></span><br><span class="line">    <span class="attr">maxSpeed:</span> <span class="number">0.5</span></span><br><span class="line">    <span class="attr">pauseOnSelected:</span> <span class="literal">true</span> <span class="comment"># true 意味着当选中对应 tag 时,停止转动</span></span><br></pre></td></tr></table></figure>

<h4 id="添加线状动态背景"><a href="#添加线状动态背景" class="headerlink" title="添加线状动态背景"></a>添加线状动态背景</h4><p><img data-src="%E7%BA%BF%E6%80%A7%E5%8A%A8%E6%80%81%E8%83%8C%E6%99%AF.gif" alt="线性动态背景"></p>
<ul>
<li><p>修改<code>next/layout/_layout.njk</code>_,添加到末尾</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;% <span class="keyword">if</span> theme.canvas_nest %&#125;</span><br><span class="line">&lt;script type=<span class="string">"text/javascript"</span> src=<span class="string">"//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"</span>&gt;&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&#123;% endif %&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>/next/_config.yml</code>添加</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># --------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># background settings</span></span><br><span class="line"><span class="comment"># --------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># add canvas-nest effect</span></span><br><span class="line"><span class="comment"># see detail from https://github.com/hustcc/canvas-nest.js</span></span><br><span class="line"><span class="attr">canvas_nest:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="添加点击爱心特效"><a href="#添加点击爱心特效" class="headerlink" title="添加点击爱心特效"></a>添加点击爱心特效</h4><p>首先在 <code>~/themes/next/source/js/</code> 下新建文件 <code>clicklove.js</code>，接着把以下的代码拷贝粘贴到该文件中：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 所在目录：~/themes/next/source/js/ */</span></span><br><span class="line">!<span class="function"><span class="keyword">function</span>(<span class="params">e,t,a</span>)</span>&#123;<span class="function"><span class="keyword">function</span> <span class="title">n</span>(<span class="params"></span>)</span>&#123;c(<span class="string">".heart&#123;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);&#125;.heart:after,.heart:before&#123;content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;&#125;.heart:after&#123;top: -5px;&#125;.heart:before&#123;left: -5px;&#125;"</span>),o(),r()&#125;<span class="function"><span class="keyword">function</span> <span class="title">r</span>(<span class="params"></span>)</span>&#123;<span class="keyword">for</span>(<span class="keyword">var</span> e=<span class="number">0</span>;e&lt;d.length;e++)d[e].alpha&lt;=<span class="number">0</span>?(t.body.removeChild(d[e].el),d.splice(e,<span class="number">1</span>)):(d[e].y--,d[e].scale+=<span class="number">.004</span>,d[e].alpha-=<span class="number">.013</span>,d[e].el.style.cssText=<span class="string">"left:"</span>+d[e].x+<span class="string">"px;top:"</span>+d[e].y+<span class="string">"px;opacity:"</span>+d[e].alpha+<span class="string">";transform:scale("</span>+d[e].scale+<span class="string">","</span>+d[e].scale+<span class="string">") rotate(45deg);background:"</span>+d[e].color+<span class="string">";z-index:99999"</span>);requestAnimationFrame(r)&#125;<span class="function"><span class="keyword">function</span> <span class="title">o</span>(<span class="params"></span>)</span>&#123;<span class="keyword">var</span> t=<span class="string">"function"</span>==<span class="keyword">typeof</span> e.onclick&amp;&amp;e.onclick;e.onclick=<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;t&amp;&amp;t(),i(e)&#125;&#125;<span class="function"><span class="keyword">function</span> <span class="title">i</span>(<span class="params">e</span>)</span>&#123;<span class="keyword">var</span> a=t.createElement(<span class="string">"div"</span>);a.className=<span class="string">"heart"</span>,d.push(&#123;<span class="attr">el</span>:a,<span class="attr">x</span>:e.clientX<span class="number">-5</span>,<span class="attr">y</span>:e.clientY<span class="number">-5</span>,<span class="attr">scale</span>:<span class="number">1</span>,<span class="attr">alpha</span>:<span class="number">1</span>,<span class="attr">color</span>:s()&#125;),t.body.appendChild(a)&#125;<span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params">e</span>)</span>&#123;<span class="keyword">var</span> a=t.createElement(<span class="string">"style"</span>);a.type=<span class="string">"text/css"</span>;<span class="keyword">try</span>&#123;a.appendChild(t.createTextNode(e))&#125;<span class="keyword">catch</span>(t)&#123;a.styleSheet.cssText=e&#125;t.getElementsByTagName(<span class="string">"head"</span>)[<span class="number">0</span>].appendChild(a)&#125;<span class="function"><span class="keyword">function</span> <span class="title">s</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span><span class="string">"rgb("</span>+~~(<span class="number">255</span>*<span class="built_in">Math</span>.random())+<span class="string">","</span>+~~(<span class="number">255</span>*<span class="built_in">Math</span>.random())+<span class="string">","</span>+~~(<span class="number">255</span>*<span class="built_in">Math</span>.random())+<span class="string">")"</span>&#125;<span class="keyword">var</span> d=[];e.requestAnimationFrame=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> e.requestAnimationFrame||e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||e.oRequestAnimationFrame||e.msRequestAnimationFrame||<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;setTimeout(e,<span class="number">1e3</span>/<span class="number">60</span>)&#125;&#125;(),n()&#125;(<span class="built_in">window</span>,<span class="built_in">document</span>);</span><br></pre></td></tr></table></figure>

<p>然后在 <code>~/theme/next/layout/_layout.njk</code> 文件的末尾添加引用：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;!-- 文件位置：~<span class="regexp">/theme/</span>next/layout/_layout.njk --&gt;</span><br><span class="line">&lt;script type=<span class="string">"text/javascript"</span> src=<span class="string">"/js/clicklove.js"</span>&gt;&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="添加图片"><a href="#添加图片" class="headerlink" title="添加图片"></a>添加图片</h4><h5 id="阿里云储存对象-OSS-服务：可以放在阿里云上"><a href="#阿里云储存对象-OSS-服务：可以放在阿里云上" class="headerlink" title="阿里云储存对象 OSS 服务：可以放在阿里云上"></a><a href="https://www.aliyun.com/product/oss/" target="_blank" rel="noopener">阿里云储存对象 OSS 服务</a>：可以放在阿里云上</h5><h5 id="hexo-asset-image插件"><a href="#hexo-asset-image插件" class="headerlink" title="hexo-asset-image插件"></a><a href="https://github.com/xcodebuild/hexo-asset-image">hexo-asset-image</a>插件</h5><h6 id="安装插件-1"><a href="#安装插件-1" class="headerlink" title="安装插件"></a>安装插件</h6><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-asset-image --save</span><br></pre></td></tr></table></figure>

<h6 id="修改博客配置文件-config-yml："><a href="#修改博客配置文件-config-yml：" class="headerlink" title="修改博客配置文件 _config.yml："></a>修改博客配置文件 <code>_config.yml</code>：</h6><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#post_asset_folder 设置为 true 后，当你新建一个 post 的时候，会在同级目录生成一个相同名字的文件夹</span></span><br><span class="line"><span class="attr">post_asset_folder:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h6 id="解决插件自身bug"><a href="#解决插件自身bug" class="headerlink" title="解决插件自身bug"></a>解决插件自身bug</h6><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"># 文件位置：~/node_modules/hexo-asset-image/index.js</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    #var endPos = link.length-1</span><br><span class="line">	<span class="keyword">var</span> endPos = link.lastIndexOf(<span class="string">'.'</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h6 id="引入图片"><a href="#引入图片" class="headerlink" title="引入图片"></a>引入图片</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">![Alt text](&#x2F;path&#x2F;to&#x2F;img.jpg)</span><br><span class="line">![Alt text](&#x2F;path&#x2F;to&#x2F;img.jpg &quot;Optional title&quot;)</span><br></pre></td></tr></table></figure>

<p>对于 Markdown 图片引用的代码，主要有三个部分：</p>
<ol>
<li><code>Alt text</code>，替代文本，图片无法显示时读者看到的就是它</li>
<li><code>/path/to/img.jpg</code>，URL，即图片的链接</li>
<li><code>Optional title</code>，图片的标题</li>
</ol>
<h5 id="hexo-自带（新版推荐使用）"><a href="#hexo-自带（新版推荐使用）" class="headerlink" title="hexo 自带（新版推荐使用）"></a>hexo 自带（新版推荐使用）</h5><h6 id="修改博客配置文件-config-yml：-1"><a href="#修改博客配置文件-config-yml：-1" class="headerlink" title="修改博客配置文件 _config.yml："></a>修改博客配置文件 <code>_config.yml</code>：</h6><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#post_asset_folder 设置为 true 后，当你新建一个 post 的时候，会在同级目录生成一个相同名字的文件夹</span></span><br><span class="line"><span class="attr">post_asset_folder:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h6 id="markdown语法插入图片"><a href="#markdown语法插入图片" class="headerlink" title="markdown语法插入图片"></a>markdown语法插入图片</h6><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#图片相对路径</span></span><br><span class="line"><span class="string">![Alt</span> <span class="string">text](img.jpg)</span></span><br></pre></td></tr></table></figure>

<h6 id="用于相对路径引用的标签插件"><a href="#用于相对路径引用的标签插件" class="headerlink" title="用于相对路径引用的标签插件"></a>用于相对路径引用的标签插件</h6><p>Hexo 3之后可以使用<a href="https://hexo.io/zh-cn/docs/tag-plugins.html" target="_blank" rel="noopener">标签插件</a>来引入图片</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># example.jpg 路径</span></span><br><span class="line"><span class="string">&#123;%</span> <span class="string">asset_img</span> <span class="string">example.jpg</span> <span class="string">这是一个实例图片</span> <span class="string">%&#125;</span></span><br><span class="line"><span class="string">&#123;%</span> <span class="string">asset_img</span> <span class="string">"spaced asset.jpg"</span> <span class="string">"spaced title"</span> <span class="string">%&#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="添加动态模型插件"><a href="#添加动态模型插件" class="headerlink" title="添加动态模型插件"></a>添加动态模型插件</h4><p><a href="https://github.com/EYHN/hexo-helper-live2d/blob/master/README.zh-CN.md">中文文档</a></p>
<h5 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">安装插件</span></span><br><span class="line">npm install --save hexo-helper-live2d</span><br><span class="line"><span class="meta">#</span><span class="bash">安装动态模型，此处可以选择自己喜欢的模型 https://huaji8.top/post/live2d-plugin-2.0/</span></span><br><span class="line">npm install --save live2d-widget-model-z16</span><br></pre></td></tr></table></figure>

<h5 id="在-themes-next-layout-layout-njk添加"><a href="#在-themes-next-layout-layout-njk添加" class="headerlink" title="在 ~/themes/next/layout/layout.njk添加"></a>在 <code>~/themes/next/layout/layout.njk</code>添加</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#末尾添加就行</span><br><span class="line">&#123;&#123; live2d() &#125;&#125;</span><br></pre></td></tr></table></figure>

<h5 id="配置-config-yml"><a href="#配置-config-yml" class="headerlink" title="配置~/_config.yml"></a>配置<code>~/_config.yml</code></h5><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 添加动态模型插件</span></span><br><span class="line"><span class="attr">live2d:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">scriptFrom:</span> <span class="string">local</span></span><br><span class="line">  <span class="attr">pluginRootPath:</span> <span class="string">live2dw/</span></span><br><span class="line">  <span class="attr">pluginJsPath:</span> <span class="string">lib/</span></span><br><span class="line">  <span class="attr">pluginModelPath:</span> <span class="string">assets/</span></span><br><span class="line">  <span class="attr">tagMode:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">debug:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">model:</span></span><br><span class="line">    <span class="attr">use:</span> <span class="string">live2d-widget-model-z16</span> <span class="comment">## 对应安装的宠物依赖包</span></span><br><span class="line">  <span class="attr">display:</span></span><br><span class="line">    <span class="attr">position:</span> <span class="string">right</span>  <span class="comment">##位置</span></span><br><span class="line">    <span class="attr">width:</span> <span class="number">150</span></span><br><span class="line">    <span class="attr">height:</span> <span class="number">300</span></span><br><span class="line">  <span class="attr">mobile:</span></span><br><span class="line">    <span class="attr">show:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">react:</span></span><br><span class="line">    <span class="attr">opacity:</span> <span class="number">0.7</span></span><br></pre></td></tr></table></figure>

<h4 id="添加音乐"><a href="#添加音乐" class="headerlink" title="添加音乐"></a>添加音乐</h4><h5 id="直接使用-HTML-的标签，格式如下，其中-music-url-替换为你需要加载的音乐即可："><a href="#直接使用-HTML-的标签，格式如下，其中-music-url-替换为你需要加载的音乐即可：" class="headerlink" title="直接使用 HTML 的标签，格式如下，其中 music-url 替换为你需要加载的音乐即可："></a>直接使用 HTML 的标签，格式如下，其中 <code>music-url</code> 替换为你需要加载的音乐即可：</h5><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">audio</span> <span class="attr">src</span>=<span class="string">"music-url"</span> <span class="attr">style</span>=<span class="string">"max-height :100%; max-width: 100%; display: block; margin-left: auto; margin-right: auto;"</span> <span class="attr">controls</span>=<span class="string">"controls"</span> <span class="attr">loop</span>=<span class="string">"loop"</span> <span class="attr">preload</span>=<span class="string">"meta"</span>&gt;</span>Your browser does not support the audio tag.<span class="tag">&lt;/<span class="name">audio</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="使用hexo-tag-aplayer插件"><a href="#使用hexo-tag-aplayer插件" class="headerlink" title="使用hexo-tag-aplayer插件"></a>使用<a href="https://github.com/MoePlayer/hexo-tag-aplayer">hexo-tag-aplayer</a>插件</h5><h6 id="安装插件-2"><a href="#安装插件-2" class="headerlink" title="安装插件"></a>安装插件</h6><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-tag-aplayer --save</span><br></pre></td></tr></table></figure>

<h6 id="载入标签格式如下："><a href="#载入标签格式如下：" class="headerlink" title="载入标签格式如下："></a>载入标签格式如下：</h6><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;% aplayer <span class="string">"歌曲名"</span> <span class="string">"歌手名"</span> <span class="string">"https://什么什么什么.mp3"</span> <span class="string">"https://封面图.jpg"</span> <span class="string">"lrc:https://歌词.lrc"</span> %&#125;</span><br></pre></td></tr></table></figure>

<h6 id="歌单："><a href="#歌单：" class="headerlink" title="歌单："></a>歌单：</h6><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;% aplayerlist %&#125;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"autoplay"</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="string">"showlrc"</span>: <span class="number">3</span>,</span><br><span class="line">    <span class="string">"mutex"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">"music"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">"title"</span>: <span class="string">"歌曲名"</span>,</span><br><span class="line">            <span class="string">"author"</span>: <span class="string">"歌手名"</span>,</span><br><span class="line">            <span class="string">"url"</span>: <span class="string">"https://什么什么什么.mp3"</span>,</span><br><span class="line">            <span class="string">"pic"</span>: <span class="string">"https://封面图.jpg"</span>,</span><br><span class="line">            <span class="string">"lrc"</span>: <span class="string">"https://歌词.lrc"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">"title"</span>: <span class="string">"歌曲名"</span>,</span><br><span class="line">            <span class="string">"author"</span>: <span class="string">"歌手名"</span>,</span><br><span class="line">            <span class="string">"url"</span>: <span class="string">"https://什么什么什么.mp3"</span>,</span><br><span class="line">            <span class="string">"pic"</span>: <span class="string">"https://封面图.jpg"</span>,</span><br><span class="line">            <span class="string">"lrc"</span>: <span class="string">"https://歌词.lrc"</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line">&#123;% endaplayerlist %&#125;</span><br></pre></td></tr></table></figure>

<h6 id="网易云音乐生成外链"><a href="#网易云音乐生成外链" class="headerlink" title="网易云音乐生成外链"></a>网易云音乐生成外链</h6><p>网页中打开<a href="https://music.163.com/" target="_blank" rel="noopener">网易云官网</a></p>
<p><img data-src="%E7%BD%91%E6%98%93%E4%BA%91%E9%9F%B3%E4%B9%90.png" alt="网易云音乐"></p>
<p>生成外链代码</p>
<p><img data-src="%E7%94%9F%E6%88%90%E9%9F%B3%E4%B9%90%E5%A4%96%E9%93%BE%E4%BB%A3%E7%A0%81.png" alt="生成音乐外链代码"></p>
<p>将外链代码插入到侧边栏文件<code>~/themes/next/layout/_macro/sidebar.swig</code></p>
<h4 id="添加视频"><a href="#添加视频" class="headerlink" title="添加视频"></a>添加视频</h4><h5 id="HTML-的标签"><a href="#HTML-的标签" class="headerlink" title="HTML 的标签"></a>HTML 的标签</h5><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">poster</span>=<span class="string">"https://封面图.jpg"</span> <span class="attr">src</span>=<span class="string">"https://什么什么什么.mp4"</span> <span class="attr">style</span>=<span class="string">"max-height :100%; max-width: 100%; display: block; margin-left: auto; margin-right: auto;"</span> <span class="attr">controls</span>=<span class="string">"controls"</span> <span class="attr">loop</span>=<span class="string">"loop"</span> <span class="attr">preload</span>=<span class="string">"meta"</span>&gt;</span>Your browser does not support the video tag.<span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="hexo-tag-dplayer插件"><a href="#hexo-tag-dplayer插件" class="headerlink" title="hexo-tag-dplayer插件"></a><a href="https://github.com/MoePlayer/hexo-tag-dplayer">hexo-tag-dplayer</a>插件</h5><h6 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h6><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-tag-dplayer --save</span><br></pre></td></tr></table></figure>

<h6 id="插入文章"><a href="#插入文章" class="headerlink" title="插入文章"></a>插入文章</h6><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;% dplayer <span class="string">"url=https://什么什么什么.mp4"</span> <span class="string">"https://封面图.jpg"</span> <span class="string">"api=https://api.prprpr.me/dplayer/"</span> <span class="string">"id="</span> <span class="string">"loop=false"</span> %&#125;</span><br></pre></td></tr></table></figure>

<h4 id="文末添加相关文章"><a href="#文末添加相关文章" class="headerlink" title="文末添加相关文章"></a>文末添加相关文章</h4><h5 id="hexo-recommended-posts插件"><a href="#hexo-recommended-posts插件" class="headerlink" title="hexo-recommended-posts插件"></a><a href="https://github.com/huiwang/hexo-recommended-posts">hexo-recommended-posts</a>插件</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-recommended-posts --save</span><br></pre></td></tr></table></figure>

<h5 id="在编辑完新的文章之后，使用如下命令获取推荐列表"><a href="#在编辑完新的文章之后，使用如下命令获取推荐列表" class="headerlink" title="在编辑完新的文章之后，使用如下命令获取推荐列表"></a>在编辑完新的文章之后，使用如下命令获取推荐列表</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo recommend</span><br></pre></td></tr></table></figure>

<h5 id="如果你对默认显示的位置和样式不满意，可以进行自定义设定。在博客根目录的-config-yml-添加："><a href="#如果你对默认显示的位置和样式不满意，可以进行自定义设定。在博客根目录的-config-yml-添加：" class="headerlink" title="如果你对默认显示的位置和样式不满意，可以进行自定义设定。在博客根目录的 _config.yml 添加："></a>如果你对默认显示的位置和样式不满意，可以进行自定义设定。在博客根目录的 <code>_config.yml</code> 添加：</h5><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Dependency: https://github.com/huiwang/hexo-recommended-posts</span></span><br><span class="line"><span class="attr">recommended_posts:</span></span><br><span class="line">  <span class="attr">server:</span> <span class="string">https://api.truelaurel.com</span> <span class="comment">#后端推荐服务器地址</span></span><br><span class="line">  <span class="attr">timeoutInMillis:</span> <span class="number">10000</span> <span class="comment">#服务时长，超过此时长，则使用离线推荐模式</span></span><br><span class="line">  <span class="attr">internalLinks:</span> <span class="number">3</span> <span class="comment">#内部文章数量</span></span><br><span class="line">  <span class="attr">externalLinks:</span> <span class="number">1</span> <span class="comment">#外部文章数量</span></span><br><span class="line">  <span class="attr">fixedNumber:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">autoDisplay:</span> <span class="literal">true</span> <span class="comment">#自动在文章底部显示推荐文章</span></span><br><span class="line">  <span class="attr">excludePattern:</span> <span class="string">[]</span></span><br><span class="line">  <span class="attr">titleHtml:</span> <span class="string">&lt;h1&gt;推荐文章&lt;span</span> <span class="string">style="font-size:0.45em;</span> <span class="string">color:gray"&gt;（由&lt;a</span> <span class="string">href="https://github.com/huiwang/hexo-recommended-posts"&gt;hexo文章推荐插件&lt;/a&gt;驱动）&lt;/span&gt;&lt;/h1&gt;</span> <span class="comment">#自定义标题</span></span><br></pre></td></tr></table></figure>

<p>其中 <code>excludePattern</code> 可以添加想要被过滤的链接的正则表达式, 如配置为 <code>[&quot;example.com&quot;]</code>, 则所有包含 <code>example.com</code> 的链接都会从推荐文章中过滤掉.</p>
<p><code>fixedNumber</code> 字段用来控制是否返回固定数量的推荐文章, 如果默认推荐文章不够的话会填充当前文章的前后文章作为推荐文章.</p>
<h5 id="在主题根目录的-config-yml-添加："><a href="#在主题根目录的-config-yml-添加：" class="headerlink" title="在主题根目录的 _config.yml 添加："></a>在主题根目录的 <code>_config.yml</code> 添加：</h5><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 推荐文章</span></span><br><span class="line"><span class="attr">recommended_posts:</span></span><br><span class="line">  <span class="attr">enabled:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h5 id="在主题语言包中添加："><a href="#在主题语言包中添加：" class="headerlink" title="在主题语言包中添加："></a>在主题语言包中添加：</h5><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 文件位置：~/theme/next/languages/zh-CN.yml</span></span><br><span class="line"><span class="attr">copyright:</span></span><br><span class="line">    <span class="attr">author:</span> <span class="string">本文作者</span></span><br><span class="line">    <span class="attr">link:</span> <span class="string">本文链接</span></span><br><span class="line">    <span class="attr">license_title:</span> <span class="string">版权声明</span></span><br><span class="line">    <span class="attr">license_content:</span> <span class="string">"本博客所有文章除特别声明外，均采用 %s 许可协议。转载请注明出处！"</span></span><br><span class="line">    <span class="attr">recommended_posts:</span> <span class="string">推荐文章</span></span><br></pre></td></tr></table></figure>

<h5 id="主题配置文件中开启-post-body-后的自定义文件"><a href="#主题配置文件中开启-post-body-后的自定义文件" class="headerlink" title="主题配置文件中开启 post-body 后的自定义文件"></a>主题配置文件中开启 <code>post-body</code> 后的自定义文件</h5><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">custom_file_path:</span></span><br><span class="line">  <span class="attr">postBodyEnd:</span> <span class="string">source/_data/post-body-end.njk</span></span><br></pre></td></tr></table></figure>

<h5 id="在-source-data-下新建文件-post-body-end-njk："><a href="#在-source-data-下新建文件-post-body-end-njk：" class="headerlink" title="在 ~/source/_data/ 下新建文件 post-body-end.njk："></a>在 <code>~/source/_data/</code> 下新建文件 <code>post-body-end.njk</code>：</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;!-- 文件位置：~<span class="regexp">/source/</span>_data/post-body-end.swig --&gt;</span><br><span class="line"></span><br><span class="line">&#123;% <span class="keyword">if</span> theme.recommended_posts.enabled and not is_index %&#125;</span><br><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"post-body"</span>&gt;</span><br><span class="line">  &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"note primary"</span>&gt;</span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"recommended_posts"</span>&gt;</span><br><span class="line">      &#123;% <span class="keyword">set</span> recommended_posts = recommended_posts(post, site) %&#125;</span><br><span class="line">      &#123;% <span class="keyword">if</span> recommended_posts.length &gt; <span class="number">0</span> %&#125;</span><br><span class="line">        &lt;h4&gt;&#123;&#123; __(<span class="string">'推荐文章'</span>) &#125;&#125;&lt;<span class="regexp">/h4&gt;</span></span><br><span class="line"><span class="regexp">        &lt;ul&gt;</span></span><br><span class="line"><span class="regexp">          &#123;% for link in recommended_posts  %&#125;</span></span><br><span class="line"><span class="regexp">            &lt;li&gt;&lt;a href="&#123;&#123; link.permalink &#125;&#125;"&gt;&#123;&#123; link.title &#125;&#125;&lt;/</span>a&gt;&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">          &#123;% endfor %&#125;</span></span><br><span class="line"><span class="regexp">        &lt;/u</span>l&gt;</span><br><span class="line">      &#123;% endif %&#125; </span><br><span class="line">    &lt;<span class="regexp">/div&gt; </span></span><br><span class="line"><span class="regexp">  &lt;/</span>div&gt;</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&#123;% endif %&#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="添加结束标语"><a href="#添加结束标语" class="headerlink" title="添加结束标语"></a>添加结束标语</h4><h5 id="同样需要在-post-body-end-swig-文件中添加内容，开启自定义文件的功能参考上文。"><a href="#同样需要在-post-body-end-swig-文件中添加内容，开启自定义文件的功能参考上文。" class="headerlink" title="同样需要在 post-body-end.swig 文件中添加内容，开启自定义文件的功能参考上文。"></a>同样需要在 <code>post-body-end.swig</code> 文件中添加内容，开启自定义文件的功能参考<a href="https://guanqr.com/tech/website/hexo-theme-next-customization/#文末添加相关文章" target="_blank" rel="noopener">上文</a>。</h5><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    &#123;% if not is_index %&#125;</span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"end-slogan"</span> <span class="attr">style</span>=<span class="string">"text-align:center;font-size:13px;letter-spacing:10px;user-select:none;color:#bbb;"</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span>本文结束啦<span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"fa fa-star"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span>感谢您阅读<span class="tag">&lt;<span class="name">br</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    &#123;% endif %&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="在博客根目录的-config-yml-添加："><a href="#在博客根目录的-config-yml-添加：" class="headerlink" title="在博客根目录的 _config.yml 添加："></a>在博客根目录的 <code>_config.yml</code> 添加：</h5><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 文章末尾添加「本文结束」标记</span></span><br><span class="line"><span class="attr">passage_end_tag:</span></span><br><span class="line">  <span class="attr">enabled:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2>]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>GitPages</tag>
        <tag>个人博客</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM系列(一)JVM类加载机制</title>
    <url>/blog/2022/08/01/JVM%E7%B3%BB%E5%88%97(%E4%B8%80)JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/blog/assets/css/APlayer.min.css"><script src="/blog/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="类加载器初始化以及加载类的过程"><a href="#类加载器初始化以及加载类的过程" class="headerlink" title="类加载器初始化以及加载类的过程"></a>类加载器初始化以及加载类的过程</h2><h3 id="在什么时候才会启动类加载器"><a href="#在什么时候才会启动类加载器" class="headerlink" title="在什么时候才会启动类加载器?"></a>在什么时候才会启动类加载器?</h3><p>其实,类加载器并不需要等到某个类被“首次主动使用”时再加载它,JVM规范允许类加载器在预料某个类将要被使用时就预先加载它,如果在预先加载的过程中遇到了.class文件缺失或存在错误,类加载器必须在程序首次主动使用该类时才报告错误(LinkgeError)错误,如果这个类一直没有被程序主动使用,那么类加载器就不会报错误.</p>
<h3 id="从那个地方去加载-class文件"><a href="#从那个地方去加载-class文件" class="headerlink" title="从那个地方去加载.class文件"></a>从那个地方去加载.class文件</h3><p>在这里进行一个简单的分类:</p>
<ol>
<li>本地磁盘</li>
<li>网上加载.class(Applet)</li>
<li>从数据库中</li>
<li>压缩文件中(ZAR,Jar等)</li>
<li>从其他文件生成的(JSP应用)</li>
</ol>
<h3 id="LoadClass的类加载过程"><a href="#LoadClass的类加载过程" class="headerlink" title="LoadClass的类加载过程"></a>LoadClass的类加载过程</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Math</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> initData = <span class="number">666</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> User user = <span class="keyword">new</span> User();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compute</span><span class="params">()</span> </span>&#123; <span class="comment">//一个方法对应一块栈帧内存区域</span></span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> c = (a + b) * <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Math math = <span class="keyword">new</span> Math();</span><br><span class="line">        math.compute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img data-src="JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6.jpg" alt="JVM类加载机制"></p>
<p>类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：<strong>加载、验证、准备、解析、初始化</strong>、使用和卸载七个阶段。它们的顺序如下图所示：</p>
<img data-src="类加载生命周期.png" alt="类加载生命周期"  />

<h4 id="加载-Loading"><a href="#加载-Loading" class="headerlink" title="加载(Loading)"></a>加载(Loading)</h4><p>”加载“是”类加机制”的第一个过程，在加载阶段，虚拟机主要完成三件事：</p>
<ol>
<li>通过一个类的全限定名来获取其定义的二进制字节流</li>
<li>将这个字节流所代表的的静态存储结构转化为方法区的运行时数据结构</li>
<li>在堆中生成一个代表这个类的Class对象，作为方法区中这些数据的访问入口</li>
</ol>
<p>在硬盘上查找并通过IO读入字节码文件,使用到类时才会加载,例如调用类的main()方法,new对象等,在加载阶段会在内存中生成一个代表这个类的java.lang.Class对象,作为方法区这个类的各种数据的访问入口.</p>
<h4 id="验证-Verification"><a href="#验证-Verification" class="headerlink" title="验证(Verification)"></a>验证(Verification)</h4><p>验证的主要作用就是确保被==<strong>加载的类的正确性</strong>==。也是连接阶段的第一步。说白了也就是我们加载好的.class文件不能对我们的虚拟机有危害，所以先检测验证一下。他主要是完成四个阶段的验证：</p>
<p>（1）文件格式的验证：验证.class文件字节流是否符合class文件的格式的规范，并且能够被当前版本的虚拟机处理。这里面主要对魔数、主版本号、常量池等等的校验（魔数、主版本号都是.class文件里面包含的数据信息、在这里可以不用理解）。</p>
<p>（2）元数据验证：主要是对字节码描述的信息进行语义分析，以保证其描述的信息符合java语言规范的要求，比如说验证这个类是不是有父类，类中的字段方法是不是和父类冲突等等。</p>
<p>（3）字节码验证：这是整个验证过程最复杂的阶段，主要是通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。在元数据验证阶段对数据类型做出验证后，这个阶段主要对类的方法做出分析，保证类的方法在运行时不会做出危害虚拟机安全的事。</p>
<p>（4）符号引用验证：它是验证的最后一个阶段，发生在虚拟机将符号引用转化为直接引用的时候。主要是对类自身以外的信息进行校验。目的是确保解析动作能够完成。</p>
<p>对整个类加载机制而言，验证阶段是一个很重要但是非必需的阶段，如果我们的代码能够确保没有问题，那么我们就没有必要去验证，毕竟验证需要花费一定的的时间。当然我们可以使用-Xverfity:none来关闭大部分的验证。</p>
<h4 id="准备-Preparation"><a href="#准备-Preparation" class="headerlink" title="准备(Preparation)"></a>准备(Preparation)</h4><p>准备阶段主要为<strong>==类变量分配内存并设置初始值==</strong>。这些内存都在方法区分配。在这个阶段我们只需要注意两点就好了，也就是类变量和初始值两个关键词：</p>
<p>（1）类变量（static）会分配内存，但是实例变量不会，实例变量主要随着对象的实例化一块分配到java堆中，</p>
<p>（2）这里的初始值指的是数据类型默认值，而不是代码中被显示赋予的值。比如</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> value = <span class="number">1</span>; </span><br><span class="line"><span class="comment">//在这里准备阶段过后的value值为0，而不是1。赋值为1的动作在初始化阶段。</span></span><br></pre></td></tr></table></figure>

<p>注意，在上面value是被static所修饰的准备阶段之后是0，但是如果同时被final和static修饰准备阶段之后就是1了。我们可以理解为static final在编译器就将结果放入调用它的类的常量池中了。</p>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td>int</td>
<td>0</td>
</tr>
<tr>
<td>boolean</td>
<td>false</td>
</tr>
<tr>
<td>long</td>
<td>0L</td>
</tr>
<tr>
<td>float</td>
<td>0.0f</td>
</tr>
<tr>
<td>double</td>
<td>0.0d</td>
</tr>
<tr>
<td>char</td>
<td>‘\u000’</td>
</tr>
<tr>
<td>reference</td>
<td>null</td>
</tr>
</tbody></table>
<h4 id="解析-Resolution"><a href="#解析-Resolution" class="headerlink" title="解析(Resolution)"></a>解析(Resolution)</h4><p>解析阶段主要是虚拟机将==常量池中的<strong>符号引用转化为直接引用的过程</strong>==。</p>
<p>解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行。</p>
<p>将<strong>符号引用</strong>替换为直接引用,该阶段会把一些静态方法(符号引用,比如main()方法)替换为指向数据所存内存的指针或句柄等(直接引用),这是所谓的<strong>静态链接</strong>过程(类加载期间完成),<strong>动态链接</strong>是在程序运行期间完成的将符号引用替换为直接引用</p>
<h5 id="符号引用"><a href="#符号引用" class="headerlink" title="符号引用"></a>符号引用</h5><p>以一组符号来描述所引用的目标,可以是任何形式的字面量,只要是能无歧义的定位到目标就好</p>
<h5 id="直接引用"><a href="#直接引用" class="headerlink" title="直接引用"></a>直接引用</h5><p>直接引用时可以指向目标的指针,相对偏移量或者是一个直接或间接定位到目标的句柄,和虚拟机实现的内存有关,不同的虚拟机直接引用不同.</p>
<h4 id="初始化-Initialization"><a href="#初始化-Initialization" class="headerlink" title="初始化(Initialization)"></a>初始化(Initialization)</h4><p>这是类加载机制的最后一步，在这个阶段，java程序代码才开始真正执行。我们知道，在准备阶段已经为类变量赋过一次值。在初始化阶端，程序可以根据自己的需求来赋值了。一句话描述这个阶段就是执行类构造器&lt; clinit &gt;()方法的过程。</p>
<p>在初始化阶段，主要为<strong>==类的静态变量赋予正确的初始值，JVM负责对类进行初始化==</strong>，主要对类变量进行初始化。在Java中对类变量进行初始值设定有两种方式：</p>
<p>①声明类变量是指定初始值</p>
<p>②使用静态代码块为类变量指定初始值</p>
<p>JVM初始化步骤:</p>
<p>1、假如这个类还没有被加载和连接，则程序先加载并连接该类</p>
<p>2、假如该类的直接父类还没有被初始化，则先初始化其直接父类</p>
<p>3、假如类中有初始化语句，则系统依次执行这些初始化语句</p>
<p>类初始化时机：只有当对类的主动使用的时候才会导致类的初始化，类的主动使用包括以下六种：</p>
<ul>
<li>创建类的实例，也就是new的方式</li>
<li>访问某个类或接口的静态变量，或者对该静态变量赋值</li>
<li>调用类的静态方法</li>
<li>反射（如 Class.forName(“com.fly.Test”)）</li>
<li>初始化某个类的子类，则其父类也会被初始化</li>
<li>Java虚拟机启动时被标明为启动类的类，直接使用 java.exe命令来运行某个主类</li>
</ul>
<h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><p><img data-src="%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B.jpg" alt="类加载过程"></p>
<p>类被加载到方法区中后主要包含 <strong>运行时常量池、类型信息、字段信息、方法信息、类加载器的引用、对应class实例的引用</strong>等信息。</p>
<p><strong>类加载器的引用</strong>：这个类到类加载器实例的引用</p>
<p><strong>对应class实例的引用</strong>：类加载器在加载类信息放到方法区中后，会创建一个对应的Class 类型的对象实例放到堆(Heap)中, 作为开发人员访问方法区中类定义的入口和切入点。</p>
<p><strong>注意</strong>，主类在运行过程中如果使用到其它类，会逐步加载这些类。</p>
<p>jar包或war包里的类不是一次性全部加载的，是使用到时才加载。</p>
<p>上面的类加载过程主要是通过类加载器来实现的，Java里有如下几种类加载器</p>
<h3 id="引导类加载器—BootStrap-ClassLoader"><a href="#引导类加载器—BootStrap-ClassLoader" class="headerlink" title="引导类加载器—BootStrap ClassLoader"></a>引导类加载器—BootStrap ClassLoader</h3><p>最顶层的加载类，<strong>负责加载支撑JVM运行的位于JRE的lib目录下的核心类库</strong>，也就是我们环境变量下面%JRE_HOME%\lib下的rt.jar、resources.jar、charsets.jar和class等。另外需要注意的是可以通过启动jvm时指定-Xbootclasspath和路径来改变Bootstrap ClassLoader的加载目录。比如java -Xbootclasspath/a:path被指定的文件追加到默认的bootstrap路径中。</p>
<h3 id="扩展类加载器—Extension-ClassLoader"><a href="#扩展类加载器—Extension-ClassLoader" class="headerlink" title="扩展类加载器—Extension ClassLoader"></a>扩展类加载器—Extension ClassLoader</h3><p>扩展的类加载器，负责加载支撑JVM运行的位于JRE的lib目录下的ext扩展目录中的JAR类包,加载目录%JRE_HOME%\lib\ext目录下的jar包和class文件。还可以加载-D java.ext.dirs选项指定的目录。</p>
<h3 id="应用程序类加载器—Application-ClassLoader"><a href="#应用程序类加载器—Application-ClassLoader" class="headerlink" title="应用程序类加载器—Application ClassLoader"></a>应用程序类加载器—Application ClassLoader</h3><p>也称为SystemAppClass,负责加载ClassPath路径下的类包,主要就是加载你自己写的那些类.</p>
<h3 id="自定义加载器—User-ClassLoader"><a href="#自定义加载器—User-ClassLoader" class="headerlink" title="自定义加载器—User ClassLoader"></a>自定义加载器—User ClassLoader</h3><p>负责加载用户自定义路径下的类包</p>
<h3 id="类加载的三种方式"><a href="#类加载的三种方式" class="headerlink" title="类加载的三种方式"></a>类加载的三种方式</h3><p>类加载的三种方式。</p>
<p>（1）通过命令行启动应用时由JVM初始化加载含有main()方法的主类。</p>
<p>（2）通过Class.forName()方法动态加载，会默认执行初始化块（static{}），但是Class.forName(name,initialize,loader)中的initialze可指定是否要执行初始化块。</p>
<p>（3）通过ClassLoader.loadClass()方法动态加载，不会执行初始化块。</p>
<h2 id="类加载器初始化过程-双亲委派"><a href="#类加载器初始化过程-双亲委派" class="headerlink" title="类加载器初始化过程- 双亲委派"></a>类加载器初始化过程- 双亲委派</h2><p>在Launcher构造方法内部，其创建了两个类加载器，分别是sun.misc.Launcher.ExtClassLoader(扩展类加载器)和sun.misc.Launcher.AppClassLoader(应用类加载器)。</p>
<p>JVM默认使用Launcher的getClassLoader()方法返回的类加载器AppClassLoader的实例加载我们的应用程序。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Launcher的构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Launcher</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Launcher.ExtClassLoader var1;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//构造扩展类加载器，在构造的过程中将其父加载器设置为null</span></span><br><span class="line">        var1 = Launcher.ExtClassLoader.getExtClassLoader();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException var10) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(<span class="string">"Could not create extension class loader"</span>, var10);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//构造应用类加载器，在构造的过程中将其父加载器设置为ExtClassLoader，</span></span><br><span class="line">        <span class="comment">//Launcher的loader属性值是AppClassLoader，我们一般都是用这个类加载器来加载我们自己写的应用程序</span></span><br><span class="line">        <span class="keyword">this</span>.loader = Launcher.AppClassLoader.getAppClassLoader(var1);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException var9) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(<span class="string">"Could not create application class loader"</span>, var9);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Thread.currentThread().setContextClassLoader(<span class="keyword">this</span>.loader);</span><br><span class="line">    String var2 = System.getProperty(<span class="string">"java.security.manager"</span>);</span><br><span class="line">    。。。 。。。 <span class="comment">//省略一些不需关注代码</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img data-src="%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6.jpg" alt="双亲委派机制"></p>
<p>这里类加载其实就有一个<strong>双亲委派机制</strong>，加载某个类时会先委托父加载器寻找目标类，找不到再委托上层父加载器加载，如果所有父加载器在自己的加载类路径下都找不到目标类，则在自己的类加载路径中查找并载入目标类。</p>
<p>比如我们的Math类，最先会找应用程序类加载器加载，应用程序类加载器会先委托扩展类加载器加载，扩展类加载器再委托引导类加载器，顶层引导类加载器在自己的类加载路径里找了半天没找到Math类，则向下退回加载Math类的请求，扩展类加载器收到回复就自己加载，在自己的类加载路径里找了半天也没找到Math类，又向下退回Math类的加载请求给应用程序类加载器，应用程序类加载器于是在自己的类加载路径里找Math类，结果找到了就自己加载了。</p>
<p><strong>双亲委派机制说简单点就是，先找父亲加载，不行再由儿子自己加载</strong></p>
<p>我们来看下应用程序类加载器AppClassLoader加载类的双亲委派机制源码，AppClassLoader的loadClass方法最终会调用其父类ClassLoader的loadClass方法，该方法的大体逻辑如下：</p>
<ol>
<li>首先，检查一下指定名称的类是否已经加载过，如果加载过了，就不需要再加载，直接返回。</li>
<li>如果此类没有加载过，那么，再判断一下是否有父加载器；如果有父加载器，则由父加载器加载（即调用parent.loadClass(name, false);）.或者是调用bootstrap类加载器来加载。</li>
<li>如果父加载器及bootstrap类加载器都没有找到指定的类，那么调用当前类加载器的findClass方法来完成类加载。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ClassLoader的loadClass方法，里面实现了双亲委派机制</span></span><br><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)</span><br><span class="line">    <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">        <span class="comment">// 检查当前类加载器是否已经加载了该类</span></span><br><span class="line">        Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">long</span> t0 = System.nanoTime();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;  <span class="comment">//如果当前加载器父加载器不为空则委托父加载器加载该类</span></span><br><span class="line">                    c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;  <span class="comment">//如果当前加载器父加载器为空则委托引导类加载器加载该类</span></span><br><span class="line">                    c = findBootstrapClassOrNull(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// If still not found, then invoke findClass in order</span></span><br><span class="line">                <span class="comment">// to find the class.</span></span><br><span class="line">                <span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line">                <span class="comment">//都会调用URLClassLoader的findClass方法在加载器的类路径里查找并加载该类</span></span><br><span class="line">                c = findClass(name);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resolve) &#123;  <span class="comment">//不会执行</span></span><br><span class="line">            resolveClass(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="为什么要设计双亲委派机制？"><a href="#为什么要设计双亲委派机制？" class="headerlink" title="为什么要设计双亲委派机制？"></a><strong>为什么要设计双亲委派机制？</strong></h3><ul>
<li>沙箱安全机制：自己写的java.lang.String.class类不会被加载，这样便可以防止核心API库被随意篡改</li>
<li>避免类的重复加载：当父类已经加载了该类时，就没有必要子类ClassLoader再加载一次，保证<strong>被加载类的唯一性</strong></li>
</ul>
<h3 id="全盘负责委托机制"><a href="#全盘负责委托机制" class="headerlink" title="全盘负责委托机制"></a><strong>全盘负责委托机制</strong></h3><p><strong>“全盘负责”是指当一个ClassLoder装载一个类时，除非显示的使用另外一个ClassLoder，该类所依赖及引用的类也由这个ClassLoder载入。</strong></p>
<h3 id="为什么加载类要子类委托给父类，而不是直接从引导类加载器向下加载"><a href="#为什么加载类要子类委托给父类，而不是直接从引导类加载器向下加载" class="headerlink" title="为什么加载类要子类委托给父类，而不是直接从引导类加载器向下加载?"></a>为什么加载类要子类委托给父类，而不是直接从引导类加载器向下加载?</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 检查当前类加载器是否已经加载了该类</span><br><span class="line">Class&lt;?&gt; c &#x3D; findLoadedClass(name);</span><br></pre></td></tr></table></figure>

<p>站在设计角度来看我们写的程序大部分(95%)都是由应用程序加载器进行加载,并且根据源码我们得知加载时会先检查当前类加载器是否已经加载了该类,只有第一次加载某个类时会向上进行委托,等下次再使用这个类时由于已经被加载过,那么直接从应用程序类加载器获取就可以.如果直接从引导类加载器进行加载,那么每次都要从上到下去进行加载,会影响性能,且设计不合理.</p>
<h2 id="自定义类加载器"><a href="#自定义类加载器" class="headerlink" title="自定义类加载器"></a>自定义类加载器</h2><p>自定义类加载器只需要继承 java.lang.ClassLoader 类，该类有两个核心方法，一个是loadClass(String, boolean)，实现了<strong>双亲委派机制</strong>，还有一个方法是findClass，默认实现是空方法，所以我们自定义类加载器主要是<strong>重写findClass方法</strong>。</p>
<p>（1）遵守双亲委派模型：继承ClassLoader,重写findClass()方法。</p>
<p>（2）破坏双亲委派模型：继承ClassLoader,重写loadClass()方法。 通常我们推荐采用第一种方法自定义类加载器，最大程度上的遵守双亲委派模型。</p>
<h3 id="遵循双亲委派机制"><a href="#遵循双亲委派机制" class="headerlink" title="遵循双亲委派机制"></a>遵循双亲委派机制</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClassLoaderTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String classPath;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MyClassLoader</span><span class="params">(String classPath)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.classPath = classPath;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">byte</span>[] loadByte(String name) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            name = name.replaceAll(<span class="string">"\\."</span>, <span class="string">"/"</span>);</span><br><span class="line">            FileInputStream fis = <span class="keyword">new</span> FileInputStream(classPath + <span class="string">"/"</span> + name</span><br><span class="line">                    + <span class="string">".class"</span>);</span><br><span class="line">            <span class="keyword">int</span> len = fis.available();</span><br><span class="line">            <span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[len];</span><br><span class="line">            fis.read(data);</span><br><span class="line">            fis.close();</span><br><span class="line">            <span class="keyword">return</span> data;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">byte</span>[] data = loadByte(name);</span><br><span class="line">                <span class="comment">//defineClass将一个字节数组转为Class对象，这个字节数组是class文件读取后最终的字节数组。</span></span><br><span class="line">                <span class="keyword">return</span> defineClass(name, data, <span class="number">0</span>, data.length);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="comment">//初始化自定义类加载器，会先初始化父类ClassLoader，其中会把自定义类加载器的父加载器设置为应用程序类加载器AppClassLoader</span></span><br><span class="line"><span class="comment">//            MyClassLoader classLoader = new MyClassLoader("/Users/fly/work/myproject");</span></span><br><span class="line">            MyClassLoader classLoader = <span class="keyword">new</span> MyClassLoader(<span class="string">"/Users/fly/work/myproject/tuling-learn/src/main/java"</span>);</span><br><span class="line">            <span class="comment">///Users/fly/work/myproject 创建 test.com.fly 几级目录，将User类的复制类User1.class丢入该目录</span></span><br><span class="line"><span class="comment">//            Class clazz = classLoader.loadClass("com.fly.jvm.User1");</span></span><br><span class="line">            Class clazz = classLoader.loadClass(<span class="string">"test.com.fly.User1"</span>);</span><br><span class="line">            Object obj = clazz.newInstance();</span><br><span class="line">            Method method = clazz.getDeclaredMethod(<span class="string">"sout"</span>, <span class="keyword">null</span>);</span><br><span class="line">            method.invoke(obj, <span class="keyword">null</span>);</span><br><span class="line">            System.out.println(clazz.getClassLoader().getClass().getName());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：<br>=======自己的加载器加载类调用方法=======<br>User1<br>com.fly.jvm.MyClassLoaderTest$MyClassLoader</p>
<h3 id="打破双亲委派机制"><a href="#打破双亲委派机制" class="headerlink" title="打破双亲委派机制"></a>打破双亲委派机制</h3><p>再来一个沙箱安全机制示例，尝试打破双亲委派机制，用自定义类加载器加载我们自己实现的 java.lang.String.class</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClassLoaderTest2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClassLoader2</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String classPath;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MyClassLoader2</span><span class="params">(String classPath)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.classPath = classPath;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">byte</span>[] loadByte(String name) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            name = name.replaceAll(<span class="string">"\\."</span>, <span class="string">"/"</span>);</span><br><span class="line">            FileInputStream fis = <span class="keyword">new</span> FileInputStream(classPath + <span class="string">"/"</span> + name</span><br><span class="line">                    + <span class="string">".class"</span>);</span><br><span class="line">            <span class="keyword">int</span> len = fis.available();</span><br><span class="line">            <span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[len];</span><br><span class="line">            fis.read(data);</span><br><span class="line">            fis.close();</span><br><span class="line">            <span class="keyword">return</span> data;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">byte</span>[] data = loadByte(name);</span><br><span class="line">                <span class="comment">//defineClass将一个字节数组转为Class对象，这个字节数组是class文件读取后最终的字节数组。</span></span><br><span class="line">                <span class="keyword">return</span> defineClass(name, data, <span class="number">0</span>, data.length);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 打破双亲委派机制：重写类加载方法，实现自己的加载逻辑，不委派给双亲加载</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@author</span> fly</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@date</span> 2022/5/10 22:47</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> resolve</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span> java.lang.Class&lt;?&gt;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">                <span class="comment">// First, check if the class has already been loaded</span></span><br><span class="line">                Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">                <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">long</span> t0 = System.nanoTime();</span><br><span class="line">                    <span class="comment">//移除双亲委派机制，取消加载类时调用父类加载器</span></span><br><span class="line"><span class="comment">//                    try &#123;</span></span><br><span class="line"><span class="comment">//                        if (parent != null) &#123;</span></span><br><span class="line"><span class="comment">//                            c = parent.loadClass(name, false);</span></span><br><span class="line"><span class="comment">//                        &#125; else &#123;</span></span><br><span class="line"><span class="comment">//                            c = findBootstrapClassOrNull(name);</span></span><br><span class="line"><span class="comment">//                        &#125;</span></span><br><span class="line"><span class="comment">//                    &#125; catch (ClassNotFoundException e) &#123;</span></span><br><span class="line"><span class="comment">//                        // ClassNotFoundException thrown if class not found</span></span><br><span class="line"><span class="comment">//                        // from the non-null parent class loader</span></span><br><span class="line"><span class="comment">//                    &#125;</span></span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">// If still not found, then invoke findClass in order</span></span><br><span class="line">                        <span class="comment">// to find the class.</span></span><br><span class="line">                        <span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line">                        c = findClass(name);</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">                        sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                        sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                        sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">                    resolveClass(c);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> c;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            MyClassLoader2 classLoader = <span class="keyword">new</span> MyClassLoader2(<span class="string">"/Users/fly/work/myproject/testjvm"</span>);</span><br><span class="line">            <span class="comment">//尝试用自己改写类加载机制去加载自己写的java.lang.String.class</span></span><br><span class="line">            Class clazz = classLoader.loadClass(<span class="string">"java.lang.String"</span>);</span><br><span class="line">            Object obj = clazz.newInstance();</span><br><span class="line">            Method method= clazz.getDeclaredMethod(<span class="string">"sout"</span>, <span class="keyword">null</span>);</span><br><span class="line">            method.invoke(obj, <span class="keyword">null</span>);</span><br><span class="line">            System.out.println(clazz.getClassLoader().getClass().getName());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 运行结果： </p>
<p>java.lang.SecurityException: Prohibited package name: java.lang<br>    at java.lang.ClassLoader.preDefineClass(ClassLoader.java:656)<br>    at java.lang.ClassLoader.defineClass(ClassLoader.java:755)        </p>
<h2 id="TOMCAT打破双亲委派机制"><a href="#TOMCAT打破双亲委派机制" class="headerlink" title="TOMCAT打破双亲委派机制"></a>TOMCAT打破双亲委派机制</h2><p>以Tomcat类加载为例，Tomcat 如果使用默认的双亲委派类加载机制行不行？</p>
<p>我们思考一下：Tomcat是个web容器， 那么它要解决什么问题： </p>
<ol>
<li><p>一个web容器可能需要部署两个应用程序，不同的应用程序可能会<strong>依赖同一个第三方类库的不同版本</strong>，不能要求同一个类库在同一个服务器只有一份，因此要保证每个应用程序的类库都是独立的，保证相互隔离。</p>
</li>
<li><p>部署在同一个web容器中<strong>相同的类库相同的版本可以共享</strong>。否则，如果服务器有10个应用程序，那么要有10份相同的类库加载进虚拟机。 </p>
</li>
<li><p><strong>web容器也有自己依赖的类库，不能与应用程序的类库混淆</strong>。基于安全考虑，应该让容器的类库和程序的类库隔离开来。 </p>
</li>
<li><p>web容器要支持jsp的修改，我们知道，jsp 文件最终也是要编译成class文件才能在虚拟机中运行，但程序运行后修改jsp已经是司空见惯的事情， web容器需要支持 jsp 修改后不用重启。</p>
</li>
</ol>
<p>再看看我们的问题：<strong>Tomcat 如果使用默认的双亲委派类加载机制行不行？</strong> </p>
<p>答案是不行的。为什么？</p>
<p>第一个问题，如果使用默认的类加载器机制，那么是无法加载两个相同类库的不同版本的，默认的类加器是不管你是什么版本的，只在乎你的全限定类名，并且只有一份。</p>
<p>第二个问题，默认的类加载器是能够实现的，因为他的职责就是保证<strong>唯一性</strong>。</p>
<p>第三个问题和第一个问题一样。</p>
<p>我们再看第四个问题，我们想我们要怎么实现jsp文件的热加载，jsp 文件其实也就是class文件，那么如果修改了，但类名还是一样，类加载器会直接取方法区中已经存在的，修改后的jsp是不会重新加载的。那么怎么办呢？我们可以直接卸载掉这jsp文件的类加载器，所以你应该想到了，每个jsp文件对应一个唯一的类加载器，当一个jsp文件修改了，就直接卸载这个jsp类加载器。重新创建类加载器，重新加载jsp文件。</p>
<p><strong>Tomcat自定义加载器详解</strong></p>
<p><img data-src="tomcat%E5%8A%A0%E8%BD%BD%E5%99%A8.jpg" alt="tomcat加载器"></p>
<p>tomcat的几个主要类加载器：</p>
<ul>
<li><p>commonLoader：Tomcat最基本的类加载器，加载路径中的class可以被Tomcat容器本身以及各个Webapp访问；</p>
</li>
<li><p>catalinaLoader：Tomcat容器私有的类加载器，加载路径中的class对于Webapp不可见；</p>
</li>
<li><p>sharedLoader：各个Webapp共享的类加载器，加载路径中的class对于所有Webapp可见，但是对于Tomcat容器不可见；</p>
</li>
<li><p>WebappClassLoader：各个Webapp私有的类加载器，加载路径中的class只对当前Webapp可见，比如加载war包里相关的类，每个war包应用都有自己的WebappClassLoader，实现相互隔离，比如不同war包应用引入了不同的spring版本，这样实现就能加载各自的spring版本；</p>
</li>
</ul>
<p>从图中的委派关系中可以看出：</p>
<p>CommonClassLoader能加载的类都可以被CatalinaClassLoader和SharedClassLoader使用，从而实现了公有类库的共用，而CatalinaClassLoader和SharedClassLoader自己能加载的类则与对方相互隔离。</p>
<p>WebAppClassLoader可以使用SharedClassLoader加载到的类，但各个WebAppClassLoader实例之间相互隔离。</p>
<p>而JasperLoader的加载范围仅仅是这个JSP文件所编译出来的那一个.Class文件，它出现的目的就是为了被丢弃：当Web容器检测到JSP文件被修改时，会替换掉目前的JasperLoader的实例，并通过再建立一个新的Jsp类加载器来实现JSP文件的热加载功能。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClassLoaderTest3</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClassLoader3</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String classPath;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MyClassLoader3</span><span class="params">(String classPath)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.classPath = classPath;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">byte</span>[] loadByte(String name) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            name = name.replaceAll(<span class="string">"\\."</span>, <span class="string">"/"</span>);</span><br><span class="line">            FileInputStream fis = <span class="keyword">new</span> FileInputStream(classPath + <span class="string">"/"</span> + name</span><br><span class="line">                    + <span class="string">".class"</span>);</span><br><span class="line">            <span class="keyword">int</span> len = fis.available();</span><br><span class="line">            <span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[len];</span><br><span class="line">            fis.read(data);</span><br><span class="line">            fis.close();</span><br><span class="line">            <span class="keyword">return</span> data;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">byte</span>[] data = loadByte(name);</span><br><span class="line">                <span class="comment">//defineClass将一个字节数组转为Class对象，这个字节数组是class文件读取后最终的字节数组。</span></span><br><span class="line">                <span class="keyword">return</span> defineClass(name, data, <span class="number">0</span>, data.length);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 打破双亲委派机制：重写类加载方法，实现自己的加载逻辑，不委派给双亲加载</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> resolve</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span> java.lang.Class&lt;?&gt;</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@author</span> fly</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@date</span> 2022/5/10 22:47</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">                <span class="comment">// First, check if the class has already been loaded</span></span><br><span class="line">                Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">long</span> t0 = System.nanoTime();</span><br><span class="line">                    <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">// If still not found, then invoke findClass in order</span></span><br><span class="line">                        <span class="comment">// to find the class.</span></span><br><span class="line">                        <span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (!name.startsWith(<span class="string">"com.fly.jvm"</span>)) &#123;</span><br><span class="line">                            c = <span class="keyword">this</span>.getParent().loadClass(name);</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            c = findClass(name);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">                        sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                        sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                        sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">                    resolveClass(c);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> c;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            MyClassLoader3 classLoader = <span class="keyword">new</span> MyClassLoader3(<span class="string">"/Users/fly/work/myproject/testjvm"</span>);</span><br><span class="line">            Class clazz = classLoader.loadClass(<span class="string">"com.fly.jvm.User1"</span>);</span><br><span class="line">            Object obj = clazz.newInstance();</span><br><span class="line">            Method method = clazz.getDeclaredMethod(<span class="string">"sout"</span>, <span class="keyword">null</span>);</span><br><span class="line">            method.invoke(obj, <span class="keyword">null</span>);</span><br><span class="line">            System.out.println(clazz.getClassLoader());</span><br><span class="line"></span><br><span class="line">            System.out.println();</span><br><span class="line">            MyClassLoader3 classLoader1 = <span class="keyword">new</span> MyClassLoader3(<span class="string">"/Users/fly/work/myproject/testjvm1"</span>);</span><br><span class="line">            Class clazz1 = classLoader1.loadClass(<span class="string">"com.fly.jvm.User1"</span>);</span><br><span class="line">            Object obj1 = clazz1.newInstance();</span><br><span class="line">            Method method1 = clazz1.getDeclaredMethod(<span class="string">"sout"</span>, <span class="keyword">null</span>);</span><br><span class="line">            method1.invoke(obj1, <span class="keyword">null</span>);</span><br><span class="line">            System.out.println(clazz1.getClassLoader());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：              </p>
<p>User1<br>com.fly.jvm.MyClassLoaderTest3$MyClassLoader3@3c679bde</p>
<p>User1<br>com.fly.jvm.MyClassLoaderTest3$MyClassLoader3@2a3046da</p>
<p><strong>注意</strong>：同一个JVM内，两个相同包名和类名的类对象可以共存，因为他们的类加载器可以不一样，所以看两个类对象是否是同一个，除了看类的包名和类名是否都相同之外，还需要他们的类加载器也是同一个才能认为他们是同一个。</p>
<h2 id="Hotspot源码JVM启动执行main方法流程"><a href="#Hotspot源码JVM启动执行main方法流程" class="headerlink" title="Hotspot源码JVM启动执行main方法流程"></a>Hotspot源码JVM启动执行main方法流程</h2><img data-src="Hotspot源码JVM启动执行main方法流程.jpg" alt="Hotspot源码JVM启动执行main方法流程"  />
]]></content>
      <categories>
        <category>Java</category>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM系列(三)JVM对象创建与内存分配机制深度剖析</title>
    <url>/blog/2022/08/01/JVM%E7%B3%BB%E5%88%97(%E4%B8%89)JVM%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E6%9C%BA%E5%88%B6%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/blog/assets/css/APlayer.min.css"><script src="/blog/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h2><p><img data-src="%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E7%9A%84%E6%B5%81%E7%A8%8B.png" alt="对象创建的流程"></p>
<h3 id="类加载检查"><a href="#类加载检查" class="headerlink" title="类加载检查"></a>类加载检查</h3><p>虚拟机遇到一条new指令时,首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用,并且检查这个符号代表的类是否已被加载,解析和初始化过.如果没有,那必须先执行相应的类加载过程.</p>
<p>new 指令对应到语言层面上讲意思是:new关键词,对象克隆,对象序列化等.</p>
<h3 id="分配内存"><a href="#分配内存" class="headerlink" title="分配内存"></a>分配内存</h3><p>在类加载检查通过后,接下来虚拟机将为新生对象分配内存.对象所需内存的大小在类加载完成后便可完全确定,为对象分配空间的任务等同于把一块确定大小的内存从Java堆中划分出来.</p>
<h4 id="如何划分内存"><a href="#如何划分内存" class="headerlink" title="如何划分内存?"></a>如何划分内存?</h4><h5 id="指针碰撞-Bump-The-Pointer-默认"><a href="#指针碰撞-Bump-The-Pointer-默认" class="headerlink" title="指针碰撞(Bump The Pointer)-默认"></a>指针碰撞(Bump The Pointer)-默认</h5><p>如果Java堆中的内存是觉得规整的,所有用过的内存都放在一边,空闲的在另一边,中间放着一个指针作为分界点的指示器,那所分配内存就仅仅是把那个指针向空闲空间那边挪动一段与对象大小相等的距离.</p>
<h5 id="空闲列表-Free-List"><a href="#空闲列表-Free-List" class="headerlink" title="空闲列表(Free List)"></a>空闲列表(Free List)</h5><p>如果Java堆中的内存并不是规整的,已使用的内存和空闲的内存相互交错,那么就没有办法简单的进行指针碰撞了,虚拟机就必须维护一个列表,来记录那些内存块是可用的,在分配的时候从列表中找到一块足够大的空间划分给对象实例,并更新列表上的记录.</p>
<h4 id="在并发情况下-可能出现正在给对象A分配内存-指针还没来得及修改-对象B又同时使用了原来的指针分配内存的情况"><a href="#在并发情况下-可能出现正在给对象A分配内存-指针还没来得及修改-对象B又同时使用了原来的指针分配内存的情况" class="headerlink" title="在并发情况下,可能出现正在给对象A分配内存,指针还没来得及修改,对象B又同时使用了原来的指针分配内存的情况"></a>在并发情况下,可能出现正在给对象A分配内存,指针还没来得及修改,对象B又同时使用了原来的指针分配内存的情况</h4><h5 id="CAS-compare-and-swap"><a href="#CAS-compare-and-swap" class="headerlink" title="CAS (compare and swap)"></a>CAS (compare and swap)</h5><p>虚拟机采用CAS配上失败重试的方式保证更新操作的原子性来分配堆内存空间的动作进行同步处理.</p>
<h5 id="本地线程分配缓冲-Thread-Local-Allocation-Buffer-TLAB"><a href="#本地线程分配缓冲-Thread-Local-Allocation-Buffer-TLAB" class="headerlink" title="本地线程分配缓冲(Thread Local Allocation Buffer,TLAB)"></a>本地线程分配缓冲(Thread Local Allocation Buffer,TLAB)</h5><p>把内存分配的动作按照线程划分在不同的空间之中进行,即每个线程在Java堆中预先分配一小块内存,通过-XX:/-UserTLAB参数来设定虚拟机是否使用TLAB(JVM默认开启),-XX:TLABSize 指定TLAB大小.</p>
<h3 id="初始化零值"><a href="#初始化零值" class="headerlink" title="初始化零值"></a>初始化零值</h3><p>内存分配完成后,虚拟机需要将分配到的内存空间都初始化为零值(不包含对象头),如果使用TLAB,这一工作过程也可以提前至TLAB分配时进行.这一步操作保证了对象的实例字段在Java代码中可以不赋初始值就直接使用,程序能访问到这些字段的数据类型所对应的零值.</p>
<h3 id="设置对象头"><a href="#设置对象头" class="headerlink" title="设置对象头"></a>设置对象头</h3><p>初始化零值之后,虚拟机要对对象进行必要的设置,例如这个对象是那个类的实例,如何才能找到类的元数据信息,对象的哈希码,对象的GC分代年龄等信息.这些信息存放在对象的对象头Object Header之中.</p>
<p>在HotSpot虚拟机中,对象在内存中存储的布局可以分为3块区域:对象头(Header),实例数据(Instance Data)和对齐填充(Padding).在HotSpot虚拟机的对象头包括两部分信息,第一部分用于存储对象自身的运行时数据,如哈希码(Hash Code),GC分代年龄,锁状态标志,线程持有的锁,偏向线程ID,偏向时间戳等,对象头的另外一部分是类型指针,即对象指向它的类元数据的指针,虚拟机通过这个指针来确定这个对象是那个类的实例.</p>
<h4 id="32位对象头"><a href="#32位对象头" class="headerlink" title="32位对象头"></a>32位对象头</h4><p><img data-src="32%E4%BD%8D%E5%AF%B9%E8%B1%A1%E5%A4%B4.png" alt="32位对象头"></p>
<h4 id="64位对象头"><a href="#64位对象头" class="headerlink" title="64位对象头"></a>64位对象头</h4><img data-src="64位对象头.png" alt="64位对象头"  />

<p>对象头在hotspot的C++源码markOop.hpp文件里的注释如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Bit-format of an object header (most significant first, big endian layout below):</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  32 bits:</span></span><br><span class="line"><span class="comment">//  --------</span></span><br><span class="line"><span class="comment">//             hash:25 ------------&gt;| age:4    biased_lock:1 lock:2 (normal object)</span></span><br><span class="line"><span class="comment">//             JavaThread*:23 epoch:2 age:4    biased_lock:1 lock:2 (biased object)</span></span><br><span class="line"><span class="comment">//             size:32 ------------------------------------------&gt;| (CMS free block)</span></span><br><span class="line"><span class="comment">//             PromotedObject*:29 ----------&gt;| promo_bits:3 -----&gt;| (CMS promoted object)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  64 bits:</span></span><br><span class="line"><span class="comment">//  --------</span></span><br><span class="line"><span class="comment">//  unused:25 hash:31 --&gt;| unused:1   age:4    biased_lock:1 lock:2 (normal object)</span></span><br><span class="line"><span class="comment">//  JavaThread*:54 epoch:2 unused:1   age:4    biased_lock:1 lock:2 (biased object)</span></span><br><span class="line"><span class="comment">//  PromotedObject*:61 ---------------------&gt;| promo_bits:3 -----&gt;| (CMS promoted object)</span></span><br><span class="line"><span class="comment">//  size:64 -----------------------------------------------------&gt;| (CMS free block)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  unused:25 hash:31 --&gt;| cms_free:1 age:4    biased_lock:1 lock:2 (COOPs &amp;&amp; normal object)</span></span><br><span class="line"><span class="comment">//  JavaThread*:54 epoch:2 cms_free:1 age:4    biased_lock:1 lock:2 (COOPs &amp;&amp; biased object)</span></span><br><span class="line"><span class="comment">//  narrowOop:32 unused:24 cms_free:1 unused:4 promo_bits:3 -----&gt;| (COOPs &amp;&amp; CMS promoted object)</span></span><br><span class="line"><span class="comment">//  unused:21 size:35 --&gt;| cms_free:1 unused:7 ------------------&gt;| (COOPs &amp;&amp; CMS free block)</span></span><br></pre></td></tr></table></figure>

<h3 id="执行方法"><a href="#执行方法" class="headerlink" title="执行方法"></a>执行<init>方法</h3><p> 执行<init>方法，即对象按照程序员的意愿进行初始化。对应到语言层面上讲，就是为属性赋值（注意，这与上面的赋零值不同，这是由程序员赋的值）和执行构造方法。</p>
<p>对象半初始化</p>
<h4 id="对象大小与指针压缩"><a href="#对象大小与指针压缩" class="headerlink" title="对象大小与指针压缩"></a>对象大小与指针压缩</h4><p>对象大小可以用jol-core包查看</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.openjdk.jol<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jol-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>Demo:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.openjdk.jol.info.ClassLayout;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 计算对象大小</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JOLSample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ClassLayout layout = ClassLayout.parseInstance(<span class="keyword">new</span> Object());</span><br><span class="line">        System.out.println(layout.toPrintable());</span><br><span class="line"></span><br><span class="line">        System.out.println();</span><br><span class="line">        ClassLayout layout1 = ClassLayout.parseInstance(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;&#125;);</span><br><span class="line">        System.out.println(layout1.toPrintable());</span><br><span class="line"></span><br><span class="line">        System.out.println();</span><br><span class="line">        ClassLayout layout2 = ClassLayout.parseInstance(<span class="keyword">new</span> A());</span><br><span class="line">        System.out.println(layout2.toPrintable());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// -XX:+UseCompressedOops           默认开启的压缩所有指针</span></span><br><span class="line">    <span class="comment">// -XX:+UseCompressedClassPointers  默认开启的压缩对象头里的类型指针Klass Pointer</span></span><br><span class="line">    <span class="comment">// Oops : Ordinary Object Pointers</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">                       <span class="comment">//8B mark word</span></span><br><span class="line">                       <span class="comment">//4B Klass Pointer   如果关闭压缩-XX:-UseCompressedClassPointers或-XX:-UseCompressedOops，则占用8B</span></span><br><span class="line">        <span class="keyword">int</span> id;        <span class="comment">//4B</span></span><br><span class="line">        String name;   <span class="comment">//4B  如果关闭压缩-XX:-UseCompressedOops，则占用8B</span></span><br><span class="line">        <span class="keyword">byte</span> b;        <span class="comment">//1B </span></span><br><span class="line">        Object o;      <span class="comment">//4B  如果关闭压缩-XX:-UseCompressedOops，则占用8B</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">java.lang.Object object internals:</span><br><span class="line"> OFFSET  SIZE   TYPE DESCRIPTION                               VALUE</span><br><span class="line">      <span class="number">0</span>     <span class="number">4</span>        (object header)                           <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">00000001</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">1</span>)    <span class="comment">//mark word</span></span><br><span class="line">      <span class="number">4</span>     <span class="number">4</span>        (object header)                           <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">0</span>)    <span class="comment">//mark word     </span></span><br><span class="line">      <span class="number">8</span>     <span class="number">4</span>        (object header)                           e5 <span class="number">01</span> <span class="number">00</span> f8 (<span class="number">11100101</span> <span class="number">00000001</span> <span class="number">00000000</span> <span class="number">11111000</span>) (-<span class="number">134217243</span>)    <span class="comment">//Klass Pointer</span></span><br><span class="line">     <span class="number">12</span>     <span class="number">4</span>        (loss due to the next object alignment)</span><br><span class="line">Instance size: <span class="number">16</span> bytes</span><br><span class="line">Space losses: <span class="number">0</span> bytes internal + <span class="number">4</span> bytes external = <span class="number">4</span> bytes total</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[I object internals:</span><br><span class="line"> OFFSET  SIZE   TYPE DESCRIPTION                               VALUE</span><br><span class="line">      <span class="number">0</span>     <span class="number">4</span>        (object header)                           <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">00000001</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">1</span>)</span><br><span class="line">      <span class="number">4</span>     <span class="number">4</span>        (object header)                           <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">0</span>)</span><br><span class="line">      <span class="number">8</span>     <span class="number">4</span>        (object header)                           <span class="number">6</span>d <span class="number">01</span> <span class="number">00</span> f8 (<span class="number">01101101</span> <span class="number">00000001</span> <span class="number">00000000</span> <span class="number">11111000</span>) (-<span class="number">134217363</span>)</span><br><span class="line">     <span class="number">12</span>     <span class="number">4</span>        (object header)                           <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">0</span>)</span><br><span class="line">     <span class="number">16</span>     <span class="number">0</span>    <span class="keyword">int</span> [I.&lt;elements&gt;                             N/A</span><br><span class="line">Instance size: <span class="number">16</span> bytes</span><br><span class="line">Space losses: <span class="number">0</span> bytes internal + <span class="number">0</span> bytes external = <span class="number">0</span> bytes total</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">com.tuling.jvm.JOLSample$A object internals:</span><br><span class="line"> OFFSET  SIZE               TYPE DESCRIPTION                               VALUE</span><br><span class="line">      <span class="number">0</span>     <span class="number">4</span>                    (object header)                           <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">00000001</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">1</span>)</span><br><span class="line">      <span class="number">4</span>     <span class="number">4</span>                    (object header)                           <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">0</span>)</span><br><span class="line">      <span class="number">8</span>     <span class="number">4</span>                    (object header)                           <span class="number">61</span> cc <span class="number">00</span> f8 (<span class="number">01100001</span> <span class="number">11001100</span> <span class="number">00000000</span> <span class="number">11111000</span>) (-<span class="number">134165407</span>)</span><br><span class="line">     <span class="number">12</span>     <span class="number">4</span>                <span class="keyword">int</span> A.id                                      <span class="number">0</span></span><br><span class="line">     <span class="number">16</span>     <span class="number">1</span>               <span class="keyword">byte</span> A.b                                       <span class="number">0</span></span><br><span class="line">     <span class="number">17</span>     <span class="number">3</span>                    (alignment/padding gap)                  </span><br><span class="line">     <span class="number">20</span>     <span class="number">4</span>   java.lang.String A.name                                    <span class="keyword">null</span></span><br><span class="line">     <span class="number">24</span>     <span class="number">4</span>   java.lang.Object A.o                                       <span class="keyword">null</span></span><br><span class="line">     <span class="number">28</span>     <span class="number">4</span>                    (loss due to the next object alignment)</span><br><span class="line">Instance size: <span class="number">32</span> bytes</span><br><span class="line">Space losses: <span class="number">3</span> bytes internal + <span class="number">4</span> bytes external = <span class="number">7</span> bytes total</span><br></pre></td></tr></table></figure>



<h5 id="什么是java对象的指针压缩"><a href="#什么是java对象的指针压缩" class="headerlink" title="什么是java对象的指针压缩?"></a>什么是java对象的指针压缩?</h5><ol>
<li>jdk1.6 update14开始，在64bit操作系统中，JVM支持指针压缩</li>
<li>jvm配置参数:UseCompressedOops,compressed ——压缩 ,oop (ordinary object pointer) ——对象指针</li>
<li>启用指针压缩:-XX:+UseCompressedOops(默认开启),禁止指针压缩:- XX:UseCopmpressedOops</li>
</ol>
<h5 id="为什么要进行指针压缩"><a href="#为什么要进行指针压缩" class="headerlink" title="为什么要进行指针压缩?"></a>为什么要进行指针压缩?</h5><ol>
<li><p>在64位平台的HotSpot中使用32位指针(实际存储用64位),内存使用会多出1.5倍左右,使用较大指针在主内存和缓存之间移动数据<strong>,占用较大宽带,同时GC也会承受较大压力.</strong></p>
</li>
<li><p>为了减少64位平台下内存的消耗,启用指针压缩功能</p>
</li>
<li><p>在jvm中,32位地址最大支持4G内存(2的32次方),可以通过对对象指针存入<strong>堆内存</strong>时压缩编码,取出cpu寄存器后编码方式进行优化(对象指针在堆中是32位,在寄存器中是35位,2的35次方=32G),使得jvm中32位地址就可以支持更大的内存配置(小于等于32G)</p>
</li>
<li><p>堆内存小于4G时,不需要启用指针压缩,jvm会直接去除高32位地址,即使用低虚拟地址空间</p>
</li>
<li><p>堆内存大于32G时,压缩指针会失效,会强制使用64位(即8字节)来对java对象寻址,这就会出现1的问题,所以堆内存不要大于32G为好</p>
</li>
</ol>
<p>   关于<strong>对齐填充</strong>:对于大部分处理器,对象以8字节整数倍来对齐填充都是最高效的存取方式</p>
<h2 id="对象内存分配"><a href="#对象内存分配" class="headerlink" title="对象内存分配"></a>对象内存分配</h2><h3 id="对象内存分配流程图"><a href="#对象内存分配流程图" class="headerlink" title="对象内存分配流程图"></a>对象内存分配流程图</h3><img data-src="对象内存分配流程图.png" alt="对象内存分配流程图" style="zoom: 50%;" />

<h3 id="对象栈上分配"><a href="#对象栈上分配" class="headerlink" title="对象栈上分配"></a>对象栈上分配</h3><p>通过JVM内存分配可以知道JAVA中的对象都是在堆上进行分配，当对象没有被引用的时候，需要依靠GC进行回收内存，如果对象数量较多的时候，会给GC带来较大压力，也间接影响了应用的性能。为了减少临时对象在堆内分配的数量，JVM通过<strong>逃逸分析</strong>确定该对象不会被外部访问。如果不会逃逸可以将该对象在<strong>栈上分配</strong>内存，这样该对象所占用的内存空间就可以随栈帧出栈而销毁，就减轻了垃圾回收的压力。</p>
<p>JVM中，Java堆上分配创建对象的内存空间是常识，Java堆中的对象对各线程共享可见，只要持有该对象的引用，就可访问到堆中存储的对象数据。</p>
<p>虚拟机的GC子系统会回收堆中不再使用的对象，但回收动作无论是标记筛选出可回收对象，还是回收和整理内存，都需耗费大量资源。</p>
<p>如果确定一个对象不会逃逸出线程，那让该对象在栈上分配内存是个不错主意，对象所占用内存空间就可随栈帧出栈而销毁。</p>
<p>在一般应用中，完全不会逃逸的局部对象和不会逃逸出线程的对象所占的比例很大，如果能使用栈上分配，那大量对象就会随方法结束而自动销毁，GC子系统压力会下降很多。栈上分配可支持方法逃逸，但不能支持线程逃逸。</p>
<h4 id="对象逃逸"><a href="#对象逃逸" class="headerlink" title="对象逃逸"></a>对象逃逸</h4><p><strong>对象逃逸分析</strong>：就是分析对象动态作用域，当一个对象在方法中被定义后，它可能被外部方法所引用，例如作为调用参数传递到其他地方中。</p>
<ol>
<li>被外部方法所引用:例如作为调用参数传递给其他方法，称为方法逃逸</li>
<li>被外部线程访问:譬如赋值给可以在其他线程中访问的实例变量，称为线程逃逸</li>
</ol>
<p>从不逃逸 ——&gt;方法逃逸  ——&gt; 线程逃逸，称为对象由低到高的不同逃逸程度。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   User user = <span class="keyword">new</span> User();</span><br><span class="line">   user.setId(<span class="number">1</span>);</span><br><span class="line">   user.setName(<span class="string">"zhuge"</span>);</span><br><span class="line">   <span class="comment">//TODO 保存到数据库</span></span><br><span class="line">   <span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   User user = <span class="keyword">new</span> User();</span><br><span class="line">   user.setId(<span class="number">1</span>);</span><br><span class="line">   user.setName(<span class="string">"zhuge"</span>);</span><br><span class="line">   <span class="comment">//TODO 保存到数据库</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很显然test1方法中的user对象被返回了，这个对象的作用域范围不确定，test2方法中的user对象我们可以确定当方法结束这个对象就可以认为是无效对象了，对于这样的对象我们其实可以将其分配在栈内存里，让其在方法结束时跟随栈内存一起被回收掉。</p>
<p>JVM对于这种情况可以通过开启逃逸分析参数(-XX:+DoEscapeAnalysis)来优化对象内存分配位置，使其通过<strong>标量替换</strong>优先分配在栈上(<strong>栈上分配</strong>)，<strong>JDK7之后默认开启逃逸分析</strong>，如果要关闭使用参数(-XX:-DoEscapeAnalysis)</p>
<h4 id="标量替换（Scalar-Replacement）"><a href="#标量替换（Scalar-Replacement）" class="headerlink" title="标量替换（Scalar Replacement）"></a>标量替换（Scalar Replacement）</h4><p><strong>标量替换：</strong>通过逃逸分析确定该对象不会被外部访问，并且对象可以被进一步分解时，<strong>JVM不会创建该对象</strong>，而是将该对象成员变量分解若干个被这个方法使用的成员变量所代替，这些代替的成员变量在栈帧或寄存器上分配空间，这样就不会因为没有一大块连续空间导致对象内存不够分配。开启标量替换参数(-XX:+EliminateAllocations)，<strong>JDK7之后默认开启</strong>。</p>
<p><strong>标量与聚合量：</strong>标量即不可被进一步分解的量，而JAVA的基本数据类型就是标量（如：int，long等基本数据类型以及reference类型等），标量的对立就是可以被进一步分解的量，而这种量称之为聚合量。而在JAVA中对象就是可以被进一步分解的聚合量。</p>
<h4 id="同步消除（Synchronization-Elimination）"><a href="#同步消除（Synchronization-Elimination）" class="headerlink" title="同步消除（Synchronization Elimination）"></a>同步消除（Synchronization Elimination）</h4><p>线程同步本身是一个相对耗时过程，如果逃逸分析能确定一个变量不会逃逸出线程，无法被其他线程访问，那么该变量读写肯定不会有竞争， 对该变量实施的同步措施也可安全消除。</p>
<h4 id="栈上分配示例"><a href="#栈上分配示例" class="headerlink" title="栈上分配示例"></a>栈上分配示例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 栈上分配，标量替换</span></span><br><span class="line"><span class="comment"> * 代码调用了1亿次alloc()，如果是分配到堆上，大概需要1GB以上堆空间，如果堆空间小于该值，必然会触发GC。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 使用如下参数不会发生GC</span></span><br><span class="line"><span class="comment"> * -Xmx15m -Xms15m -XX:+DoEscapeAnalysis -XX:+PrintGC -XX:+EliminateAllocations</span></span><br><span class="line"><span class="comment"> * 使用如下参数都会发生大量GC</span></span><br><span class="line"><span class="comment"> * -Xmx15m -Xms15m -XX:-DoEscapeAnalysis -XX:+PrintGC -XX:+EliminateAllocations</span></span><br><span class="line"><span class="comment"> * -Xmx15m -Xms15m -XX:+DoEscapeAnalysis -XX:+PrintGC -XX:-EliminateAllocations</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AllotOnStack</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000000</span>; i++) &#123;</span><br><span class="line">            alloc();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(end - start);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">alloc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setId(<span class="number">1</span>);</span><br><span class="line">        user.setName(<span class="string">"zhuge"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结论：<strong>==栈上分配依赖于逃逸分析和标量替换==</strong></p>
<h3 id="对象在Eden区分配"><a href="#对象在Eden区分配" class="headerlink" title="对象在Eden区分配"></a>对象在Eden区分配</h3><p>大多数情况下，对象在新生代中 Eden 区分配。当 Eden 区没有足够空间进行分配时，虚拟机将发起一次Minor GC。我们来进行实际测试一下。</p>
<p>在测试之前我们先来看看 <strong>Minor GC和Full GC 有什么不同呢？</strong></p>
<ul>
<li><strong>Minor GC/Young GC</strong>：指发生新生代的的垃圾收集动作，Minor GC非常频繁，回收速度一般也比较快。</li>
<li><strong>Major GC/Full GC</strong>：一般会回收老年代 ，年轻代，方法区的垃圾，Major GC的速度一般会比Minor GC的慢10倍以上。</li>
</ul>
<p><strong>Eden与Survivor区默认8:1:1</strong></p>
<p>大量的对象被分配在eden区，eden区满了后会触发minor gc，可能会有99%以上的对象成为垃圾被回收掉，剩余存活的对象会被挪到为空的那块survivor区，下一次eden区满了后又会触发minor gc，把eden区和survivor区垃圾对象回收，把剩余存活的对象一次性挪动到另外一块为空的survivor区，因为新生代的对象都是朝生夕死的，存活时间很短，所以JVM默认的8:1:1的比例是很合适的，<strong>让eden区尽量的大，survivor区够用即可，</strong></p>
<p>JVM默认有这个参数-XX:+UseAdaptiveSizePolicy(默认开启)，会导致这个8:1:1比例自动变化，如果不想这个比例有变化可以设置参数-XX:-UseAdaptiveSizePolicy</p>
<p>示例:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//添加运行JVM参数： -XX:+PrintGCDetails</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GCTest</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">      <span class="keyword">byte</span>[] allocation1, allocation2<span class="comment">/*, allocation3, allocation4, allocation5, allocation6*/</span>;</span><br><span class="line">      allocation1 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">60000</span>*<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">      <span class="comment">//allocation2 = new byte[8000*1024];</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">/*allocation3 = new byte[1000*1024];</span></span><br><span class="line"><span class="comment">     allocation4 = new byte[1000*1024];</span></span><br><span class="line"><span class="comment">     allocation5 = new byte[1000*1024];</span></span><br><span class="line"><span class="comment">     allocation6 = new byte[1000*1024];*/</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">Heap</span><br><span class="line"> PSYoungGen      total <span class="number">76288</span>K, used <span class="number">65536</span>K [<span class="number">0x000000076b400000</span>, <span class="number">0x0000000770900000</span>, <span class="number">0x00000007c0000000</span>)</span><br><span class="line">  eden space <span class="number">65536</span>K, <span class="number">100</span>% used [<span class="number">0x000000076b400000</span>,<span class="number">0x000000076f400000</span>,<span class="number">0x000000076f400000</span>)</span><br><span class="line">  from space <span class="number">10752</span>K, <span class="number">0</span>% used [<span class="number">0x000000076fe80000</span>,<span class="number">0x000000076fe80000</span>,<span class="number">0x0000000770900000</span>)</span><br><span class="line">  to   space <span class="number">10752</span>K, <span class="number">0</span>% used [<span class="number">0x000000076f400000</span>,<span class="number">0x000000076f400000</span>,<span class="number">0x000000076fe80000</span>)</span><br><span class="line"> ParOldGen       total <span class="number">175104</span>K, used <span class="number">0</span>K [<span class="number">0x00000006c1c00000</span>, <span class="number">0x00000006cc700000</span>, <span class="number">0x000000076b400000</span>)</span><br><span class="line">  object space <span class="number">175104</span>K, <span class="number">0</span>% used [<span class="number">0x00000006c1c00000</span>,<span class="number">0x00000006c1c00000</span>,<span class="number">0x00000006cc700000</span>)</span><br><span class="line"> Metaspace       used <span class="number">3342</span>K, capacity <span class="number">4496</span>K, committed <span class="number">4864</span>K, reserved <span class="number">1056768</span>K</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">space</span>    <span class="title">used</span> 361<span class="title">K</span>, <span class="title">capacity</span> 388<span class="title">K</span>, <span class="title">committed</span> 512<span class="title">K</span>, <span class="title">reserved</span> 1048576<span class="title">K</span></span></span><br></pre></td></tr></table></figure>

<p>我们可以看出eden区内存几乎已经被分配完全（即使程序什么也不做，新生代也会使用至少几M内存）。<strong>假如我们再为allocation2分配内存会出现什么情况呢？</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//添加运行JVM参数： -XX:+PrintGCDetails</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GCTest</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">      <span class="keyword">byte</span>[] allocation1, allocation2<span class="comment">/*, allocation3, allocation4, allocation5, allocation6*/</span>;</span><br><span class="line">      allocation1 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">60000</span>*<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">      allocation2 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">8000</span>*<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">      <span class="comment">/*allocation3 = new byte[1000*1024];</span></span><br><span class="line"><span class="comment">      allocation4 = new byte[1000*1024];</span></span><br><span class="line"><span class="comment">      allocation5 = new byte[1000*1024];</span></span><br><span class="line"><span class="comment">      allocation6 = new byte[1000*1024];*/</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: <span class="number">65253</span>K-&gt;<span class="number">936</span>K(<span class="number">76288</span>K)] <span class="number">65253</span>K-&gt;<span class="number">60944</span>K(<span class="number">251392</span>K), <span class="number">0.0279083</span> secs] [Times: user=<span class="number">0.13</span> sys=<span class="number">0.02</span>, real=<span class="number">0.03</span> secs] </span><br><span class="line">Heap</span><br><span class="line"> PSYoungGen      total <span class="number">76288</span>K, used <span class="number">9591</span>K [<span class="number">0x000000076b400000</span>, <span class="number">0x0000000774900000</span>, <span class="number">0x00000007c0000000</span>)</span><br><span class="line">  eden space <span class="number">65536</span>K, <span class="number">13</span>% used [<span class="number">0x000000076b400000</span>,<span class="number">0x000000076bc73ef8</span>,<span class="number">0x000000076f400000</span>)</span><br><span class="line">  from space <span class="number">10752</span>K, <span class="number">8</span>% used [<span class="number">0x000000076f400000</span>,<span class="number">0x000000076f4ea020</span>,<span class="number">0x000000076fe80000</span>)</span><br><span class="line">  to   space <span class="number">10752</span>K, <span class="number">0</span>% used [<span class="number">0x0000000773e80000</span>,<span class="number">0x0000000773e80000</span>,<span class="number">0x0000000774900000</span>)</span><br><span class="line"> ParOldGen       total <span class="number">175104</span>K, used <span class="number">60008</span>K [<span class="number">0x00000006c1c00000</span>, <span class="number">0x00000006cc700000</span>, <span class="number">0x000000076b400000</span>)</span><br><span class="line">  object space <span class="number">175104</span>K, <span class="number">34</span>% used [<span class="number">0x00000006c1c00000</span>,<span class="number">0x00000006c569a010</span>,<span class="number">0x00000006cc700000</span>)</span><br><span class="line"> Metaspace       used <span class="number">3342</span>K, capacity <span class="number">4496</span>K, committed <span class="number">4864</span>K, reserved <span class="number">1056768</span>K</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">space</span>    <span class="title">used</span> 361<span class="title">K</span>, <span class="title">capacity</span> 388<span class="title">K</span>, <span class="title">committed</span> 512<span class="title">K</span>, <span class="title">reserved</span> 1048576<span class="title">K</span></span></span><br></pre></td></tr></table></figure>

<p><strong>简单解释一下为什么会出现这种情况：</strong> 因为给allocation2分配内存的时候eden区内存几乎已经被分配完了，我们刚刚讲了当Eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC，GC期间虚拟机又发现allocation1无法存入Survior空间，所以只好把新生代的对象<strong>提前转移到老年代</strong>中去，老年代上的空间足够存放allocation1，所以不会出现Full GC。执行Minor GC后，后面分配的对象如果能够存在eden区的话，还是会在eden区分配内存。可以执行如下代码验证：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GCTest</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">      <span class="keyword">byte</span>[] allocation1, allocation2, allocation3, allocation4, allocation5, allocation6;</span><br><span class="line">      allocation1 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">60000</span>*<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">      allocation2 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">8000</span>*<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">      allocation3 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1000</span>*<span class="number">1024</span>];</span><br><span class="line">      allocation4 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1000</span>*<span class="number">1024</span>];</span><br><span class="line">     allocation5 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1000</span>*<span class="number">1024</span>];</span><br><span class="line">     allocation6 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1000</span>*<span class="number">1024</span>];</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: <span class="number">65253</span>K-&gt;<span class="number">952</span>K(<span class="number">76288</span>K)] <span class="number">65253</span>K-&gt;<span class="number">60960</span>K(<span class="number">251392</span>K), <span class="number">0.0311467</span> secs] [Times: user=<span class="number">0.08</span> sys=<span class="number">0.02</span>, real=<span class="number">0.03</span> secs] </span><br><span class="line">Heap</span><br><span class="line"> PSYoungGen      total <span class="number">76288</span>K, used <span class="number">13878</span>K [<span class="number">0x000000076b400000</span>, <span class="number">0x0000000774900000</span>, <span class="number">0x00000007c0000000</span>)</span><br><span class="line">  eden space <span class="number">65536</span>K, <span class="number">19</span>% used [<span class="number">0x000000076b400000</span>,<span class="number">0x000000076c09fb68</span>,<span class="number">0x000000076f400000</span>)</span><br><span class="line">  from space <span class="number">10752</span>K, <span class="number">8</span>% used [<span class="number">0x000000076f400000</span>,<span class="number">0x000000076f4ee030</span>,<span class="number">0x000000076fe80000</span>)</span><br><span class="line">  to   space <span class="number">10752</span>K, <span class="number">0</span>% used [<span class="number">0x0000000773e80000</span>,<span class="number">0x0000000773e80000</span>,<span class="number">0x0000000774900000</span>)</span><br><span class="line"> ParOldGen       total <span class="number">175104</span>K, used <span class="number">60008</span>K [<span class="number">0x00000006c1c00000</span>, <span class="number">0x00000006cc700000</span>, <span class="number">0x000000076b400000</span>)</span><br><span class="line">  object space <span class="number">175104</span>K, <span class="number">34</span>% used [<span class="number">0x00000006c1c00000</span>,<span class="number">0x00000006c569a010</span>,<span class="number">0x00000006cc700000</span>)</span><br><span class="line"> Metaspace       used <span class="number">3343</span>K, capacity <span class="number">4496</span>K, committed <span class="number">4864</span>K, reserved <span class="number">1056768</span>K</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">space</span>    <span class="title">used</span> 361<span class="title">K</span>, <span class="title">capacity</span> 388<span class="title">K</span>, <span class="title">committed</span> 512<span class="title">K</span>, <span class="title">reserved</span> 1048576<span class="title">K</span></span></span><br></pre></td></tr></table></figure>

<h3 id="大对象直接进入老年代"><a href="#大对象直接进入老年代" class="headerlink" title="大对象直接进入老年代"></a>大对象直接进入老年代</h3><p>大对象就是需要大量连续内存空间的对象（比如：字符串、数组）。JVM参数 -XX:PretenureSizeThreshold 可以设置大对象的大小，如果对象超过设置大小会直接进入老年代，不会进入年轻代，这个参数只在 Serial 和ParNew两个收集器下有效。</p>
<p>比如设置JVM参数：-XX:PretenureSizeThreshold=1000000 (单位是字节)  -XX:+UseSerialGC  ，再执行下上面的第一个程序会发现大对象直接进了老年代</p>
<p><strong>为什么要这样呢？</strong></p>
<p>为了避免为大对象分配内存时的复制操作而降低效率。</p>
<h3 id="长期存活的对象直接进入老年代"><a href="#长期存活的对象直接进入老年代" class="headerlink" title="长期存活的对象直接进入老年代"></a>长期存活的对象直接进入老年代</h3><p>既然虚拟机采用了分代收集的思想来管理内存，那么内存回收时就必须能识别哪些对象应放在新生代，哪些对象应放在老年代中。为了做到这一点，虚拟机给每个对象一个对象年龄（Age）计数器。</p>
<p>如果对象在 Eden 出生并经过第一次 Minor GC 后仍然能够存活，并且能被 Survivor 容纳的话，将被移动到 Survivor 空间中，并将对象年龄设为1。对象在 Survivor 中每熬过一次 MinorGC，年龄就增加1岁，当它的年龄增加到一定程度（默认为15岁，CMS收集器默认6岁，不同的垃圾收集器会略微有点不同），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 <strong>-XX:MaxTenuringThreshold</strong> 来设置。</p>
<h3 id="对象动态年龄判断"><a href="#对象动态年龄判断" class="headerlink" title="对象动态年龄判断"></a>对象动态年龄判断</h3><p>当前放对象的Survivor区域里(其中一块区域，放对象的那块s区)，一批对象的总大小大于这块Survivor区域内存大小的50%(-XX:TargetSurvivorRatio可以指定)，那么此时<strong>大于等于</strong>这批对象年龄最大值的对象，就可以<strong>直接进入老年代</strong>了，例如Survivor区域里现在有一批对象，年龄1+年龄2+年龄n的多个年龄对象总和超过了Survivor区域的50%，此时就会把年龄n(含)以上的对象都放入老年代。这个规则其实是希望那些可能是长期存活的对象，尽早进入老年代。<strong>对象动态年龄判断机制一般是在minor gc之后触发的。</strong></p>
<h3 id="老年代空间分配担保机制"><a href="#老年代空间分配担保机制" class="headerlink" title="老年代空间分配担保机制"></a>老年代空间分配担保机制</h3><p>年轻代每次<strong>minor gc</strong> 之前都会计算下老年代<strong>剩余可用空间</strong></p>
<p>如果这个可用空间小于年轻代里现有的所有对象大小之和(<strong>包括垃圾对象</strong>)</p>
<p>就会看一个“-XX:-HandlePromotionFailure”(jdk1.8默认就设置了)的参数是否设置了</p>
<p>如果有这个参数，就会看看老年代的可用内存大小，是否大于之前每一次minor gc后进入老年代的对象的<strong>平均大小</strong>。</p>
<p>如果上一步结果是小于或者之前说的参数没有设置，那么就会触发一次Full gc，对老年代和年轻代一起回收一次垃圾，如果回收完还是没有足够空间存放新的对象就会发生”OOM”</p>
<p>当然，如果minor gc之后剩余存活的需要挪动到老年代的对象大小还是大于老年代可用空间，那么也会触发full gc，full gc完之后如果还是没有空间放minor gc之后的存活对象，则也会发生“OOM”</p>
<p><img data-src="%E8%80%81%E5%B9%B4%E5%B8%A6%E7%A9%BA%E9%97%B4%E5%88%86%E9%85%8D%E6%8B%85%E4%BF%9D%E6%9C%BA%E5%88%B6.png" alt="老年带空间分配担保机制"></p>
<h2 id="对象内存回放"><a href="#对象内存回放" class="headerlink" title="对象内存回放"></a>对象内存回放</h2><p>堆中几乎放着所有的对象实例,对堆垃圾回收前的第一步就是要判断哪些对象已经死亡(即不能再被任何途径使用的对象).</p>
<h3 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h3><p>给对象中添加一个引用计数器,每当有一个地方引用它,计数器就加1;当引用失效,计数器就减1;任何时候计数器为0的对象就是不可能再被使用的.</p>
<p><strong>这个方法实现简单高效,但是目前主流的虚拟机中并没有选择这个算法来管理内存,其最主要的原因是它很难解决对象之间相互循环引用的问题.</strong></p>
<p>所谓对象之间的相互引用问题，如下面代码所示：除了对象objA 和 objB 相互引用着对方之外，这两个对象之间再无任何引用。但是他们因为互相引用对方，导致它们的引用计数器都不为0，于是引用计数算法无法通知 GC 回收器回收他们。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReferenceCountingGc</span> </span>&#123;</span><br><span class="line">   Object instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      ReferenceCountingGc objA = <span class="keyword">new</span> ReferenceCountingGc();</span><br><span class="line">      ReferenceCountingGc objB = <span class="keyword">new</span> ReferenceCountingGc();</span><br><span class="line">      objA.instance = objB;</span><br><span class="line">      objB.instance = objA;</span><br><span class="line">      objA = <span class="keyword">null</span>;</span><br><span class="line">      objB = <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h3><p>将“<strong>GC Roots</strong>”对象作为起点,从这些节点开始向下搜索引用的对象,找到的对象都标记为<strong>非垃圾对象</strong>,其余未标记的对象都是垃圾对象</p>
<p>GC Root根节点:==线程的本地变量==,静态变量,本地方法栈的变量等等</p>
<p><img data-src="%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90%E7%AE%97%E6%B3%95.jpeg" alt="可达性分析算法"> </p>
<h3 id="常见的引用类型"><a href="#常见的引用类型" class="headerlink" title="常见的引用类型"></a>常见的引用类型</h3><p>java的引用类型一般分为四种：<strong>强引用</strong>、<strong>软引用</strong>、弱引用、虚引用</p>
<h4 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h4><p>普通的变量引用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> User user = <span class="keyword">new</span> User();</span><br></pre></td></tr></table></figure>

<h4 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h4><p>将对象用SoftReference软引用类型的对象包裹,正常情况下不会被回收,但是GC做完后发现释放不出空间存放新的对象则会把这些软引用对象回收掉.<strong>软引用可用来实现内存敏感的高速缓存.</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> SoftReference&lt;User&gt; user =<span class="keyword">new</span> SoftReference&lt;User&gt;(<span class="keyword">new</span> User())</span><br></pre></td></tr></table></figure>

<p>软引用在实际中有重要的应用，例如浏览器的后退按钮。按后退时，这个后退时显示的网页内容是重新进行请求还是从缓存中取出呢？这就要看具体的实现策略了。</p>
<ol>
<li>如果一个网页在浏览结束时就进行内容的回收,则按后退查看前面浏览过的页面时，需要重新构建</li>
<li>如果将浏览过的网页存储到内存中会造成内存的大量浪费，甚至会造成内存溢出</li>
</ol>
<h4 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h4><p>将对象用WeakReference软引用类型的对象包裹，弱引用跟没引用差不多，<strong>GC会直接回收掉</strong>，很少用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> WeakReference&lt;User&gt; user = <span class="keyword">new</span> WeakReference&lt;User&gt;(<span class="keyword">new</span> User());</span><br></pre></td></tr></table></figure>

<h4 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h4><p>虚引用也称为幽灵引用或者幻影引用，它是最弱的一种引用关系，几乎不用</p>
<h3 id="finalize-方法最终判定对象是否存活"><a href="#finalize-方法最终判定对象是否存活" class="headerlink" title="finalize()方法最终判定对象是否存活"></a>finalize()方法最终判定对象是否存活</h3><p>即使在可达性分析算法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑”阶段，要真正宣告一个对象死亡，至少要经历再次标记过程。</p>
<p><strong>标记的前提是对象在进行可达性分析后发现没有与GC Roots相连接的引用链。</strong></p>
<p><strong>1. 第一次标记并进行一次筛选。</strong></p>
<p>筛选的条件是此对象是否有必要执行finalize()方法。</p>
<p>当对象没有覆盖finalize方法，对象将直接被回收。</p>
<p><strong>2. 第二次标记</strong></p>
<p>如果这个对象覆盖了finalize方法，finalize方法是对象脱逃死亡命运的最后一次机会，如果对象要在finalize()中成功拯救自己，只要重新与引用链上的任何的一个对象建立关联即可，譬如把自己赋值给某个类变量或对象的成员变量，那在第二次标记时它将移除出“即将回收”的集合。如果对象这时候还没逃脱，那基本上它就真的被回收了。</p>
<p>注意：一个对象的finalize()方法只会被执行一次，也就是说通过调用finalize方法自我救命的机会就一次。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OOMTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      List&lt;Object&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">      <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">         list.add(<span class="keyword">new</span> User(i++, UUID.randomUUID().toString()));</span><br><span class="line">         <span class="keyword">new</span> User(j--, UUID.randomUUID().toString());</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//User类需要重写finalize方法</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    OOMTest.list.add(<span class="keyword">this</span>);</span><br><span class="line">    System.out.println(<span class="string">"关闭资源，userid="</span> + id + <span class="string">"即将被回收"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>finalize()方法的运行代价高昂， 不确定性大， 无法保证各个对象的调用顺序， 如今已被官方明确声明为不推荐使用的语法。 有些资料描述它适合做“关闭外部资源”之类的清理性工作， 这完全是对finalize()方法用途的一种自我安慰。 finalize()能做的所有工作， 使用try-finally或者其他方式都可以做得更好、更及时， 所以建议大家完全可以忘掉Java语言里面的这个方法。</p>
<h3 id="如何判断一个类是无用的类"><a href="#如何判断一个类是无用的类" class="headerlink" title="如何判断一个类是无用的类"></a>如何判断一个类是无用的类</h3><p>方法区主要回收的是无用的类，那么如何判断一个类是无用的类呢？</p>
<p>类需要同时满足下面3个条件才能算是 <strong>“无用的类”</strong> ：</p>
<ul>
<li>该类所有的对象实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。</li>
<li>加载该类的 ClassLoader 已经被回收。</li>
<li>该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM系列(五)垃圾收集器G1和ZGC</title>
    <url>/blog/2022/08/01/JVM%E7%B3%BB%E5%88%97(%E4%BA%94)%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8G1%E5%92%8CZGC/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/blog/assets/css/APlayer.min.css"><script src="/blog/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="G1收集器-XX-UseG1GC"><a href="#G1收集器-XX-UseG1GC" class="headerlink" title="G1收集器(-XX:+UseG1GC)"></a>G1收集器(-XX:+UseG1GC)</h2><p>G1(Garbage-First)是一款面向服务器的垃圾收集器,==主要针对配备多颗处理器及大容量内存的机器==,以极高概率满足GC停顿时间要求的同时,还具备高吞吐量性能特征.</p>
<img data-src="G1收集器.png" alt="G1收集器"  />

<p><img data-src="G1%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.png" alt="G1内存模型"></p>
<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>G1将Java堆划分为多个大小相等的独立区域（<strong>Region</strong>），JVM目标是不超过2048个Region(JVM源码里TARGET_REGION_NUMBER 定义)，实际可以超过该值，但是不推荐。</p>
<p>一般Region大小等于堆大小除以2048，比如堆大小为4096M，则Region大小为2M，当然也可以用参数”-XX:G1HeapRegionSize”手动指定Region大小，但是推荐默认的计算方式。</p>
<p>G1保留了年轻代和老年代的概念，但不再是物理隔阂了，它们都是（可以不连续）Region的集合。</p>
<p>默认年轻代对堆内存的占比是5%，如果堆大小为4096M，那么年轻代占据200MB左右的内存，对应大概是100个Region，可以通过“-XX:G1NewSizePercent”设置新生代初始占比，在系统运行中，JVM会不停的给年轻代增加更多的Region，但是最多新生代的占比不会超过60%，可以通过“-XX:G1MaxNewSizePercent”调整。年轻代中的Eden和Survivor对应的region也跟之前一样，默认8:1:1，假设年轻代现在有1000个region，eden区对应800个，s0对应100个，s1对应100个。</p>
<p>一个Region可能之前是年轻代，如果Region进行了垃圾回收，之后可能又会变成老年代，也就是说Region的区域功能可能会动态变化。</p>
<p>G1垃圾收集器对于对象什么时候会转移到老年代跟之前讲过的原则一样，<strong>唯一不同的是对大对象的处理</strong>，G1有专门分配大对象的Region叫<strong>Humongous区</strong>，而不是让大对象直接进入老年代的Region中。在G1中，大对象的判定规则就是一个大对象超过了一个Region大小的50%，比如按照上面算的，每个Region是2M，只要一个大对象超过了1M，就会被放入Humongous中，而且一个大对象如果太大，可能会横跨多个Region来存放。</p>
<p>Humongous区专门存放短期巨型对象，不用直接进老年代，可以节约老年代的空间，避免因为老年代空间不够的GC开销。</p>
<p>Full GC的时候除了收集年轻代和老年代之外，也会将Humongous区一并回收。</p>
<h3 id="收集步骤"><a href="#收集步骤" class="headerlink" title="收集步骤"></a>收集步骤</h3><p>G1收集器一次GC(主要值Mixed GC)的运作过程大致分为以下几个步骤：</p>
<ul>
<li><p><strong>初始标记</strong>（initial mark，STW）：暂停所有的其他线程，并记录下gc roots直接能引用的对象，<strong>速度很快</strong> ；</p>
</li>
<li><p><strong>并发标记</strong>（Concurrent Marking）：同CMS的并发标记</p>
</li>
<li><p><strong>最终标记</strong>（Remark，STW）：同CMS的重新标记</p>
</li>
<li><p><strong>筛选回收</strong>（Cleanup，STW）：筛选回收阶段首先对各个Region的<strong>回收价值和成本进行排序</strong>，<strong>根据用户所期望的GC停顿STW时间(可以用JVM参数 -XX:MaxGCPauseMillis指定)来制定回收计划</strong>，比如说老年代此时有1000个Region都满了，但是因为根据预期停顿时间，本次垃圾回收可能只能停顿200毫秒，那么通过之前回收成本计算得知，可能回收其中800个Region刚好需要200ms，那么就只会回收800个Region(<strong>Collection Set</strong>，要回收的集合)，尽量把GC导致的停顿时间控制在我们指定的范围内。这个阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分Region，时间是用户可控制的，而且停顿用户线程将大幅提高收集效率。不管是年轻代或是老年代，<strong>回收算法主要用的是复制算法</strong>，<strong>将一个region中的存活对象复制到另一个region中，这种不会像CMS那样回收完因为有很多内存碎片还需要整理一次，G1采用复制算法回收几乎不会有太多内存碎片</strong>。(注意：CMS回收阶段是跟用户线程一起并发执行的，G1因为内部实现太复杂暂时没实现并发回收，不过到了ZGC，Shenandoah就实现了并发收集，Shenandoah可以看成是G1的升级版本)</p>
</li>
</ul>
<img data-src="G1收集步骤.png" alt="G1收集步骤" style="zoom:87%;" />



<p><strong>G1收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的Region(这也就是它的名字Garbage-First的由来)，比如一个Region花200ms能回收10M垃圾，另外一个Region花50ms能回收20M垃圾，在回收时间有限情况下，G1当然会优先选择后面这个Region回收</strong>。这种使用Region划分内存空间以及有优先级的区域回收方式，保证了G1收集器在有限时间内可以尽可能高的收集效率。</p>
<p>被视为JDK1.7以上版本Java虚拟机的一个重要进化特征。它具备以下特点：</p>
<ul>
<li><strong>并行与并发</strong>：G1能充分利用CPU、多核环境下的硬件优势，使用多个CPU（CPU或者CPU核心）来缩短Stop-The-World停顿时间。部分其他收集器原本需要停顿Java线程来执行GC动作，G1收集器仍然可以通过并发的方式让java程序继续执行。</li>
<li><strong>分代收集</strong>：虽然G1可以不需要其他收集器配合就能独立管理整个GC堆，但是还是保留了分代的概念。</li>
<li><strong>空间整合</strong>：与CMS的“标记–清理”算法不同，G1从整体来看是基于“<strong>标记整理</strong>”算法实现的收集器；从局部上来看是基于“复制”算法实现的。</li>
<li><strong>可预测的停顿</strong>：这是G1相对于CMS的另一个大优势，降低停顿时间是G1 和 CMS 共同的关注点，但G1 除了追求低停顿外，还能建立<strong>可预测的停顿时间模型</strong>，能让使用者明确指定在一个长度为M毫秒的时间片段(通过参数”<strong>-XX:MaxGCPauseMillis</strong>“指定)内完成垃圾收集。</li>
</ul>
<p>毫无疑问， 可以由用户指定期望的停顿时间是G1收集器很强大的一个功能， 设置不同的期望停顿时间， 可使得G1在不同应用场景中取得关注吞吐量和关注延迟之间的最佳平衡。 不过， 这里设置的“期望值”必须是符合实际的， 不能异想天开， 毕竟G1是要冻结用户线程来复制对象的， 这个停顿时</p>
<p>间再怎么低也得有个限度。 它默认的停顿目标为两百毫秒， 一般来说， 回收阶段占到几十到一百甚至接近两百毫秒都很正常， 但如果我们把停顿时间调得非常低， 譬如设置为二十毫秒， 很可能出现的结果就是由于停顿目标时间太短， 导致每次选出来的回收集只占堆内存很小的一部分， 收集器收集的速度逐渐跟不上分配器分配的速度， 导致垃圾慢慢堆积。 很可能一开始收集器还能从空闲的堆内存中获得一些喘息的时间， 但应用运行时间一长就不行了， 最终占满堆引发Full GC反而降低性能， 所以通常把期望停顿时间设置为一两百毫秒或者两三百毫秒会是比较合理的。</p>
<h3 id="G1垃圾收集分类"><a href="#G1垃圾收集分类" class="headerlink" title="G1垃圾收集分类"></a>G1垃圾收集分类</h3><h4 id="Young-GC"><a href="#Young-GC" class="headerlink" title="Young GC"></a>Young GC</h4><p>YoungGC并不是说现有的Eden区放满了就会马上触发，G1会计算下现在Eden区回收大概要多久时间，如果回收时间远远小于参数 -XX:MaxGCPauseMills 设定的值，那么增加年轻代的region，继续给新对象存放，不会马上做Young GC，直到下一次Eden区放满，G1计算回收时间接近参数 -XX:MaxGCPauseMills 设定的值，那么就会触发Young GC</p>
<h4 id="Mixed-GC"><a href="#Mixed-GC" class="headerlink" title="Mixed GC"></a>Mixed GC</h4><p>不是FullGC，老年代的堆占有率达到参数(<strong>-XX:InitiatingHeapOccupancyPercent</strong>)设定的值则触发，回收所有的Young和部分Old(根据期望的GC停顿时间确定old区垃圾收集的优先顺序)以及<strong>大对象区</strong>，正常情况G1的垃圾收集是先做MixedGC，主要使用复制算法，需要把各个region中存活的对象拷贝到别的region里去，拷贝过程中如果发现<strong>没有足够的空region</strong>能够承载拷贝对象就会触发一次Full GC</p>
<h4 id="Full-GC"><a href="#Full-GC" class="headerlink" title="Full GC"></a>Full GC</h4><p>停止系统程序，然后采用单线程进行标记、清理和压缩整理，好空闲出来一批Region来供下一次MixedGC使用，这个过程是非常耗时的。(Shenandoah优化成多线程收集了)</p>
<h3 id="G1收集器参数设置"><a href="#G1收集器参数设置" class="headerlink" title="G1收集器参数设置"></a>G1收集器参数设置</h3><p>-XX:+UseG1GC:使用G1收集器</p>
<p>  -XX:ParallelGCThreads:指定GC工作的线程数量</p>
<p>  -XX:G1HeapRegionSize:指定分区大小(1MB~32MB，且必须是2的N次幂)，默认将整堆划分为2048个分区</p>
<p>  -XX:MaxGCPauseMillis:目标暂停时间(默认200ms)</p>
<p>  -XX:G1NewSizePercent:新生代内存初始空间(默认整堆5%，值配置整数，默认就是百分比)</p>
<p>  -XX:G1MaxNewSizePercent:新生代内存最大空间</p>
<p>  -XX:TargetSurvivorRatio:Survivor区的填充容量(默认50%)，Survivor区域里的一批对象(年龄1+年龄2+年龄n的多个年龄对象)总和超过了Survivor区域的50%，此时就会把年龄n(含)以上的对象都放入老年代</p>
<p>  -XX:MaxTenuringThreshold:最大年龄阈值(默认15)</p>
<p>  -XX:InitiatingHeapOccupancyPercent:老年代占用空间达到整堆内存阈值(默认45%)，则执行新生代和老年代的混合收集(<strong>MixedGC</strong>)，比如我们之前说的堆默认有2048个region，如果有接近1000个region都是老年代的region，则可能就要触发MixedGC了</p>
<p> -XX:G1MixedGCLiveThresholdPercent(默认85%)  region中的存活对象低于这个值时才会回收该region，如果超过这个值，存活对象过多，回收的的意义不大。</p>
<p>  -XX:G1MixedGCCountTarget:在一次回收过程中指定做几次筛选回收(默认8次)，在最后一个筛选回收阶段可以回收一会，然后暂停回收，恢复系统运行，一会再开始回收，这样可以让系统不至于单次停顿时间过长。</p>
<p>  -XX:G1HeapWastePercent(默认5%): gc过程中空出来的region是否充足阈值，在混合回收的时候，对Region回收都是基于复制算法进行的，都是把要回收的Region里的存活对象放入其他Region，然后这个Region中的垃圾对象全部清理掉，这样的话在回收过程就会不断空出来新的Region，一旦空闲出来的Region数量达到了堆内存的5%，此时就会立即停止混合回收，意味着本次混合回收就结束了。</p>
<h3 id="G1垃圾收集器优化建议"><a href="#G1垃圾收集器优化建议" class="headerlink" title="G1垃圾收集器优化建议"></a>G1垃圾收集器优化建议</h3><p>假设参数 -XX:MaxGCPauseMills 设置的值很大，导致系统运行很久，年轻代可能都占用了堆内存的60%了，此时才触发年轻代gc。</p>
<p>那么存活下来的对象可能就会很多，此时就会导致Survivor区域放不下那么多的对象，就会进入老年代中。</p>
<p>或者是你年轻代gc过后，存活下来的对象过多，导致进入Survivor区域后触发了动态年龄判定规则，达到了Survivor区域的50%，也会快速导致一些对象进入老年代中。</p>
<p>所以这里核心还是在于调节 -XX:MaxGCPauseMills 这个参数的值，在保证他的年轻代gc别太频繁的同时，还得考虑每次gc过后的存活对象有多少,避免存活对象太多快速进入老年代，频繁触发mixed gc.</p>
<h4 id="什么场景适合使用G1"><a href="#什么场景适合使用G1" class="headerlink" title="什么场景适合使用G1"></a>什么场景适合使用G1</h4><ol>
<li>50%以上的堆被存活对象占用</li>
<li>对象分配和晋升的速度变化非常大</li>
<li>垃圾回收时间特别长，超过1秒</li>
<li>8GB以上的堆内存(建议值)</li>
<li>停顿时间是500ms以内</li>
</ol>
<h4 id="每秒几十万并发的系统如何优化JVM"><a href="#每秒几十万并发的系统如何优化JVM" class="headerlink" title="每秒几十万并发的系统如何优化JVM"></a>每秒几十万并发的系统如何优化JVM</h4><p>Kafka类似的支撑高并发消息系统大家肯定不陌生，对于kafka来说，每秒处理几万甚至几十万消息时很正常的，一般来说部署kafka需要用大内存机器(比如64G)，也就是说可以给年轻代分配个三四十G的内存用来支撑高并发处理，这里就涉及到一个问题了，我们以前常说的对于eden区的young gc是很快的，这种情况下它的执行还会很快吗？很显然，不可能，因为内存太大，处理还是要花不少时间的，假设三四十G内存回收可能最快也要几秒钟，按kafka这个并发量放满三四十G的eden区可能也就一两分钟吧，那么意味着整个系统每运行一两分钟就会因为young gc卡顿几秒钟没法处理新消息，显然是不行的。那么对于这种情况如何优化了，我们可以使用G1收集器，设置 -XX:MaxGCPauseMills 为50ms，假设50ms能够回收三到四个G内存，然后50ms的卡顿其实完全能够接受，用户几乎无感知，那么整个系统就可以在卡顿几乎无感知的情况下一边处理业务一边收集垃圾。</p>
<p>G1天生就适合这种大内存机器的JVM运行，可以比较完美的解决大内存垃圾回收时间过长的问题。</p>
<h2 id="ZGC收集器-XX-UseZGC"><a href="#ZGC收集器-XX-UseZGC" class="headerlink" title="ZGC收集器(-XX:+UseZGC)"></a>ZGC收集器(-XX:+UseZGC)</h2><p>参考文章：<a href="https://wiki.openjdk.java.net/display/zgc/Main" target="_blank" rel="noopener">https://wiki.openjdk.java.net/display/zgc/Main</a></p>
<p><a href="http://cr.openjdk.java.net/~pliden/slides/ZGC-Jfokus-2018.pdf" target="_blank" rel="noopener">http://cr.openjdk.java.net/~pliden/slides/ZGC-Jfokus-2018.pdf</a></p>
<p>ZGC是一款JDK 11中新加入的具有实验性质的低延迟垃圾收集器，ZGC可以说源自于是Azul System公司开发的C4（Concurrent Continuously Compacting Collector） 收集器。</p>
<img data-src="ZGC支持系统.png" alt="ZGC支持系统" style="zoom:67%;" />

<h3 id="ZGC目标"><a href="#ZGC目标" class="headerlink" title="ZGC目标"></a>ZGC目标</h3><p>如下图所示，ZGC的目标主要有4个：</p>
<img data-src="ZGC目标.png" alt="ZGC目标" style="zoom: 67%;" />



<ul>
<li><strong>支持TB量级的堆</strong>。我们生产环境的硬盘还没有上TB呢，这应该可以满足未来十年内，所有JAVA应用的需求了吧。 </li>
<li><strong>最大GC停顿时间不超10ms</strong>。目前一般线上环境运行良好的JAVA应用Minor GC停顿时间在10ms左右，Major GC一般都需要100ms以上（G1可以调节停顿时间，但是如果调的过低的话，反而会适得其反），之所以能做到这一点是因为它的停顿时间主要跟Root扫描有关，而Root数量和堆大小是没有任何关系的。 </li>
<li><strong>奠定未来GC特性的基础</strong>。</li>
<li><strong>最糟糕的情况下吞吐量会降低15%</strong>。这都不是事，停顿时间足够优秀。至于吞吐量，通过扩容分分钟解决。</li>
</ul>
<p>另外，Oracle官方提到了它最大的优点是：它的停顿时间不会随着堆的增大而增长！也就是说，几十G堆的停顿时间是10ms以下，几百G甚至上T堆的停顿时间也是10ms以下。</p>
<h3 id="不分代-暂时"><a href="#不分代-暂时" class="headerlink" title="不分代(暂时)"></a>不分代(暂时)</h3><p>单代，即ZGC「没有分代」。我们知道以前的垃圾回收器之所以分代，是因为源于“「大部分对象朝生夕死」”的假设，事实上大部分系统的对象分配行为也确实符合这个假设。</p>
<p>那么为什么ZGC就不分代呢？因为分代实现起来麻烦，作者就先实现出一个比较简单可用的单代版本，后续会优化。</p>
<h3 id="ZGC内存布局"><a href="#ZGC内存布局" class="headerlink" title="ZGC内存布局"></a>ZGC内存布局</h3><p>ZGC收集器是一款基于Region内存布局的， 暂时不设分代的， 使用了<strong>读屏障、 颜色指针</strong>等技术来实现可并发的标记-整理算法的， 以低延迟为首要目标的一款垃圾收集器。</p>
<p>ZGC的Region可以具有如图3-19所示的大、 中、 小三类容量：</p>
<ul>
<li>小型Region（Small Region） ： 容量固定为2MB， 用于放置小于256KB的小对象。</li>
<li>中型Region（Medium Region） ： 容量固定为32MB， 用于放置大于等于256KB但小于4MB的对象。</li>
<li>大型Region（Large Region） ： 容量不固定， 可以动态变化， 但必须为2MB的整数倍， 用于放置4MB或以上的大对象。 <strong>每个大型Region中只会存放一个大对象</strong>， 这也预示着虽然名字叫作“大型Region”， 但它的实际容量完全有可能小于中型Region， 最小容量可低至4MB。 大型Region在ZGC的实现中是不会被重分配（重分配是ZGC的一种处理动作， 用于复制对象的收集器阶段， 稍后会介绍到）的， 因为复制一个大对象的代价非常高昂。</li>
</ul>
<img data-src="ZGC内存布局.png" alt="ZGC内存布局" style="zoom:60%;" />

<h3 id="NUMA-aware"><a href="#NUMA-aware" class="headerlink" title="NUMA-aware"></a>NUMA-aware</h3><p>NUMA对应的有UMA，UMA即<strong>Uniform Memory Access Architecture</strong>，NUMA就是Non Uniform Memory Access Architecture。UMA表示内存只有一块，所有CPU都去访问这一块内存，那么就会存在竞争问题（争夺内存总线访问权），有竞争就会有锁，有锁效率就会受到影响，而且CPU核心数越多，竞争就越激烈。NUMA的话每个CPU对应有一块内存，且这块内存在主板上离这个CPU是最近的，每个CPU优先访问这块内存，那效率自然就提高了：</p>
<p><img data-src="NUMA.webp" alt="NUMA"></p>
<p>服务器的NUMA架构在中大型系统上一直非常盛行，也是高性能的解决方案，尤其在系统延迟方面表现都很优秀。ZGC是能自动感知NUMA架构并充分利用NUMA架构特性的。</p>
<h3 id="ZGC运作过程"><a href="#ZGC运作过程" class="headerlink" title="ZGC运作过程"></a>ZGC运作过程</h3><p>ZGC的运作过程大致可划分为以下四个大的阶段：</p>
<p><img data-src="ZGC%E8%BF%90%E4%BD%9C%E8%BF%87%E7%A8%8B.png" alt="ZGC运作过程"></p>
<ul>
<li><strong>并发标记（Concurrent Mark）</strong>：与G1一样，并发标记是遍历对象图做可达性分析的阶段，它的初始标记(<strong>Mark Start</strong>)和最终标记(<strong>Mark End</strong>)也会出现短暂的停顿，与G1不同的是， ZGC的标记是在指针上而不是在对象上进行的， 标记阶段会更新<strong>颜色指针</strong>(见下面详解)中的Marked 0、 Marked 1标志位。</li>
<li><strong>并发预备重分配（Concurrent Prepare for Relocate）</strong>：这个阶段需要根据特定的查询条件统计得出本次收集过程要清理哪些Region，将这些Region组成重分配集（Relocation Set）。ZGC每次回收都会扫描所有的Region，用范围更大的扫描成本换取省去G1中记忆集的维护成本。</li>
<li><strong>并发重分配（Concurrent Relocate）</strong>：重分配是ZGC执行过程中的核心阶段，这个过程要把重分配集中的存活对象复制到新的Region上，并为重分配集中的每个Region维护一个<strong>转发表（Forward Table）</strong>，记录从旧对象到新对象的转向关系。ZGC收集器能仅从引用上就明确得知一个对象是否处于重分配集之中，如果用户线程此时并发访问了位于重分配集中的对象，这次访问将会被预置的内存屏障(<strong>读屏障</strong>(见下面详解))所截获，然后立即根据Region上的转发表记录将访问转发到新复制的对象上，并同时修正更新该引用的值，使其直接指向新对象，ZGC将这种行为称为指针的“自愈”（Self-Healing）能力。</li>
</ul>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">ZGC的颜色指针因为“自愈”（Self-Healing）能力，所以只有第一次访问旧对象会变慢， 一旦重分配集中某个Region的存活对象都复制完毕后，</span><br><span class="line">这个Region就可以立即释放用于新对象的分配，但是转发表还得留着不能释放掉， 因为可能还有访问在使用这个转发表。</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>并发重映射（Concurrent Remap）</strong>：重映射所做的就是修正整个堆中指向重分配集中旧对象的所有引用，但是ZGC中对象引用存在“自愈”功能，所以这个重映射操作并不是很迫切。ZGC很巧妙地把并发重映射阶段要做的工作，合并到了下一次垃圾收集循环中的并发标记阶段里去完成，反正它们都是要遍历所有对象的，这样合并就节省了一次遍历对象图的开销。一旦所有指针都被修正之后， 原来记录新旧对象关系的转发表就可以释放掉了。</li>
</ul>
<h3 id="颜色指针"><a href="#颜色指针" class="headerlink" title="颜色指针"></a>颜色指针</h3><p>Colored Pointers，即颜色指针，如下图所示，ZGC的核心设计之一。以前的垃圾回收器的GC信息都保存在对象头中，而ZGC的GC信息保存在指针中。</p>
<img data-src="颜色指针.png" alt="颜色指针" style="zoom:67%;" />

<p>每个对象有一个64位指针，这64位被分为：</p>
<ul>
<li>18位：预留给以后使用；</li>
<li>1位：Finalizable标识，此位与并发引用处理有关，它表示这个对象只能通过finalizer才能访问；</li>
<li>1位：Remapped标识，设置此位的值后，对象未指向relocation set中（relocation set表示需要GC的Region集合）；</li>
<li>1位：Marked1标识；</li>
<li>1位：Marked0标识，和上面的Marked1都是标记对象用于辅助GC；</li>
<li>42位：对象的地址（所以它可以支持2^42=4T内存）</li>
</ul>
<h4 id="为什么有2个mark标记？"><a href="#为什么有2个mark标记？" class="headerlink" title="为什么有2个mark标记？"></a>为什么有2个mark标记？</h4><p>每一个GC周期开始时，会交换使用的标记位，使上次GC周期中修正的已标记状态失效，所有引用都变成未标记。</p>
<p>GC周期1：使用mark0, 则周期结束所有引用mark标记都会成为01。</p>
<p>GC周期2：使用mark1, 则期待的mark标记10，所有引用都能被重新标记。</p>
<p>通过对配置ZGC后对象指针分析我们可知，对象指针必须是64位，那么ZGC就无法支持32位操作系统，同样的也就无法支持压缩指针了（CompressedOops，压缩指针也是32位）。</p>
<h4 id="颜色指针的三大优势："><a href="#颜色指针的三大优势：" class="headerlink" title="颜色指针的三大优势："></a>颜色指针的三大优势：</h4><ol>
<li>一旦某个Region的存活对象被移走之后，这个Region立即就能够被释放和重用掉，而不必等待整个堆中所有指向该Region的引用都被修正后才能清理，这使得理论上只要还有一个空闲Region，ZGC就能完成收集。</li>
<li>颜色指针可以大幅减少在垃圾收集过程中内存屏障的使用数量，ZGC只使用了读屏障。</li>
<li>颜色指针具备强大的扩展性，它可以作为一种可扩展的存储结构用来记录更多与对象标记、重定位过程相关的数据，以便日后进一步提高性能。</li>
</ol>
<h3 id="读屏障"><a href="#读屏障" class="headerlink" title="读屏障"></a>读屏障</h3><p>之前的GC都是采用Write Barrier，这次ZGC采用了完全不同的方案读屏障，这个是ZGC一个非常重要的特性。</p>
<p>在标记和移动对象的阶段，每次「从堆里对象的引用类型中读取一个指针」的时候，都需要加上一个Load Barriers。</p>
<p>那么我们该如何理解它呢？看下面的代码，第一行代码我们尝试读取堆中的一个对象引用obj.fieldA并赋给引用o（fieldA也是一个对象时才会加上读屏障）。如果这时候对象在GC时被移动了，接下来JVM就会加上一个读屏障，这个屏障会把读出的指针更新到对象的新地址上，并且把堆里的这个指针“修正”到原本的字段里。这样就算GC把对象移动了，读屏障也会发现并修正指针，于是应用代码就永远都会持有更新后的有效指针，而且不需要STW。</p>
<p>那么，JVM是如何判断对象被移动过呢？就是利用上面提到的颜色指针，如果指针是Bad Color，那么程序还不能往下执行，需要「slow path」，修正指针；如果指针是Good Color，那么正常往下执行即可：</p>
<img data-src="读屏障.png" alt="读屏障" style="zoom:70%;" />

<p>❝ 这个动作是不是非常像JDK并发中用到的CAS自旋？读取的值发现已经失效了，需要重新读取。而ZGC这里是之前持有的指针由于GC后失效了，需要通过读屏障修正指针。❞ </p>
<p>后面3行代码都不需要加读屏障：Object p = o这行代码并没有从堆中读取数据；o.doSomething()也没有从堆中读取数据；obj.fieldB不是对象引用，而是原子类型。</p>
<p>正是因为Load Barriers的存在，所以会导致配置ZGC的应用的吞吐量会变低。官方的测试数据是需要多出额外4%的开销：</p>
<img data-src="读屏障2.png" alt="读屏障2" style="zoom:70%;" />

<p>那么，判断对象是Bad Color还是Good Color的依据是什么呢？就是根据上一段提到的Colored Pointers的4个颜色位。当加上读屏障时，根据对象指针中这4位的信息，就能知道当前对象是Bad/Good Color了。</p>
<p><strong>PS：</strong>既然低42位指针可以支持4T内存，那么能否通过预约更多位给对象地址来达到支持更大内存的目的呢？答案肯定是不可以。因为目前主板地址总线最宽只有48bit，4位是颜色位，就只剩44位了，所以受限于目前的硬件，ZGC最大只能支持16T的内存，JDK13就把最大支持堆内存从4T扩大到了16T。</p>
<h3 id="ZGC存在的问题"><a href="#ZGC存在的问题" class="headerlink" title="ZGC存在的问题"></a>ZGC存在的问题</h3><p>ZGC最大的问题是<strong>浮动垃圾</strong>。ZGC的停顿时间是在10ms以下，但是ZGC的执行时间还是远远大于这个时间的。假如ZGC全过程需要执行10分钟，在这个期间由于对象分配速率很高，将创建大量的新对象，这些对象很难进入当次GC，所以只能在下次GC的时候进行回收，这些只能等到下次GC才能回收的对象就是浮动垃圾。</p>
<p>==ZGC没有分代概念，每次都需要进行全堆扫描，导致一些“朝生夕死”的对象没能及时的被回收。==   </p>
<p><strong>解决方案</strong></p>
<p>目前唯一的办法是增大堆的容量，使得程序得到更多的喘息时间，但是这个也是一个治标不治本的方案。如果需要从根本上解决这个问题，还是需要引入分代收集，让新生对象都在一个专门的区域中创建，然后专门针对这个区域进行更频繁、更快的收集。</p>
<h3 id="ZGC参数设置"><a href="#ZGC参数设置" class="headerlink" title="ZGC参数设置"></a>ZGC参数设置</h3><p>启用ZGC比较简单，设置JVM参数即可：-XX:+UnlockExperimentalVMOptions 「-XX:+UseZGC」。调优也并不难，因为ZGC调优参数并不多，远不像CMS那么复杂。它和G1一样，可以调优的参数都比较少，大部分工作JVM能很好的自动完成。下图所示是ZGC可以调优的参数：</p>
<p><img data-src="ZGC%E8%B0%83%E4%BC%98%E5%8F%82%E6%95%B0.png" alt="ZGC调优参数"></p>
<h3 id="ZGC触发时机"><a href="#ZGC触发时机" class="headerlink" title="ZGC触发时机"></a>ZGC触发时机</h3><p>ZGC目前有4中机制触发GC：</p>
<ul>
<li>定时触发，默认为不使用，可通过ZCollectionInterval参数配置。</li>
<li>预热触发，最多三次，在堆内存达到10%、20%、30%时触发，主要时统计GC时间，为其他GC机制使用。</li>
<li>分配速率，基于正态分布统计，计算内存99.9%可能的最大分配速率，以及此速率下内存将要耗尽的时间点，在耗尽之前触发GC（耗尽时间 - 一次GC最大持续时间 - 一次GC检测周期时间）。</li>
<li>主动触发，（默认开启，可通过ZProactive参数配置） 距上次GC堆内存增长10%，或超过5分钟时，对比距上次GC的间隔时间跟（49 * 一次GC的最大持续时间），超过则触发。</li>
</ul>
<h2 id="如何选择垃圾收集器"><a href="#如何选择垃圾收集器" class="headerlink" title="如何选择垃圾收集器"></a>如何选择垃圾收集器</h2><ol>
<li>优先调整堆的大小让服务器自己来选择</li>
<li>如果内存小于100M，使用串行收集器</li>
<li>如果是单核，并且没有停顿时间的要求，串行或JVM自己选择</li>
<li>如果允许停顿时间超过1秒，选择并行或者JVM自己选</li>
<li>如果响应时间最重要，并且不能超过1秒，使用并发收集器</li>
<li><strong>4G以下可以用parallel，4-8G可以用ParNew+CMS，8G以上可以用G1，几百G以上用ZGC</strong></li>
</ol>
<p><img data-src="%E9%80%89%E6%8B%A9%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8.png" alt="选择垃圾收集器"></p>
<p><strong>JDK 1.8默认使用 Parallel(年轻代和老年代都是)</strong></p>
<p><strong>JDK 1.9默认使用 G1</strong></p>
<h2 id="安全点与安全区域"><a href="#安全点与安全区域" class="headerlink" title="安全点与安全区域"></a>安全点与安全区域</h2><p><strong>安全点</strong>就是指代码中一些特定的位置,当线程运行到这些位置时它的状态是确定的,这样JVM就可以安全的进行一些操作,比如GC等，所以GC不是想什么时候做就立即触发的，是需要等待所有线程运行到安全点后才能触发。</p>
<p>这些特定的安全点位置主要有以下几种:</p>
<ol>
<li>方法返回之前</li>
<li>调用某个方法之后</li>
<li>抛出异常的位置</li>
<li>循环的末尾</li>
</ol>
<p>大体实现思想是当垃圾收集需要中断线程的时候， 不直接对线程操作， 仅仅简单地设置一个标志位， 各个线程执行过程时会不停地主动去轮询这个标志， 一旦发现中断标志为真时就自己在最近的安全点上主动中断挂起。 轮询标志的地方和安全点是重合的。</p>
<p><strong>安全区域又是什么？</strong></p>
<p>Safe Point 是对正在执行的线程设定的。</p>
<p>如果一个线程处于 Sleep 或中断状态，它就不能响应 JVM 的中断请求，再运行到 Safe Point 上。</p>
<p>因此 JVM 引入了 Safe Region。</p>
<p>Safe Region 是指在一段代码片段中，<strong>引用关系不会发生变化</strong>。在这个区域内的任意地方开始 GC 都是安全的。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM系列(二)JVM内存模型深度剖析与优化</title>
    <url>/blog/2022/08/01/JVM%E7%B3%BB%E5%88%97(%E4%BA%8C)JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90%E4%B8%8E%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/blog/assets/css/APlayer.min.css"><script src="/blog/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="JDK体系结构"><a href="#JDK体系结构" class="headerlink" title="JDK体系结构"></a>JDK体系结构</h2><img data-src="JDK体系结构.jpg" alt="JDK体系结构"  />

<h3 id="javap"><a href="#javap" class="headerlink" title="javap"></a>javap</h3><p>通过<strong>反编译</strong>生成的字节码文件，我们可以深入的了解java代码的工作机制。但是，自己分析类文件结构太麻烦了！除了使用第三方的jclasslib工具之外，oracle官方也提供了工具：javap。</p>
<p><strong>javap是jdk自带的反解析工具。它的作用就是根据class字节码文件，反解析出当前类对应的code区 （字节码指令）、局部变量表、异常表和代码行偏移量映射表、常量池等信息。</strong></p>
<img data-src="javap.png" alt="javap" style="zoom: 50%;" />

<ul>
<li>javap -l ：会输出行号和本地变量表信息；</li>
<li>javap -c ：会对当前class字节码进行反编译生成汇编代码；</li>
<li>javap -v： class字节码文件中除了包-c参数包含的内容外，还会输出行号、局部变量表信息、常量池等信息；</li>
<li><strong>通过javap命令可以查看一个java类反汇编得到的Class文件版本号、常量池、访问标识、变量表、指令代码行号表等信息，但是注意，javap命令并不会显示类索引、父类索引、接口索引集合、<clinit>()、<init>()等结构；</strong></li>
</ul>
<h2 id="Java语言的跨平台特性"><a href="#Java语言的跨平台特性" class="headerlink" title="Java语言的跨平台特性"></a>Java语言的跨平台特性</h2><p><img data-src="Java%E8%AF%AD%E8%A8%80%E7%9A%84%E8%B7%A8%E5%B9%B3%E5%8F%B0%E7%89%B9%E6%80%A7.png" alt="Java语言的跨平台特性"></p>
<h2 id="JVM整体结构及内存模型"><a href="#JVM整体结构及内存模型" class="headerlink" title="JVM整体结构及内存模型"></a>JVM整体结构及内存模型</h2><img data-src="JVM内存模型.png" alt="JVM内存模型"  />

<img data-src="运行时JVM内存区域.jpeg" alt="运行时JVM内存区域"  />

<h3 id="内存结构"><a href="#内存结构" class="headerlink" title="内存结构"></a>内存结构</h3><h4 id="堆-Heap"><a href="#堆-Heap" class="headerlink" title="堆(Heap)"></a>堆(Heap)</h4><p>线程共享。所有的对象实例以及数组都要在堆上分配。回收器主要管理的对象。</p>
<h5 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h5><p>堆的作用是存放对象实例和数组。从结构上来分，可以分为新生代和老年代。而新生代又可以分为Eden 空间、From Survivor 空间（s0）、To Survivor 空间（s1）。 所有新生成的对象首先都是放在新生代的。需要注意，Survivor的两个区是对称的，没先后关系，所以同一个区中可能同时存在从Eden复制过来的对象，和从前一个Survivor复制过来的对象，而复制到老年代的只有从第一个Survivor区过来的对象。而且，Survivor区总有一个是空的。</p>
<h5 id="控制参数"><a href="#控制参数" class="headerlink" title="控制参数"></a>控制参数</h5><p>-Xms设置堆的最小空间大小。-Xmx设置堆的最大空间大小。-XX:NewSize设置新生代最小空间大小。-XX:MaxNewSize设置新生代最大空间大小。</p>
<h5 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h5><p>此区域是垃圾回收的主要操作区域。</p>
<h4 id="方法区（Method-Area"><a href="#方法区（Method-Area" class="headerlink" title="方法区（Method Area)"></a>方法区（Method Area)</h4><h5 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h5><p>方法区（Method Area）与Java 堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量池、静态变量、即时编译器编译后的代码等数据。虽然Java 虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做Non-Heap（非堆），目的应该是与Java 堆区分开来。</p>
<p>很多人愿意把方法区称为“永久代”（Permanent Generation），本质上两者并不等价，仅仅是因为HotSpot虚拟机的设计团队选择把GC 分代收集扩展至方法区，或者说使用永久代来实现方法区而已。对于其他虚拟机（如BEA JRockit、IBM J9 等）来说是不存在永久代的概念的。在Java8中永生代彻底消失了。</p>
<h5 id="控制参数-1"><a href="#控制参数-1" class="headerlink" title="控制参数"></a>控制参数</h5><p>-XX:PermSize 设置最小空间 -XX:MaxPermSize 设置最大空间。</p>
<h5 id="垃圾回收-1"><a href="#垃圾回收-1" class="headerlink" title="垃圾回收"></a>垃圾回收</h5><p>对此区域会涉及但是很少进行垃圾回收。这个区域的内存回收目标主要是针对常量池的回收和对类型的卸载，一般来说这个区域的回收“成绩”比较难以令人满意。</p>
<h4 id="栈-JVM-Stack）"><a href="#栈-JVM-Stack）" class="headerlink" title="栈(JVM Stack）"></a>栈(JVM Stack）</h4><p>线程私有。存储局部变量表、操作栈、动态链接、方法出口，对象指针。</p>
<img data-src="栈.png" alt="栈"  />

<h5 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h5><p>每一个线程都有自己的java虚拟机栈，这个栈与线程同时创建，一个线程中的每个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。每个线程有一个私有的栈，随着线程的创建而创建。栈里面存着的是一种叫“栈帧”的东西，每个方法会创建一个栈帧，栈帧中存放了局部变量表（基本数据类型和对象引用）、操作数栈、动态链接和返回地址等信息。</p>
<p>当前运行方法对应的栈帧叫做当前栈帧。局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。</p>
<h5 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h5><p>生命周期和线程的生命周期是一致的</p>
<h5 id="栈的特点"><a href="#栈的特点" class="headerlink" title="栈的特点"></a>栈的特点</h5><p>栈是一种快速有效的分配储存方式，访问速度仅次于程序计数器。</p>
<p>JVM堆虚拟机栈的操作只有两个:</p>
<ul>
<li><p>每个方法执行，伴随着进栈</p>
</li>
<li><p>方法执行结束后，伴随着出栈</p>
</li>
</ul>
<p>对于栈来说并不存在垃圾回收的问题，但是存在溢出的问题。</p>
<h5 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h5><p>局部变量表的实际数据结构就是一个数组，solt就是指的数组的下标。主要用来存储方法参数，方法体内的局部变量。包括基本数据类型，对象引用，return Address。<strong>局部变量表中的变量也是重要的垃圾回收根节点，只要被局部变量表中直接或间接引用的对象都不会被回收。</strong></p>
<p>局部变量表里存放了编译期间可知的各种基本数据类型（8种）、对象引用、return Address类型（指向一条字节码指令的地址）。他有如下特点：</p>
<ul>
<li>64位长度的long和double类型占用2个局部变量空间（Slot），其余数据类型只占用一个。</li>
<li>局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的.</li>
<li>在方法运行期间不会改变局部变量表的大小。</li>
</ul>
<h6 id="关于Slot的理解"><a href="#关于Slot的理解" class="headerlink" title="关于Slot的理解"></a>关于Slot的理解</h6><p>Slot是局部变量表中最基本的存储单位</p>
<p>32位以内的类型占1个slot，64位以内的类型占2个slot。值得注意的是byte、short、char 在存储前被转换为int，boolean也被转换为int，0表示false，非0表示true。</p>
<p>每个Slot都会对应一个索引，通过这个索引访问局部变量表中的局部变量值。</p>
<p>当一个实例方法被调用的时候，它的方法参数和方法体内部定义的局部变量将会按照顺序被复制到局部变量表中的每一个slot上</p>
<p>如果需要访问局部变量表中一个64bit的局部变量值时，只需要使用前一个索引即可。（比如：访问long或double类型变量）</p>
<p>如果当前帧是由构造方法或者实例方法创建的，那么该对象引用this将会存放在index为0的slot处，其余的参数按照参数表顺序继续排列。</p>
<h6 id="静态变量和局部变量的对比"><a href="#静态变量和局部变量的对比" class="headerlink" title="静态变量和局部变量的对比"></a>静态变量和局部变量的对比</h6><p>按照数据类型分类：</p>
<ul>
<li><p>基本数据类型</p>
</li>
<li><p>引用数据类型</p>
</li>
</ul>
<p>按照类中声明的位置： </p>
<ul>
<li><p>成员变量： 在使用前都经历过默认初始化赋值</p>
<ul>
<li><p>类变量：连接的准备阶段默认赋值，初始化阶段显示赋值</p>
</li>
<li><p>实例变量：随着对象的创建会在堆空间中分配空间并赋值</p>
</li>
</ul>
</li>
<li><p>局部变量：使用前必须进行显式赋值</p>
</li>
</ul>
<p>类变量：在类加载时有两个机会进行初始化，分别是加载时的准备阶段和初始化阶段。</p>
<p>而局部变量和类变量不同，局部变量表不存在系统初始化的过程，这意味着一旦定义了局部变量则必须人为的初始化，否则无法使用。</p>
<h5 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h5><p>其实在栈帧刚刚创建的时候，操作数栈是空的，java虚拟机可以从局部变量表或者对象的实例字段中，复制一些常量或者变量值到操作数栈中。也可以从操作数栈中取走数据。它的深度在编译期就已经确定了。在方法的code属性中max_stack进行查看。</p>
<h6 id="栈顶缓存技术-Tos"><a href="#栈顶缓存技术-Tos" class="headerlink" title="栈顶缓存技术(Tos)"></a>栈顶缓存技术(Tos)</h6><p>由于操作数是存储在内存中的，因此频繁地执行内存读/写操作必然会影响执行速度。为了解决这个问题，HotSpot JVM的设计者们提出了栈顶缓存（Tos，Top-of-Stack Cashing）技术，将栈顶元素全部缓存在物理CPU的寄存器中，以此降低对内存的读/写次数，提升执行引擎的执行效率。</p>
<h5 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h5><blockquote>
<p>每一个栈帧内部都包含一个指向运行时常量池中该栈帧所属方法的引用。包含这个引用的目的就是为了支持当前方法的代码能够实现动态链接（Dynamic Linking）。</p>
</blockquote>
<p>在线程中一个方法去调用另外一个方法，是通过符号引用来实现的，动态链接的作用就是把这个符号引用表示的方法转化为实际方法的直接引用。</p>
<p>在Java源文件被编译到字节码文件中时，所有的变量和方法引用都作为符号引用（Symbolic Reference）保存在class文件的常量池里。比如：描述一个方法调用了另外的其他方法时，就是通过常量池中指向方法的符号引用来表示的，那么动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用。</p>
<h5 id="方法出口"><a href="#方法出口" class="headerlink" title="方法出口"></a>方法出口</h5><p>方法的退出存在两种情景：一是正常执行完成后退出，二是出现未处理的非正常退出。无论哪种退出方式，方法退出后都会返回该方法的调用位置。方法正常退出时，调用者的pc计数器的值作为返回地址，即调用该方法的指令的下一条指令的地址。而通过异常退出的，返回地址是要通过异常表来确定，栈帧中一般不会保存这部分信息。</p>
<blockquote>
<p>当一个方法开始执行后，只有两种方式可以退出这个方法：</p>
<p>执行引擎遇到任意一个方法返回的字节码指令（return），会有返回值传递给上层的方法调用者，简称正常完成出口；</p>
<ul>
<li><p>一个方法在正常调用完成之后，究竟需要使用哪一个返回指令，还需要根据方法返回值的实际数据类型而定。</p>
</li>
<li><p>在字节码指令中，返回指令包含ireturn（当返回值是boolean，byte，char，short和int类型时使用），lreturn（Long类型），freturn（Float类型），dreturn（Double类型），areturn。另外还有一个return指令声明为void的方法，实例初始化方法，类和接口的初始化方法使用。</p>
</li>
</ul>
<p>方法执行过程中，抛出异常时的异常处理，存储在一个异常处理表，方便在发生异常的时候找到处理异常的代码</p>
</blockquote>
<h5 id="附带信息"><a href="#附带信息" class="headerlink" title="附带信息"></a>附带信息</h5><p>栈帧中还允许携带与Java虚拟机实现相关的一些附加信息。例如：对程序调试提供支持的信息。</p>
<h5 id="控制参数-2"><a href="#控制参数-2" class="headerlink" title="控制参数"></a>控制参数</h5><p>-Xss控制每个线程栈的大小。</p>
<h5 id="异常情况"><a href="#异常情况" class="headerlink" title="异常情况"></a>异常情况</h5><p>在Java 虚拟机规范中，对这个区域规定了两种异常状况：</p>
<p>- StackOverflowError： 异常线程请求的栈深度大于虚拟机所允许的深度时抛出；</p>
<p>- OutOfMemoryError 异常： 虚拟机栈可以动态扩展，当扩展时无法申请到足够的内存或者是创建新线程时没有足够的内存再创建java虚拟机栈时会抛出。</p>
<h4 id="本地方法栈-Native-Method-Stack"><a href="#本地方法栈-Native-Method-Stack" class="headerlink" title="本地方法栈(Native Method Stack)"></a>本地方法栈(Native Method Stack)</h4><p>线程私有。为虚拟机使用到的Native 方法服务。如Java使用c或者c++编写的接口服务时，代码在此区运行。</p>
<h5 id="概念-3"><a href="#概念-3" class="headerlink" title="概念"></a>概念</h5><p>本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别不过是虚拟机栈为虚拟机执行Java 方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的Native 方法服务。</p>
<h5 id="控制参数-3"><a href="#控制参数-3" class="headerlink" title="控制参数"></a>控制参数</h5><p>在Sun JDK中本地方法栈和方法栈是同一个，因此也可以用-Xss控制每个线程的大小。</p>
<p>与虚拟机栈一样，本地方法栈区域也会抛出StackOverflowError 和OutOfMemoryError异常。</p>
<h4 id="程序计数器-Program-Counter-Register"><a href="#程序计数器-Program-Counter-Register" class="headerlink" title="程序计数器(Program Counter Register)"></a>程序计数器(Program Counter Register)</h4><h5 id="概念-4"><a href="#概念-4" class="headerlink" title="概念"></a>概念</h5><p>计算机组成原理里面提到内存里面有很多寄存器，大概几百个吧，每一种寄存器的用途都不一样，其中有一个寄存器就是程序计数器。这个寄存器的主要作用就是<strong>==当前线程所执行的字节码的行号指示器。指向下一条要执行的指令。==</strong>线程私有。有些文章也翻译成PC寄存器（PC Register）。</p>
<h5 id="为什么要有这个程序计数器呢？"><a href="#为什么要有这个程序计数器呢？" class="headerlink" title="为什么要有这个程序计数器呢？"></a>为什么要有这个程序计数器呢？</h5><p>因为我们的处理器在一个时刻，只能执行一个线程中的指令。但是我们的程序往往都是多线程的，这时候处理器就需要来回切换我们的线程，为了在线程切换之后回到之前正确的位置上，此时就需要一个程序计数器，这也就很容易理解了我们的每个线程都有一个自己的程序计数器来保存自己之前的状态。</p>
<h5 id="程序计数器的功能是什么"><a href="#程序计数器的功能是什么" class="headerlink" title="程序计数器的功能是什么?"></a>程序计数器的功能是什么?</h5><p>我们的程序代码假如是一行一行执行的，程序计数器永远指向下一行需要执行的字节码指令。在循环结构中，我们就可以改变程序计数器中的值，来指向下一条需要执行的指令。因此，在分支、循环、跳转、异常处理和线程恢复等等一些场景都需要这个程序计数器来完成。</p>
<p>《java虚拟机规范》中说如果当前执行的是 Java 的方法，则该寄存器中保存当前执行指令的地址；倘若执行的是native方法，则PC寄存器中为空（Undefined）。PC寄存区区域就是存放了N多个这样的寄存区。此内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域.因此可以把他的几个特点归纳如下。</p>
<ol>
<li>程序计数器指定下一条需要执行的指令</li>
<li>每一个线程独有一个程序计数器</li>
<li>执行java代码时，寄存器保存当前指令地址</li>
<li>执行native方法时候，寄存器为空</li>
<li>不会造成OutOfMemoryError情况</li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><table>
<thead>
<tr>
<th>运行时数据区</th>
<th>是否存在Error</th>
<th>是否存在GC</th>
</tr>
</thead>
<tbody><tr>
<td>程序计数器</td>
<td>否</td>
<td>否</td>
</tr>
<tr>
<td>虚拟机栈</td>
<td>是</td>
<td>否</td>
</tr>
<tr>
<td>本地方法栈</td>
<td>是</td>
<td>否</td>
</tr>
<tr>
<td>方法区</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>堆</td>
<td>是</td>
<td>是</td>
</tr>
</tbody></table>
<h3 id="在minor-gc过程中对象挪动后，引用如何修改"><a href="#在minor-gc过程中对象挪动后，引用如何修改" class="headerlink" title="在minor gc过程中对象挪动后，引用如何修改"></a>在minor gc过程中对象挪动后，引用如何修改</h3><p>对象在堆内部挪动的过程其实是复制，原有区域对象还在，一般不直接清理，JVM内部清理过程只是将对象分配指针移动到区域的头位置即可，比如扫描s0区域，扫到gcroot引用的非垃圾对象是将这些对象<strong>复制</strong>到s1或老年代，最后扫描完了将s0区域的对象分配指针移动到区域的起始位置即可，s0区域之前对象并不直接清理，当有新对象分配了，原有区域里的对象也就被清除了。</p>
<p>minor gc在根扫描过程中会记录所有被扫描到的对象引用(在年轻代这些引用很少，因为大部分都是垃圾对象不会扫描到)，如果引用的对象被复制到新地址了，最后会一并更新引用指向新地址。</p>
<p>这里面内部算法比较复杂，感兴趣可以参考R大的这篇文章：</p>
<p><a href="https://hllvm-group.iteye.com/group/topic/39376#post-257329" target="_blank" rel="noopener">https://hllvm-group.iteye.com/group/topic/39376#post-257329</a></p>
<h2 id="JVM内存参数设置"><a href="#JVM内存参数设置" class="headerlink" title="JVM内存参数设置"></a>JVM内存参数设置</h2><h3 id="jvm参数分类"><a href="#jvm参数分类" class="headerlink" title="jvm参数分类"></a>jvm参数分类</h3><p>根据jvm参数开头可以区分参数类型，共三类：“-”、“-X”、“-XX”，</p>
<h4 id="标准参数"><a href="#标准参数" class="headerlink" title="标准参数(-)"></a>标准参数(-)</h4><p>所有的JVM实现都必须实现这些参数的功能,而且向后兼容;</p>
<p>例子：-verbose:class，-verbose:gc，-verbose:jni……</p>
<h4 id="非标准参数-X"><a href="#非标准参数-X" class="headerlink" title="非标准参数(-X)"></a>非标准参数(-X)</h4><p>默认JVM实现这些参数的功能,但是并不保证所有JVM实现都满足,且不保证向后兼容;</p>
<p>例子：Xms20m，-Xmx20m，-Xmn20m，-Xss128k……</p>
<h4 id="非Stable参数-XX"><a href="#非Stable参数-XX" class="headerlink" title="非Stable参数(-XX)"></a>非Stable参数(-XX)</h4><p>此类参数各个JVM实现会有所不同,将来可能会随时取消,需要慎重使用;</p>
<p>例子：-XX:+PrintGCDetails，-XX:-UseParallelGC，-XX:+PrintGCTimeStamps……</p>
<h3 id="关键参数详解"><a href="#关键参数详解" class="headerlink" title="关键参数详解"></a>关键参数详解</h3><p>最重要和常见的几个参数如下：</p>
<p>■ -Xms20m ：设置jvm初始化堆大小为20m，一般与-Xmx相同避免垃圾回收完成后jvm重新分。</p>
<p>■ -Xmx20m：设置jvm最大可用内存大小为20m。</p>
<p>■ -Xmn10m：设置新生代大小为20m。</p>
<p>■ -Xss128k：设置每个线程的栈大小为128k。</p>
<p>上面这几个参数我以前经常容易被混淆，不过后来根据字母拆分就简单了很多。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>拆分</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>-Xms</td>
<td>-X ,memory,size</td>
<td>内存大小</td>
</tr>
<tr>
<td>-Xmx</td>
<td>-X,memory,max</td>
<td>内存最大</td>
</tr>
<tr>
<td>-Xmn</td>
<td>-X,memory,new</td>
<td>新生代内存</td>
</tr>
<tr>
<td>-Xss</td>
<td>-X,stack,size</td>
<td>栈大小</td>
</tr>
</tbody></table>
<p>还有几个GC的参数见名知意就不详解了，后面测试会一一说明，主要的如下：</p>
<p>■ -verbose:gc：可以输出每次GC的一些信息；</p>
<p>■ -XX:-UseConcMarkSweepGC：使用CMS收集器；</p>
<p>■ -XX:-UseParallelGC ；</p>
<p>■ -XX:-UseSerialGC；</p>
<p>■ -XX:CMSInitiatingOccupancyFraction=80 CMS gc，表示在老年代达到80%使用率时马上进行回收；</p>
<p>■ -XX:+printGC；</p>
<p>■ -XX:+PrintGCDetails：打印GC详情；</p>
<p>■ -XX:+PrintGCTimeStamps：打印时间戳；</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL</title>
    <url>/blog/2020/08/18/MySQL/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/blog/assets/css/APlayer.min.css"><script src="/blog/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h1><p>MySQL 数据库管理系统具有很多的优势，下面总结了其中几种。</p>
<h2 id="特点和优势"><a href="#特点和优势" class="headerlink" title="特点和优势"></a>特点和优势</h2><h3 id="MySQL-是开放源代码的数据库"><a href="#MySQL-是开放源代码的数据库" class="headerlink" title="MySQL 是开放源代码的数据库"></a>MySQL 是开放源代码的数据库</h3><p>MySQL 是开放源代码的数据库，任何人都可以获取该数据库的源代码。这就使得任何人都可以修正 MySQL 的缺陷，并且任何人都能以任何目的来使用该数据库。MySQL 是一款可以自由使用的数据库。</p>
<a id="more"></a>

<h3 id="MySQL-的跨平台性"><a href="#MySQL-的跨平台性" class="headerlink" title="MySQL 的跨平台性"></a>MySQL 的跨平台性</h3><p>MySQL 不仅可以在 Windows 系列的操作系统上运行，还可以在 UNIX、Linux 和 Mac OS 等操作系统上运行。因为很多网站都选择 UNIX、Linux 作为网站的服务器，所以 MySQL 的跨平台性保证了其在 Web 应用方面的优势。虽然微软公司的 SQL Server 数据库是一款很优秀的商业数据库，但是其只能在 Windows 系列的操作系统上运行。因此，MySQL 数据库的跨平台性是一个很大的优势。</p>
<h3 id="价格优势"><a href="#价格优势" class="headerlink" title="价格优势"></a>价格优势</h3><p>MySQL 数据库是一个自由软件，任何人都可以从 MySQL 的官方网站上下载该软件，这些社区版本的 MySQL 都是免费试用的，即使是需要付费的附加功能，其价格也是很便宜的。相对于 Oracle、DB2 和 SQL Server 这些价格昂贵的商业软件，MySQL 具有绝对的价格优势。</p>
<h3 id="功能强大且使用方便"><a href="#功能强大且使用方便" class="headerlink" title="功能强大且使用方便"></a>功能强大且使用方便</h3><p>MySQL 是一个真正的多用户、 多线程 SQL 数据库服务器。它能够快速、有效和安全的处理大量的数据。相对于 Oracle 等数据库来说，MySQL 的使用是非常简单的。MySQL 主要目标是快速、健壮和易用。</p>
<h2 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h2><h3 id="Linux-操作系统的-MySQL-软件包一般分为以下-3-类："><a href="#Linux-操作系统的-MySQL-软件包一般分为以下-3-类：" class="headerlink" title="Linux 操作系统的 MySQL 软件包一般分为以下 3 类："></a>Linux 操作系统的 MySQL 软件包一般分为以下 3 类：</h3><ul>
<li>RPM 软件包</li>
<li>二进制软件包</li>
<li>源码包</li>
</ul>
<h4 id="RPM"><a href="#RPM" class="headerlink" title="RPM"></a>RPM</h4><p>RPM 软件包的安装和卸载都很方便，它的服务器端（Server）软件和客户端（Client）软件都需要分开下载和安装。</p>
<h4 id="二进制软件包"><a href="#二进制软件包" class="headerlink" title="二进制软件包"></a>二进制软件包</h4><p>二进制软件包是软件发布的时候已经进行过编译的软件包，安装速度比源码包快得多。</p>
<h4 id="源码包"><a href="#源码包" class="headerlink" title="源码包"></a>源码包</h4><p>源码包中是 MySQL 数据库的源代码，需要用户编译成二进制文件后才可以使用。</p>
<h3 id="Linux-CentOS卸载MySQL"><a href="#Linux-CentOS卸载MySQL" class="headerlink" title="Linux CentOS卸载MySQL"></a>Linux CentOS卸载MySQL</h3><h4 id="使用以下命令查看当前系统中是否安装-MySQL"><a href="#使用以下命令查看当前系统中是否安装-MySQL" class="headerlink" title="使用以下命令查看当前系统中是否安装 MySQL"></a>使用以下命令查看当前系统中是否安装 MySQL</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@bogon Desktop]# rpm -qa|grep -i mysql</span><br><span class="line">mysql-libs-5.1.71-1.el6.x86_64</span><br></pre></td></tr></table></figure>

<h4 id="停止-MySQL-服务，卸载-mysql-libs-5-1-71-1-el6-x86-64"><a href="#停止-MySQL-服务，卸载-mysql-libs-5-1-71-1-el6-x86-64" class="headerlink" title="停止 MySQL 服务，卸载 mysql-libs-5.1.71-1.el6.x86_64"></a>停止 MySQL 服务，卸载 mysql-libs-5.1.71-1.el6.x86_64</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">service mysql stop</span><br><span class="line">rpm -e --nodeps mysql-libs-5.1.71-1.el6.x86_64</span><br></pre></td></tr></table></figure>

<p>注意：如果提示错误，可使用命令 <code>rpm -ev mysql-libs-5.1.71-1.el6.x86_64 --nodeps</code> 或 <code>rpm -e --noscripts mysql-libs-5.1.71-1.el6.x86_64</code> 卸载 MySQL。</p>
<h4 id="查找之前老版本-MySQL-的目录，并且删除老版本的文件和库。"><a href="#查找之前老版本-MySQL-的目录，并且删除老版本的文件和库。" class="headerlink" title="查找之前老版本 MySQL 的目录，并且删除老版本的文件和库。"></a>查找之前老版本 MySQL 的目录，并且删除老版本的文件和库。</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find / -name mysql</span><br><span class="line"><span class="meta">#</span><span class="bash">显示 MySQL 目录后，可以使用以下命令删除目录</span></span><br><span class="line">rm -rf 目录名</span><br></pre></td></tr></table></figure>

<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p> Centos7 系统下使用 yum 命令安装 MySQL，需要注意的是 CentOS 7 版本中 MySQL数据库已从默认的程序列表中移除，所以在安装前我们需要先去官网下载 Yum 资源包，下载地址为：<a href="https://dev.mysql.com/downloads/repo/yum/" target="_blank" rel="noopener">https://dev.mysql.com/downloads/repo/yum/</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget http://repo.mysql.com/mysql-community-release-el7-5.noarch.rpm</span><br><span class="line">rpm -ivh mysql-community-release-el7-5.noarch.rpm</span><br><span class="line">yum update</span><br><span class="line">yum install mysql-server</span><br></pre></td></tr></table></figure>

<h4 id="权限设置："><a href="#权限设置：" class="headerlink" title="权限设置："></a>权限设置：</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chown mysql:mysql -R /var/lib/mysql</span><br></pre></td></tr></table></figure>

<h4 id="初始化-MySQL："><a href="#初始化-MySQL：" class="headerlink" title="初始化 MySQL："></a>初始化 MySQL：</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mysqld --initialize</span><br></pre></td></tr></table></figure>

<h4 id="启动-MySQL："><a href="#启动-MySQL：" class="headerlink" title="启动 MySQL："></a>启动 MySQL：</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl start mysqld</span><br></pre></td></tr></table></figure>

<h4 id="查看-MySQL-运行状态："><a href="#查看-MySQL-运行状态：" class="headerlink" title="查看 MySQL 运行状态："></a>查看 MySQL 运行状态：</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl status mysqld</span><br></pre></td></tr></table></figure>

<h4 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mysql -h 主机名 -u 用户名 -p</span><br></pre></td></tr></table></figure>

<p>​                                            Linux平台MySQL的安装目录</p>
<table>
<thead>
<tr>
<th>文件夹</th>
<th>文件夹内容</th>
</tr>
</thead>
<tbody><tr>
<td>/usr/bin</td>
<td>客户端和脚本（mysqladmin、mysqldump 等命令）</td>
</tr>
<tr>
<td>/usr/sbin</td>
<td>mysqld 服务器</td>
</tr>
<tr>
<td>/var/lib/mysql</td>
<td>日志文件、socket 文件和数据库</td>
</tr>
<tr>
<td>/usr/share/info</td>
<td>信息格式的手册</td>
</tr>
<tr>
<td>/usr/share/man</td>
<td>UNIX 帮助页</td>
</tr>
<tr>
<td>/usr/include/mysql</td>
<td>头文件</td>
</tr>
<tr>
<td>/usr/lib/mysql</td>
<td>库</td>
</tr>
<tr>
<td>/usr/share/mysql</td>
<td>错误消息、字符集、安装文件和配置文件等</td>
</tr>
<tr>
<td>/etc/rc.d/init.d/</td>
<td>启动脚本文件的 mysql 目录，可以用来启动和停止 MySQL 服务</td>
</tr>
</tbody></table>
<h3 id="MySQL-my-cnf配置文件详解"><a href="#MySQL-my-cnf配置文件详解" class="headerlink" title="MySQL my.cnf配置文件详解"></a>MySQL my.cnf配置文件详解</h3><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">[client]</span></span><br><span class="line"><span class="attr">port</span>=<span class="string">3306</span></span><br><span class="line"><span class="attr">socket</span>=<span class="string">/var/run/mysql/mysql.sock</span></span><br><span class="line"><span class="attr">[mysqldump]</span></span><br><span class="line"><span class="attr">quick</span></span><br><span class="line"><span class="attr">max_allowed_packet</span> = <span class="string">16M</span></span><br></pre></td></tr></table></figure>

<p>以上参数会被 MySQL 客户端应用读取，参数说明如下：</p>
<ul>
<li>port：MySQL 客户端连接服务器端时使用的端口号，默认为 3306</li>
<li>socket：套接字文件所在目录</li>
<li>quick：支持较大的数据库转储，导出非常巨大的表时需要此项 。</li>
<li>max_allowed_packet：服务所能处理的请求包的最大大小以及服务所能处理的最大的请求大小（当与大的BLOB字段一起工作时相当必要），每个连接独立的大小，大小动态增加。</li>
</ul>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">[mysqld]</span></span><br><span class="line"></span><br><span class="line"><span class="attr">user</span> = <span class="string">mysql</span></span><br><span class="line"><span class="attr">basedir</span> = <span class="string">/usr/local/mysql</span></span><br><span class="line"><span class="attr">datadir</span> = <span class="string">/mydata/mysql/data</span></span><br><span class="line"><span class="attr">port</span>=<span class="string">3306</span></span><br><span class="line"><span class="meta">server-id</span> = <span class="string">1</span></span><br><span class="line"><span class="attr">socket</span>=<span class="string">/var/run/mysql/mysql.sock</span></span><br></pre></td></tr></table></figure>

<p>上述参数说明如下：</p>
<ul>
<li>user：mysqld 程序在启动后将在给定 UNIX/Linux 账户下执行。mysqld 必须从 root 账户启动才能在启动后切换到另一个账户下执行。mysqld_safe 脚本将默认使用 user=mysql 选项来启动 mysqld 程序。</li>
<li>basedir：指定 MySQL 安装的绝对路径；</li>
<li>datadir：指定 MySQL 数据存放的绝对路径；</li>
<li>port：服务端口号，默认为 3306</li>
<li>server-id：MySQL 服务的唯一编号，每个 MySQL 服务的 id 需唯一。</li>
<li>socket：socket 文件所在目录</li>
</ul>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">character-set-server</span> = <span class="string">utf8mb4</span></span><br><span class="line"><span class="meta">collation-server</span> = <span class="string">utf8mb4_general_ci</span></span><br><span class="line"><span class="attr">init_connect</span>=<span class="string">'SET NAMES utf8mb4'</span></span><br><span class="line"><span class="attr">lower_case_table_names</span> = <span class="string">1</span></span><br><span class="line"></span><br><span class="line"><span class="attr">key_buffer_size</span>=<span class="string">16M</span></span><br><span class="line"><span class="attr">max_allowed_packet</span>=<span class="string">8M</span></span><br><span class="line"><span class="attr">no-auto-rehash</span></span><br><span class="line"><span class="attr">sql_mode</span>=<span class="string">TRADITIONAL</span></span><br></pre></td></tr></table></figure>

<ul>
<li>character-set-server：数据库默认字符集，主流字符集支持一些特殊表情符号（特殊表情符占用 4 个字节）</li>
<li>collation-server：数据库字符集对应一些排序等规则，注意要和 character-set-server 对应</li>
<li>init_connect：设置 client 连接 mysql 时的字符集，防止乱码</li>
<li>lower_case_table_names：是否对 sql 语句大小写敏感，1 表示不敏感</li>
<li>key_buffer_size：用于指定索引缓冲区的大小</li>
<li>max_allowed_packet：设置一次消息传输的最大值</li>
<li>no-auto-rehash：仅仅允许使用键值的 UPDATES 和 DELETES</li>
<li>sql_mode：表示 SQL 模式的参数，通过这个参数可以设置检验 SQL 语句的严格程度</li>
</ul>
<h3 id="MySQL配置文件（my-ini）详解"><a href="#MySQL配置文件（my-ini）详解" class="headerlink" title="MySQL配置文件（my.ini）详解"></a>MySQL配置文件（my.ini）详解</h3><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">[client]</span></span><br><span class="line"><span class="attr">port</span>=<span class="string">3306</span></span><br><span class="line"><span class="attr">[mysql]</span></span><br><span class="line"><span class="meta">default-character-set</span>=<span class="string">gbk</span></span><br></pre></td></tr></table></figure>

<p>上面显示的是客户端的参数，[client] 和 [mysql] 都是客户端，参数说明如下：</p>
<ul>
<li>port：表示 MySQL 客户端连接服务器端时使用的端口号，默认的端口号为 3306。如果需要更改端口号的话，可以直接在这里修改。</li>
<li>default-character-set：表示 MySQL 客户端默认的字符集。</li>
</ul>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">[mysqld]</span></span><br><span class="line"></span><br><span class="line"><span class="attr">port</span>=<span class="string">3306</span></span><br><span class="line"><span class="attr">basedir</span>=<span class="string">C:/Program Files/MySQL/MySQL Server 5.7/</span></span><br><span class="line"><span class="attr">datadir</span>=<span class="string">C:/ProgramData/MySQL/MySQL Server 5.7/Data</span></span><br><span class="line"></span><br><span class="line"><span class="meta">character-set-server</span>=<span class="string">gb2312</span></span><br><span class="line"><span class="meta">default-storage-engine</span>=<span class="string">INNODB</span></span><br><span class="line"><span class="meta">sql-mode</span>=<span class="string">"STRICT_TRANS_TABLES,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION"</span></span><br><span class="line"></span><br><span class="line"><span class="attr">max_connections</span>=<span class="string">100</span></span><br><span class="line"><span class="attr">query_cache_size</span>=<span class="string">0</span></span><br><span class="line"><span class="attr">table_cache</span>=<span class="string">256</span></span><br><span class="line"><span class="attr">tmp_table_size</span>=<span class="string">35M</span></span><br><span class="line"><span class="attr">thread_cache_size</span>=<span class="string">8</span></span><br><span class="line"><span class="attr">myisam_max_sort_file_size</span>=<span class="string">100G</span></span><br><span class="line"><span class="attr">myisam_sort_buffer_size</span>=<span class="string">69M</span></span><br><span class="line"><span class="attr">key_buffer_size</span>=<span class="string">55M</span></span><br><span class="line"><span class="attr">read_buffer_size</span>=<span class="string">64K</span></span><br><span class="line"><span class="attr">read_rnd_buffer_size</span>=<span class="string">256K</span></span><br><span class="line"><span class="attr">sort_buffer_size</span>=<span class="string">256K</span></span><br></pre></td></tr></table></figure>

<p>以上是服务器的参数，参数说明如下表所示：</p>
<table>
<thead>
<tr>
<th>参数名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>port</td>
<td>表示 MySQL 服务器的端口号</td>
</tr>
<tr>
<td>basedir</td>
<td>表示 MySQL 的安装路径</td>
</tr>
<tr>
<td>datadir</td>
<td>表示 MySQL 数据文件的存储位置，也是数据表的存放位置</td>
</tr>
<tr>
<td>default-character-set</td>
<td>表示服务器端默认的字符集</td>
</tr>
<tr>
<td>default-storage-engine</td>
<td>创建数据表时，默认使用的存储引擎</td>
</tr>
<tr>
<td>sql-mode</td>
<td>表示 SQL 模式的参数，通过这个参数可以设置检验 SQL 语句的严格程度</td>
</tr>
<tr>
<td>max_connections</td>
<td>表示允许同时访问 MySQL 服务器的最大连接数。其中一个连接是保留的，留给管理员专用的</td>
</tr>
<tr>
<td>query_cache_size</td>
<td>表示查询时的缓存大小，缓存中可以存储以前通过 SELECT 语句查询过的信息，再次查询时就可以直接从缓存中拿出信息，可以改善查询效率</td>
</tr>
<tr>
<td>table_open_cache</td>
<td>表示所有进程打开表的总数</td>
</tr>
<tr>
<td>tmp_table_size</td>
<td>表示内存中每个临时表允许的最大大小</td>
</tr>
<tr>
<td>thread_cache_size</td>
<td>表示缓存的最大线程数</td>
</tr>
<tr>
<td>myisam_max_sort_file_size</td>
<td>表示 MySQL 重建索引时所允许的最大临时文件的大小</td>
</tr>
<tr>
<td>myisam_sort_buffer_size</td>
<td>表示重建索引时的缓存大小</td>
</tr>
<tr>
<td>key_buffer_size</td>
<td>表示关键词的缓存大小</td>
</tr>
<tr>
<td>read_buffer_size</td>
<td>表示 MyISAM 表全表扫描的缓存大小</td>
</tr>
<tr>
<td>read_rnd_buffer_size</td>
<td>表示将排序好的数据存入该缓存中</td>
</tr>
<tr>
<td>sort_buffer_size</td>
<td>表示用于排序的缓存大小</td>
</tr>
</tbody></table>
 <figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">innodb_additional_mem_pool_size</span>=<span class="string">3M</span></span><br><span class="line"><span class="attr">innodb_flush_log_at_trx_commit</span>=<span class="string">1</span></span><br><span class="line"><span class="attr">innodb_log_buffer_size</span>=<span class="string">2M</span></span><br><span class="line"><span class="attr">innodb_buffer_pool_size</span>=<span class="string">107M</span></span><br><span class="line"><span class="attr">innodb_log_file_size</span>=<span class="string">54M</span></span><br><span class="line"><span class="attr">innodb_thread_concurrency</span>=<span class="string">18</span></span><br></pre></td></tr></table></figure>

<p>以上是 InnoDB 存储引擎使用的参数，参数说明如下：</p>
<ul>
<li>innodb_additional_mem_pool_size：表示附加的内存池，用来存储 InnoDB 表的内容。</li>
<li>innodb_flush_log_at_trx_commit：是设置提交日志的时机，若设置为 1，InnoDB 会在每次提交后将事务日志写到磁盘上。</li>
<li>innodb_log_buffer_size：表示用来存储日志数据的缓存区的大小。</li>
<li>innodb_buffer_pool_size：表示缓存的大小，InnoDB 使用一个缓冲池类保存索引和原始数据。</li>
<li>innodb_log_file_size：表示日志文件的大小。</li>
<li>innodb_thread_concurrency：表示在 InnoDB 存储引擎允许的线程最大数。</li>
</ul>
<p>注意：每次修改 my.ini 文件中的参数后，必须重新启动 MySQL 服务才会有效。</p>
<h2 id="SQL是什么？它能做什么？"><a href="#SQL是什么？它能做什么？" class="headerlink" title="SQL是什么？它能做什么？"></a>SQL是什么？它能做什么？</h2><p><strong>SQL 是一种数据库查询和程序设计语言，用于存取数据以及查询、更新和管理关系数据库系统。</strong></p>
<p>SQL 具有如下优点。</p>
<ol>
<li>一体化：SQL 集数据定义、数据操作和数据控制于一体，可以完成数据库中的全部工作。</li>
<li>使用方式灵活：SQL 具有两种使用方式，可以直接以命令方式交互使用；也可以嵌入使用，嵌入C、C++、Fortran、COBOL、Java 等语言中使用。</li>
<li>非过程化：只提操作要求，不必描述操作步骤，也不需要导航。使用时只需要告诉计算机“做什么”，而不需要告诉它“怎么做”，存储路径的选择和操作的执行由数据库管理系统自动完成。</li>
<li>语言简洁、语法简单：该语言的语句都是由描述性很强的英语单词组成，而且这些单词的数目不多。</li>
</ol>
<h3 id="SQL-包含以下-4-部分："><a href="#SQL-包含以下-4-部分：" class="headerlink" title="SQL 包含以下 4 部分："></a>SQL 包含以下 4 部分：</h3><h4 id="数据定义语言（Data-Definition-Language，DDL）"><a href="#数据定义语言（Data-Definition-Language，DDL）" class="headerlink" title="数据定义语言（Data Definition Language，DDL）"></a>数据定义语言（Data Definition Language，DDL）</h4><p>用来创建或删除数据库以及表等对象，主要包含以下几种命令：</p>
<ul>
<li>DROP：删除数据库和表等对象</li>
<li>CREATE：创建数据库和表等对象</li>
<li>ALTER：修改数据库和表等对象的结构</li>
</ul>
<h4 id="数据操作语言（Data-Manipulation-Language，DML）"><a href="#数据操作语言（Data-Manipulation-Language，DML）" class="headerlink" title="数据操作语言（Data Manipulation Language，DML）"></a>数据操作语言（Data Manipulation Language，DML）</h4><p>用来变更表中的记录，主要包含以下几种命令：</p>
<ul>
<li>SELECT：查询表中的数据</li>
<li>INSERT：向表中插入新数据</li>
<li>UPDATE：更新表中的数据</li>
<li>DELETE：删除表中的数据</li>
</ul>
<h4 id="数据查询语言（Data-Query-Language，DQL）"><a href="#数据查询语言（Data-Query-Language，DQL）" class="headerlink" title="数据查询语言（Data Query Language，DQL）"></a>数据查询语言（Data Query Language，DQL）</h4><p>用来查询表中的记录，主要包含 SELECT 命令，来查询表中的数据。</p>
<h4 id="数据控制语言（Data-Control-Language，DCL）"><a href="#数据控制语言（Data-Control-Language，DCL）" class="headerlink" title="数据控制语言（Data Control Language，DCL）"></a>数据控制语言（Data Control Language，DCL）</h4><p>用来确认或者取消对数据库中的数据进行的变更。除此之外，还可以对数据库中的用户设定权限。主要包含以下几种命令：</p>
<ul>
<li>GRANT：赋予用户操作权限</li>
<li>REVOKE：取消用户的操作权限</li>
<li>COMMIT：确认对数据库中的数据进行的变更</li>
<li>ROLLBACK：取消对数据库中的数据进行的变更</li>
</ul>
<h2 id="MySQL数据类型"><a href="#MySQL数据类型" class="headerlink" title="MySQL数据类型"></a>MySQL数据类型</h2><p>数据类型（data_type）是指系统中所允许的数据的类型。</p>
<h3 id="数值类型"><a href="#数值类型" class="headerlink" title="数值类型"></a>数值类型</h3><p>整数类型包括 TINYINT、SMALLINT、MEDIUMINT、INT、BIGINT，浮点数类型包括 FLOAT 和 DOUBLE，定点数类型为 DECIMAL。</p>
<table>
<thead>
<tr>
<th>类型名称</th>
<th>说明</th>
<th>存储需求</th>
<th>字节</th>
</tr>
</thead>
<tbody><tr>
<td>TINYINT</td>
<td>-128〜127</td>
<td>0 〜255</td>
<td>1</td>
</tr>
<tr>
<td>SMALLINT</td>
<td>-32768〜32767</td>
<td>0〜65535</td>
<td>2</td>
</tr>
<tr>
<td>MEDIUMINT</td>
<td>-8388608〜8388607</td>
<td>0〜16777215</td>
<td>3</td>
</tr>
<tr>
<td>INT (INTEGER)</td>
<td>-2147483648〜2147483647</td>
<td>0〜4294967295</td>
<td>4</td>
</tr>
<tr>
<td>BIGINT</td>
<td>-9223372036854775808〜9223372036854775807</td>
<td>0〜18446744073709551615</td>
<td>8</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>类型名称</th>
<th>说明</th>
<th>存储需求</th>
</tr>
</thead>
<tbody><tr>
<td>FLOAT</td>
<td>单精度浮点数</td>
<td>4 个字节</td>
</tr>
<tr>
<td>DOUBLE</td>
<td>双精度浮点数</td>
<td>8 个字节</td>
</tr>
<tr>
<td>DECIMAL (M, D)，DEC</td>
<td>压缩的“严格”定点数</td>
<td>M+2 个字节</td>
</tr>
</tbody></table>
<p>DECIMAL 类型不同于 FLOAT 和 DOUBLE。DOUBLE 实际上是以字符串的形式存放的，DECIMAL 可能的最大取值范围与 DOUBLE 相同，但是有效的取值范围由 M 和 D 决定。如果改变 M 而固定 D，则取值范围将随 M 的变大而变大。</p>
<h3 id="日期-时间类型"><a href="#日期-时间类型" class="headerlink" title="日期/时间类型"></a>日期/时间类型</h3><table>
<thead>
<tr>
<th>类型名称</th>
<th>日期格式</th>
<th>日期范围</th>
<th>存储需求</th>
</tr>
</thead>
<tbody><tr>
<td>YEAR</td>
<td>YYYY</td>
<td>1901 ~ 2155</td>
<td>1 个字节</td>
</tr>
<tr>
<td>TIME</td>
<td>HH:MM:SS</td>
<td>-838:59:59 ~ 838:59:59</td>
<td>3 个字节</td>
</tr>
<tr>
<td>DATE</td>
<td>YYYY-MM-DD</td>
<td>1000-01-01 ~ 9999-12-3</td>
<td>3 个字节</td>
</tr>
<tr>
<td>DATETIME</td>
<td>YYYY-MM-DD HH:MM:SS</td>
<td>1000-01-01 00:00:00 ~ 9999-12-31 23:59:59</td>
<td>8 个字节</td>
</tr>
<tr>
<td>TIMESTAMP</td>
<td>YYYY-MM-DD HH:MM:SS</td>
<td>1980-01-01 00:00:01 UTC ~ 2040-01-19 03:14:07 UTC</td>
<td>4 个字节</td>
</tr>
</tbody></table>
<h3 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h3><table>
<thead>
<tr>
<th>类型名称</th>
<th>说明</th>
<th>存储需求</th>
</tr>
</thead>
<tbody><tr>
<td>CHAR(M)</td>
<td>固定长度非二进制字符串</td>
<td>M 字节，1&lt;=M&lt;=255</td>
</tr>
<tr>
<td>VARCHAR(M)</td>
<td>变长非二进制字符串</td>
<td>L+1字节，在此，L&lt; = M和 1&lt;=M&lt;=255</td>
</tr>
<tr>
<td>TINYTEXT</td>
<td>非常小的非二进制字符串</td>
<td>L+1字节，在此，L&lt;2^8</td>
</tr>
<tr>
<td>TEXT</td>
<td>小的非二进制字符串</td>
<td>L+2字节，在此，L&lt;2^16</td>
</tr>
<tr>
<td>MEDIUMTEXT</td>
<td>中等大小的非二进制字符串</td>
<td>L+3字节，在此，L&lt;2^24</td>
</tr>
<tr>
<td>LONGTEXT</td>
<td>大的非二进制字符串</td>
<td>L+4字节，在此，L&lt;2^32</td>
</tr>
<tr>
<td>ENUM</td>
<td>枚举类型，只能有一个枚举字符串值</td>
<td>1或2个字节，取决于枚举值的数目 (最大值为65535)</td>
</tr>
<tr>
<td>SET</td>
<td>一个设置，字符串对象可以有零个或 多个SET成员</td>
<td>1、2、3、4或8个字节，取决于集合 成员的数量（最多64个成员）</td>
</tr>
</tbody></table>
<h3 id="二进制类型"><a href="#二进制类型" class="headerlink" title="二进制类型"></a>二进制类型</h3><table>
<thead>
<tr>
<th>类型名称</th>
<th>说明</th>
<th>存储需求</th>
</tr>
</thead>
<tbody><tr>
<td>BIT(M)</td>
<td>位字段类型</td>
<td>大约 (M+7)/8 字节</td>
</tr>
<tr>
<td>BINARY(M)</td>
<td>固定长度二进制字符串</td>
<td>M 字节</td>
</tr>
<tr>
<td>VARBINARY (M)</td>
<td>可变长度二进制字符串</td>
<td>M+1 字节</td>
</tr>
<tr>
<td>TINYBLOB (M)</td>
<td>非常小的BLOB</td>
<td>L+1 字节，在此，L&lt;2^8</td>
</tr>
<tr>
<td>BLOB (M)</td>
<td>小 BLOB</td>
<td>L+2 字节，在此，L&lt;2^16</td>
</tr>
<tr>
<td>MEDIUMBLOB (M)</td>
<td>中等大小的BLOB</td>
<td>L+3 字节，在此，L&lt;2^24</td>
</tr>
<tr>
<td>LONGBLOB (M)</td>
<td>非常大的BLOB</td>
<td>L+4 字节，在此，L&lt;2^32</td>
</tr>
</tbody></table>
<h2 id="MySQL存储引擎有哪些？"><a href="#MySQL存储引擎有哪些？" class="headerlink" title="MySQL存储引擎有哪些？"></a>MySQL存储引擎有哪些？</h2><p>数据库存储引擎是数据库底层软件组件，数据库管理系统使用数据引擎进行创建、查询、更新和删除数据操作。</p>
<table>
<thead>
<tr>
<th>存储引擎</th>
<th>文件</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>ARCHIVE</td>
<td>.ARZ .frm</td>
<td>用于数据存档的引擎，数据被插入后就不能在修改了，且不支持索引。</td>
</tr>
<tr>
<td>CSV</td>
<td>.CSM</td>
<td>在存储数据时，会以逗号作为数据项之间的分隔符。</td>
</tr>
<tr>
<td>BLACKHOLE</td>
<td>.frm</td>
<td>会丢弃写操作，该操作会返回空内容。</td>
</tr>
<tr>
<td>FEDERATED</td>
<td></td>
<td>将数据存储在远程数据库中，用来访问远程表的存储引擎。</td>
</tr>
<tr>
<td>InnoDB</td>
<td>.frm<br />.ibd</td>
<td>具备外键支持功能的事务处理引擎</td>
</tr>
<tr>
<td>MEMORY</td>
<td>.frm</td>
<td>置于内存的表</td>
</tr>
<tr>
<td>MERGE</td>
<td>.frm<br />.mrg</td>
<td>用来管理由多个 MyISAM 表构成的表集合</td>
</tr>
<tr>
<td>MyISAM</td>
<td>.frm<br />.MYD<br />.MYI</td>
<td>主要的非事务处理存储引擎</td>
</tr>
<tr>
<td>NDB</td>
<td></td>
<td>MySQL 集群专用存储引擎</td>
</tr>
</tbody></table>
<h3 id="MySQL存储引擎特性汇总和对比"><a href="#MySQL存储引擎特性汇总和对比" class="headerlink" title="MySQL存储引擎特性汇总和对比"></a>MySQL存储引擎特性汇总和对比</h3><table>
<thead>
<tr>
<th>特性</th>
<th>MyISAM</th>
<th>InnoDB</th>
<th>MEMORY</th>
</tr>
</thead>
<tbody><tr>
<td>存储限制</td>
<td>有</td>
<td>支持</td>
<td>有</td>
</tr>
<tr>
<td>事务安全</td>
<td>不支持</td>
<td>支持</td>
<td>不支持</td>
</tr>
<tr>
<td>锁机制</td>
<td>表锁</td>
<td>行锁</td>
<td>表锁</td>
</tr>
<tr>
<td>B树索引</td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
</tr>
<tr>
<td>哈希索引</td>
<td>不支持</td>
<td>不支持</td>
<td>支持</td>
</tr>
<tr>
<td>全文索引</td>
<td>支持</td>
<td>不支持</td>
<td>不支持</td>
</tr>
<tr>
<td>集群索引</td>
<td>不支持</td>
<td>支持</td>
<td>不支持</td>
</tr>
<tr>
<td>数据缓存</td>
<td></td>
<td>支持</td>
<td>支持</td>
</tr>
<tr>
<td>索引缓存</td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
</tr>
<tr>
<td>数据可压缩</td>
<td>支持</td>
<td>不支持</td>
<td>不支持</td>
</tr>
<tr>
<td>空间使用</td>
<td>低</td>
<td>高</td>
<td>N/A</td>
</tr>
<tr>
<td>内存使用</td>
<td>低</td>
<td>高</td>
<td>中等</td>
</tr>
<tr>
<td>批量插入速度</td>
<td>高</td>
<td>低</td>
<td>高</td>
</tr>
<tr>
<td>支持外键</td>
<td>不支持</td>
<td>支持</td>
<td>不支持</td>
</tr>
</tbody></table>
<h2 id="MySQL索引（Index）"><a href="#MySQL索引（Index）" class="headerlink" title="MySQL索引（Index）"></a>MySQL索引（Index）</h2><p>索引是一种特殊的数据库结构，由数据表中的一列或多列组合而成，可以用来快速查询数据表中有某一特定值的记录。</p>
<p>通过索引，查询数据时不用读完记录的所有信息，而只是查询索引列。否则，数据库系统将读取每条记录的所有信息进行匹配。</p>
<h3 id="为什么要使用索引"><a href="#为什么要使用索引" class="headerlink" title="为什么要使用索引"></a>为什么要使用索引</h3><p>索引就是根据表中的一列或若干列按照一定顺序建立的列值与记录行之间的对应关系表，实质上是一张描述索引列的列值与原表中记录行之间一 一对应关系的有序表。</p>
<p>索引是 MySQL 中十分重要的数据库对象，是数据库性能调优技术的基础，常用于实现数据的快速检索。</p>
<p>在 MySQL 中，通常有以下两种方式访问数据库表的行数据：</p>
<h4 id="顺序访问"><a href="#顺序访问" class="headerlink" title="顺序访问"></a>顺序访问</h4><p>顺序访问是在表中实行全表扫描，从头到尾逐行遍历，直到在无序的行数据中找到符合条件的目标数据。</p>
<p>顺序访问实现比较简单，但是当表中有大量数据的时候，效率非常低下。例如，在几千万条数据中查找少量的数据时，使用顺序访问方式将会遍历所有的数据，花费大量的时间，显然会影响数据库的处理性能。</p>
<h4 id="索引访问"><a href="#索引访问" class="headerlink" title="索引访问"></a>索引访问</h4><p>索引访问是通过遍历索引来直接访问表中记录行的方式。</p>
<p>使用这种方式的前提是对表建立一个索引，在列上创建了索引之后，查找数据时可以直接根据该列上的索引找到对应记录行的位置，从而快捷地查找到数据。索引存储了指定列数据值的指针，根据指定的排序顺序对这些指针排序。</p>
<h3 id="索引的优缺点"><a href="#索引的优缺点" class="headerlink" title="索引的优缺点"></a>索引的优缺点</h3><p>索引有其明显的优势，也有其不可避免的缺点。</p>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p>索引的优点如下：</p>
<ul>
<li>通过创建唯一索引可以保证数据库表中每一行数据的唯一性。</li>
<li>可以给所有的 MySQL 列类型设置索引。</li>
<li>可以大大加快数据的查询速度，这是使用索引最主要的原因。</li>
<li>在实现数据的参考完整性方面可以加速表与表之间的连接。</li>
<li>在使用分组和排序子句进行数据查询时也可以显著减少查询中分组和排序的时间</li>
</ul>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>增加索引也有许多不利的方面，主要如下：</p>
<ul>
<li>创建和维护索引组要耗费时间，并且随着数据量的增加所耗费的时间也会增加。</li>
<li>索引需要占磁盘空间，除了数据表占数据空间以外，每一个索引还要占一定的物理空间。如果有大量的索引，索引文件可能比数据文件更快达到最大文件尺寸。</li>
<li>当对表中的数据进行增加、删除和修改的时候，索引也要动态维护，这样就降低了数据的维护速度。</li>
</ul>
<p>使用索引时，需要综合考虑索引的优点和缺点。</p>
<p>索引可以提高查询速度，但是会影响插入记录的速度。因为，向有索引的表中插入记录时，数据库系统会按照索引进行排序，这样就降低了插入记录的速度，插入大量记录时的速度影响会更加明显。这种情况下，最好的办法是先删除表中的索引，然后插入数据，插入完成后，再创建索引。</p>
<h3 id="索引类型详解"><a href="#索引类型详解" class="headerlink" title="索引类型详解"></a>索引类型详解</h3><p>索引的类型和存储引擎有关，每种存储引擎所支持的索引类型不一定完全相同。MySQL 索引可以从存储方式、逻辑角度和实际使用的角度来进行分类。</p>
<h4 id="存储方式区分"><a href="#存储方式区分" class="headerlink" title="存储方式区分"></a>存储方式区分</h4><p>根据存储方式的不同，MySQL 中常用的索引在物理上分为 B-树索引和 HASH 索引两类，两种不同类型的索引各有其不同的适用范围。</p>
<h5 id="B-树索引"><a href="#B-树索引" class="headerlink" title="B-树索引"></a>B-树索引</h5><p>B-树索引又称为 BTREE 索引，目前大部分的索引都是采用 B-树索引来存储的。</p>
<p>B-树索引是一个典型的数据结构，其包含的组件主要有以下几个：</p>
<ul>
<li>叶子节点：包含的条目直接指向表里的数据行。叶子节点之间彼此相连，一个叶子节点有一个指向下一个叶子节点的指针。</li>
<li>分支节点：包含的条目指向索引里其他的分支节点或者叶子节点。</li>
<li>根节点：一个 B-树索引只有一个根节点，实际上就是位于树的最顶端的分支节点。</li>
</ul>
<p>基于这种树形数据结构，表中的每一行都会在索引上有一个对应值。因此，在表中进行数据查询时，可以根据索引值一步一步定位到数据所在的行。</p>
<p>B-树索引可以进行全键值、键值范围和键值前缀查询，也可以对查询结果进行 ORDER BY 排序。但 B-树索引必须遵循左边前缀原则，要考虑以下几点约束：</p>
<ul>
<li>查询必须从索引的最左边的列开始。</li>
<li>查询不能跳过某一索引列，必须按照从左到右的顺序进行匹配。</li>
<li>存储引擎不能使用索引中范围条件右边的列。</li>
</ul>
<h5 id="哈希索引"><a href="#哈希索引" class="headerlink" title="哈希索引"></a>哈希索引</h5><p>哈希（Hash）一般翻译为“散列”，也有直接音译成“哈希”的，就是把任意长度的输入（又叫作预映射，pre-image）通过散列算法变换成固定长度的输出，该输出就是散列值。</p>
<p>哈希索引也称为散列索引或 HASH 索引。MySQL 目前仅有 MEMORY 存储引擎和 HEAP 存储引擎支持这类索引。其中，MEMORY 存储引擎可以支持 B-树索引和 HASH 索引，且将 HASH 当成默认索引。</p>
<p>HASH 索引不是基于树形的数据结构查找数据，而是根据索引列对应的哈希值的方法获取表的记录行。哈希索引的最大特点是访问速度快，但也存在下面的一些缺点：</p>
<ul>
<li>MySQL 需要读取表中索引列的值来参与散列计算，散列计算是一个比较耗时的操作。也就是说，相对于 B-树索引来说，建立哈希索引会耗费更多的时间。</li>
<li>不能使用 HASH 索引排序。</li>
<li>HASH 索引只支持等值比较，如“=”“IN()”或“&lt;=&gt;”。</li>
<li>HASH 索引不支持键的部分匹配，因为在计算 HASH 值的时候是通过整个索引值来计算的。</li>
</ul>
<h4 id="逻辑区分"><a href="#逻辑区分" class="headerlink" title="逻辑区分"></a>逻辑区分</h4><h5 id="普通索引"><a href="#普通索引" class="headerlink" title="普通索引"></a>普通索引</h5><p>普通索引是 MySQL 中最基本的索引类型，它没有任何限制，唯一任务就是加快系统对数据的访问速度。</p>
<p>普通索引允许在定义索引的列中插入重复值和空值。</p>
<p>创建普通索引时，通常使用的关键字是 INDEX 或 KEY。</p>
<h5 id="唯一索引"><a href="#唯一索引" class="headerlink" title="唯一索引"></a>唯一索引</h5><p>唯一索引与普通索引类似，不同的是创建唯一性索引的目的不是为了提高访问速度，而是为了避免数据出现重复。</p>
<p>唯一索引列的值必须唯一，允许有空值。如果是组合索引，则列值的组合必须唯一。</p>
<p>创建唯一索引通常使用 UNIQUE 关键字。</p>
<h5 id="主键索引"><a href="#主键索引" class="headerlink" title="主键索引"></a>主键索引</h5><p>主键索引就是专门为主键字段创建的索引，也属于索引的一种。</p>
<p>主键索引是一种特殊的唯一索引，不允许值重复或者值为空。</p>
<p>创建主键索引通常使用 PRIMARY KEY 关键字。不能使用 CREATE INDEX 语句创建主键索引。</p>
<h5 id="空间索引"><a href="#空间索引" class="headerlink" title="空间索引"></a>空间索引</h5><p>空间索引是对空间数据类型的字段建立的索引，使用 SPATIAL 关键字进行扩展。</p>
<p>创建空间索引的列必须将其声明为 NOT NULL，空间索引只能在存储引擎为 MyISAM 的表中创建。</p>
<p>空间索引主要用于地理空间数据类型 GEOMETRY。</p>
<h5 id="全文索引"><a href="#全文索引" class="headerlink" title="全文索引"></a>全文索引</h5><p>全文索引主要用来查找文本中的关键字，只能在 CHAR、VARCHAR 或 TEXT 类型的列上创建。在 MySQL 中只有 MyISAM 存储引擎支持全文索引。</p>
<p>全文索引允许在索引列中插入重复值和空值。</p>
<p>不过对于大容量的数据表，生成全文索引非常消耗时间和硬盘空间。</p>
<p>创建全文索引使用 FULLTEXT 关键字。</p>
<h4 id="实际使用区分"><a href="#实际使用区分" class="headerlink" title="实际使用区分"></a>实际使用区分</h4><h5 id="单列索引"><a href="#单列索引" class="headerlink" title="单列索引"></a>单列索引</h5><p>单列索引就是索引只包含原表的一个列。在表中的单个字段上创建索引，单列索引只根据该字段进行索引。</p>
<p>单列索引可以是普通索引，也可以是唯一性索引，还可以是全文索引。只要保证该索引只对应一个字段即可</p>
<h5 id="多列索引"><a href="#多列索引" class="headerlink" title="多列索引"></a>多列索引</h5><p>组合索引也称为复合索引或多列索引。相对于单列索引来说，组合索引是将原表的多个列共同组成一个索引。多列索引是在表的多个字段上创建一个索引。该索引指向创建时对应的多个字段，可以通过这几个字段进行查询。但是，只有查询条件中使用了这些字段中第一个字段时，索引才会被使用。</p>
<p><code>提示：一个表可以有多个单列索引，但这些索引不是组合索引。一个组合索引实质上为表的查询提供了多个索引，以此来加快查询速度。比如，在一个表中创建了一个组合索引(c1，c2，c3)，在实际查询中，系统用来实际加速的索引有三个：单个索引(c1)、双列索引(c1，c2)和多列索引(c1，c2，c3)。</code></p>
<h2 id="数据库事务"><a href="#数据库事务" class="headerlink" title="数据库事务"></a>数据库事务</h2><p>数据库的<strong>事务（Transaction）</strong>是一种机制、一个操作序列，包含了一组数据库操作命令。事务把所有的命令作为一个整体一起向系统提交或撤销操作请求，即这一组数据库命令要么都执行，要么都不执行，因此事务是一个不可分割的工作逻辑单元。</p>
<h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><p>事务具有 4 个特性，即原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）和持久性（Durability），这 4 个特性通常简称为 ACID。</p>
<h4 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h4><p>事务是一个完整的操作。事务的各元素是不可分的（原子的）。事务中的所有元素必须作为一个整体提交或回滚。如果事务中的任何元素失败，则整个事务将失败。</p>
<h4 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h4><p>当事务完成时，数据必须处于一致状态。也就是说，在事务开始之前，数据库中存储的数据处于一致状态。在正在进行的事务中. 数据可能处于不一致的状态，如数据可能有部分被修改。然而，当事务成功完成时，数据必须再次回到已知的一致状态。通过事务对数据所做的修改不能损坏数据，或者说事务不能使数据存储处于不稳定的状态。</p>
<h4 id="隔离性"><a href="#隔离性" class="headerlink" title="隔离性"></a>隔离性</h4><p>对数据进行修改的所有并发事务是彼此隔离的，这表明事务必须是独立的，它不应以任何方式依赖于或影响其他事务。修改数据的事务可以在另一个使用相同数据的事务开始之前访问这些数据，或者在另一个使用相同数据的事务结束之后访问这些数据。</p>
<h4 id="持久性"><a href="#持久性" class="headerlink" title="持久性"></a>持久性</h4><p>事务的持久性指不管系统是否发生了故障，事务处理的结果都是永久的。</p>
<p>一个事务成功完成之后，它对数据库所作的改变是永久性的，即使系统出现故障也是如此。也就是说，一旦事务被提交，事务对数据所做的任何变动都会被永久地保留在数据库中。</p>
<h3 id="MySQL执行事务的语法和流程"><a href="#MySQL执行事务的语法和流程" class="headerlink" title="MySQL执行事务的语法和流程"></a>MySQL执行事务的语法和流程</h3><p>MySQL 提供了多种存储引擎来支持事务。支持事务的存储引擎有 InnoDB 和 BDB，其中，InnoDB 存储引擎事务主要通过 UNDO 日志和 REDO 日志实现，MyISAM 存储引擎不支持事务。</p>
<p>拓展：任何一种数据库，都会拥有各种各样的日志，用来记录数据库的运行情况、日常操作、错误信息等，MySQL 也不例外。例如，当用户 root 登录到 MySQL 服务器，就会在日志文件里记录该用户的登录时间、执行操作等。</p>
<p>为了维护 MySQL 服务器，经常需要在 MySQL 数据库中进行日志操作：</p>
<ul>
<li><strong>UNDO 日志</strong>：复制事务执行前的数据，用于在事务发生异常时回滚数据。</li>
<li><strong>REDO 日志</strong>：记录在事务执行中，每条对数据进行更新的操作，当事务提交时，该内容将被刷新到磁盘。</li>
</ul>
<p>默认设置下，每条 SQL 语句就是一个事务，即执行 SQL 语句后自动提交。为了达到将几个操作做为一个整体的目的，需要使用 BEGIN 或 START TRANSACTION 开启一个事务，或者禁止当前会话的自动提交。</p>
<h4 id="开始事务"><a href="#开始事务" class="headerlink" title="开始事务"></a>开始事务</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="comment">#或者</span></span><br><span class="line"><span class="keyword">START</span> <span class="keyword">TRANSACTION</span>;</span><br></pre></td></tr></table></figure>

<h4 id="提交事务"><a href="#提交事务" class="headerlink" title="提交事务"></a>提交事务</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure>

<p>COMMIT 表示提交事务，即提交事务的所有操作，具体地说，就是将事务中所有对数据库的更新都写到磁盘上的物理数据库中，事务正常结束。</p>
<p>提交事务，意味着将事务开始以来所执行的所有数据都修改成为数据库的永久部分，因此也标志着一个事务的结束。一旦执行了该命令，将不能回滚事务。只有在所有修改都准备好提交给数据库时，才执行这一操作。</p>
<h4 id="回滚（撤销）事务"><a href="#回滚（撤销）事务" class="headerlink" title="回滚（撤销）事务"></a>回滚（撤销）事务</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ROLLBACK</span>;</span><br></pre></td></tr></table></figure>

<p>ROLLBACK 表示撤销事务，即在事务运行的过程中发生了某种故障，事务不能继续执行，系统将事务中对数据库的所有已完成的操作全部撤销，回滚到事务开始时的状态。这里的操作指对数据库的更新操作。</p>
<p>当事务执行过程中遇到错误时，使用 ROLLBACK 语句使事务回滚到起点或指定的保持点处。同时，系统将清除自事务起点或到某个保存点所做的所有的数据修改，并且释放由事务控制的资源。因此，这条语句也标志着事务的结束。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>BEGIN 或 START TRANSACTION 语句后面的 SQL 语句对数据库数据的更新操作都将记录在事务日志中，直至遇到 ROLLBACK 语句或 COMMIT 语句。如果事务中某一操作失败且执行了 ROLLBACK 语句，那么在开启事务语句之后所有更新的数据都能回滚到事务开始前的状态。如果事务中的所有操作都全部正确完成，并且使用了 COMMIT 语句向数据库提交更新数据，则此时的数据又处在新的一致状态。</p>
<h2 id="MySQL日志"><a href="#MySQL日志" class="headerlink" title="MySQL日志"></a>MySQL日志</h2><p>任何一种数据库，都会拥有各种各样的日志，用来记录数据库的运行情况、日常操作和错误等信息，可以帮助我们诊断数据库出现的各种问题。</p>
<h3 id="错误日志（Error-Log）"><a href="#错误日志（Error-Log）" class="headerlink" title="错误日志（Error Log）"></a>错误日志（Error Log）</h3><p>该日志文件会记录 MySQL 服务器的启动、关闭和运行错误等信息。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; show variables like &#39;log_error&#39;;</span><br><span class="line">+---------------+---------------------+</span><br><span class="line">| Variable_name | Value               |</span><br><span class="line">+---------------+---------------------+</span><br><span class="line">| log_error     | &#x2F;var&#x2F;log&#x2F;mysqld.log |</span><br><span class="line">+---------------+---------------------+</span><br><span class="line">1 row in set (0.03 sec)</span><br></pre></td></tr></table></figure>

<h3 id="慢查询日志（Slow-Query-Log）"><a href="#慢查询日志（Slow-Query-Log）" class="headerlink" title="慢查询日志（Slow Query Log）"></a>慢查询日志（Slow Query Log）</h3><p>记录执行事件超过指定时间的操作，通过工具分析慢查询日志可以定位 MySQL 服务器性能瓶颈所在。</p>
<p>慢查询日志用来记录响应时间超过阈值的SQL语句，所以我们可以设置一个阈值，将运行时间超过该值的所有SQL语句都记录到慢查询日志文件中。该阈值可以通过参数 <code>long_query_time</code> 来设置，默认为10秒。</p>
<h4 id="启动慢查询日志"><a href="#启动慢查询日志" class="headerlink" title="启动慢查询日志"></a>启动慢查询日志</h4><p><strong>默认情况下，MySQL数据库并不启动慢查询日志，需要手动将这个参数设为ON，然后启动</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; show variables like &quot;%slow%&quot;;</span><br><span class="line">+---------------------------+-------------------------------------------------+</span><br><span class="line">| Variable_name             | Value                                           |</span><br><span class="line">+---------------------------+-------------------------------------------------+</span><br><span class="line">| log_slow_admin_statements | OFF                                             |</span><br><span class="line">| log_slow_slave_statements | OFF                                             |</span><br><span class="line">| slow_launch_time          | 2                                               |</span><br><span class="line">| slow_query_log            | OFF                                             |</span><br><span class="line">| slow_query_log_file       | &#x2F;var&#x2F;lib&#x2F;mysql&#x2F;iz2zeaf3cg1099kiidi06mz-slow.log |</span><br><span class="line">+---------------------------+-------------------------------------------------+</span><br><span class="line">5 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; set global slow_query_log&#x3D;&#39;ON&#39;;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mysql&gt; show variables like &quot;slow_query_log&quot;;</span><br><span class="line">+---------------------------+-------------------------------------------------+</span><br><span class="line">| Variable_name             | Value                                           |</span><br><span class="line">+---------------------------+-------------------------------------------------+                                        |</span><br><span class="line">| slow_query_log            | ON                                              |</span><br><span class="line">| slow_query_log_file       | &#x2F;var&#x2F;lib&#x2F;mysql&#x2F;iz2zeaf3cg1099kiidi06mz-slow.log |</span><br><span class="line">+---------------------------+-------------------------------------------------+</span><br><span class="line">2   rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p><strong>但是使用 <code>set global slow_query_log=&#39;ON&#39;</code> 开启慢查询日志，只是对当前数据库有效，如果MySQL数据库重启后就会失效。所以如果要永久生效，就要修改配置文件 <code>my.cnf</code> (其他系统变量也是如此)</strong>，如下：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">[mysqld]</span></span><br><span class="line"><span class="attr">slow_query_log</span>=<span class="string">1</span></span><br></pre></td></tr></table></figure>

<p>然后重启MySQL就可以让慢查询日志记录开启了,至于日志文件的路径就是上面<code>slow_query_log_file</code>对应的路径。</p>
<h4 id="设置阈值"><a href="#设置阈值" class="headerlink" title="设置阈值"></a>设置阈值</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; show variables like &#39;long_query_time&#39;;</span><br><span class="line">+-----------------+-----------+</span><br><span class="line">| Variable_name   | Value     |</span><br><span class="line">+-----------------+-----------+</span><br><span class="line">| long_query_time | 10.000000 |</span><br><span class="line">+-----------------+-----------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; set global long_query_time&#x3D;0.05;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>设置<code>long_query_time</code>这个阈值之后，MySQL数据库会记录运行时间超过该值的所有SQL语句，但对于运行时间正好等于 <code>long_query_time</code> 的情况，并不会被记录下。而设置 <code>long_query_time</code>为0来捕获所有的查询</p>
<h4 id="参数log-queries-not-using-indexes"><a href="#参数log-queries-not-using-indexes" class="headerlink" title="参数log_queries_not_using_indexes"></a>参数log_queries_not_using_indexes</h4><p><strong>另一个和慢查询日志有关的参数是 <code>log_queries_not_using_indexes</code></strong>, 如果运行的SQL语句没有使用索引，则MySQL数据库同样会将这条SQL语句记录到慢查询日志文件。首先确认打开了log_queries_not_using_indexes;</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; show variables like &#39;log_queries_not_using_indexes&#39;;</span><br><span class="line">+-------------------------------+-------+</span><br><span class="line">| Variable_name                 | Value |</span><br><span class="line">+-------------------------------+-------+</span><br><span class="line">| log_queries_not_using_indexes | ON    |</span><br><span class="line">+-------------------------------+-------+</span><br><span class="line">1 row in set (0.12 sec)</span><br></pre></td></tr></table></figure>

<h3 id="通用查询日志（Genaral-Query-Log）"><a href="#通用查询日志（Genaral-Query-Log）" class="headerlink" title="通用查询日志（Genaral Query Log）"></a>通用查询日志（Genaral Query Log）</h3><p>该日志记录 MySQL 服务器的启动和关闭信息、客户端的连接信息、更新、查询数据记录的 SQL 语句等。默认为 <code>主机名.log</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; show variables like &quot;general_log%&quot;;</span><br><span class="line">+------------------+--------------------------------------------+</span><br><span class="line">| Variable_name    | Value                                      |</span><br><span class="line">+------------------+--------------------------------------------+</span><br><span class="line">| general_log      | OFF                                        |</span><br><span class="line">| general_log_file | &#x2F;var&#x2F;lib&#x2F;mysql&#x2F;iz2zeaf3cg1099kiidi06mz.log |</span><br><span class="line">+------------------+--------------------------------------------+</span><br><span class="line">2 rows in set (0.24 sec)   </span><br><span class="line"></span><br><span class="line">#默认为不开启</span><br><span class="line">mysql&gt; set global general_log&#x3D;&#39;ON&#39;;</span><br><span class="line">Query OK, 0 rows affected (0.05 sec)</span><br></pre></td></tr></table></figure>

<h3 id="二进制日志（Binary-Log）"><a href="#二进制日志（Binary-Log）" class="headerlink" title="二进制日志（Binary Log）"></a>二进制日志（Binary Log）</h3><p>该日志文件会以二进制的形式记录数据库的各种操作，但不记录查询语句。</p>
<p>此外，二进制还包括了执行数据库更改操作的时间和执行时间等信息。<strong>二进制日志主要有以下几种作用</strong>:</p>
<ul>
<li><strong>恢复(recovery)</strong>： 某些数据的恢复需要二进制日志，如当一个数据库全备文件恢复后，我们可以通过二进制的日志进行 <code>point-in-time</code>的恢复</li>
<li><strong>复制(replication)</strong> : 通过复制和执行二进制日志使得一台远程的 MySQL 数据库(一般是slave 或者 standby) 与一台MySQL数据库(一般为master或者primary) 进行实时同步</li>
<li><strong>审计(audit)</strong>：用户可以通过二进制日志中的信息来进行审计，判断是否有对数据库进行注入攻击</li>
</ul>
<h4 id="开启二进制日志"><a href="#开启二进制日志" class="headerlink" title="开启二进制日志"></a>开启二进制日志</h4><p>通过配置参数 <code>log-bin[=name]</code> 可以启动二进制日志。如果不指定name,则默认二进制日志文件名为主机名，后缀名为二进制日志的序列号</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">log-bin</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; show variables like &#39;datadir&#39;;</span><br><span class="line">+---------------+-----------------+</span><br><span class="line">| Variable_name | Value           |</span><br><span class="line">+---------------+-----------------+</span><br><span class="line">| datadir       | &#x2F;var&#x2F;lib&#x2F;mysql&#x2F; |</span><br><span class="line">+---------------+-----------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>



<p>mysqld-bin.000001即为二进制日志文件，而mysqld-bin.index为二进制的索引文件，为了管理所有的binlog文件，MySQL额外创建了一个index文件，它按顺序记录了MySQL使用的所有binlog文件。如果你想自定义index文件的名称，可以设置 <code>log_bin_index=file</code>参数。</p>
<h4 id="查看二进制日志文件"><a href="#查看二进制日志文件" class="headerlink" title="查看二进制日志文件"></a>查看二进制日志文件</h4><p>对于二进制日志文件来说，不像错误日志文件，慢查询日志文件那样用cat，head, tail等命令可以查看，它需要通过 MySQL 提供的工具 mysqlbinlog。如:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@iz2zeaf3cg1099kiidi06mz mysql]# mysqlbinlog mysqld-bin.000001</span><br><span class="line">&#x2F;*!50530 SET @@SESSION.PSEUDO_SLAVE_MODE&#x3D;1*&#x2F;;</span><br><span class="line">&#x2F;*!40019 SET @@session.max_insert_delayed_threads&#x3D;0*&#x2F;;</span><br><span class="line">&#x2F;*!50003 SET @OLD_COMPLETION_TYPE&#x3D;@@COMPLETION_TYPE,COMPLETION_TYPE&#x3D;0*&#x2F;;</span><br><span class="line">DELIMITER &#x2F;*!*&#x2F;;</span><br><span class="line"># at 4</span><br><span class="line">#180821 16:42:53 server id 1  end_log_pos 120 CRC32 0x3e55be40 	Start: binlog v 4, server v 5.6.39-log created 180821 16:42:53 at startup</span><br><span class="line"># Warning: this binlog is either in use or was not closed properly.</span><br><span class="line">ROLLBACK&#x2F;*!*&#x2F;;</span><br><span class="line">BINLOG &#39;</span><br><span class="line">jdB7Ww8BAAAAdAAAAHgAAAABAAQANS42LjM5LWxvZwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA</span><br><span class="line">AAAAAAAAAAAAAAAAAACN0HtbEzgNAAgAEgAEBAQEEgAAXAAEGggAAAAICAgCAAAACgoKGRkAAUC+</span><br><span class="line">VT4&#x3D;</span><br><span class="line">&#39;&#x2F;*!*&#x2F;;</span><br><span class="line">DELIMITER ;</span><br><span class="line"># End of log file</span><br><span class="line">ROLLBACK &#x2F;* added by mysqlbinlog *&#x2F;;</span><br><span class="line">&#x2F;*!50003 SET COMPLETION_TYPE&#x3D;@OLD_COMPLETION_TYPE*&#x2F;;</span><br><span class="line">&#x2F;*!50530 SET @@SESSION.PSEUDO_SLAVE_MODE&#x3D;0*&#x2F;;</span><br></pre></td></tr></table></figure>

<h4 id="二进制日志文件配置参数"><a href="#二进制日志文件配置参数" class="headerlink" title="二进制日志文件配置参数"></a>二进制日志文件配置参数</h4><p><strong>max_binlog_size</strong></p>
<p>可以通过max_binlog_size参数来限定单个binlog文件的大小(默认1G)</p>
<p><strong>binlog_cache_size</strong></p>
<p>当使用事务的表存储引擎(如InnoDB存储引擎)时，所有未提交(uncommitted)的二进制日志会被记录到一个缓冲中去，等该事务提交(committed)时，直接将缓存中的二进制日志写入二进制日志文件中，而该缓冲的大小由<code>binlog_cache_size</code>决定，默认大小为32K。此外，<code>binlog_cache_size</code> 是基于会话(session)的，当每一个线程开启一个事务时，MySQL会自动分配一个大小为 <code>binlog_cache_size</code> 的缓存</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; show variables like &#39;binlog_cache_size&#39;;</span><br><span class="line">+-------------------+-------+</span><br><span class="line">| Variable_name     | Value |</span><br><span class="line">+-------------------+-------+</span><br><span class="line">| binlog_cache_size | 32768 |</span><br><span class="line">+-------------------+-------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p><strong>sync_binlog</strong></p>
<p>在默认情况下，二进制日志并不是在每次写的时候同步到磁盘。参数 <code>sync_binlog</code> = [N] 表示每写缓冲多少次就同步到磁盘。如果将N设置为1，即 <code>sync_binlog = 1</code>表示采用同步写磁盘的方式来写二进制日志，这时写操作就不用向上面所说的使用操作系统的缓冲来写二进制日志</p>
<p><strong>binlog_format</strong></p>
<p><code>binlog_format</code> 参数十分重要，它影响了记录二进制日志的格式,分为三种格式:</p>
<ul>
<li>statement : 记录的是日志的逻辑SQL语句</li>
<li>row: 记录表的行更改情况</li>
<li>mixed: 在此格式下，mysql默认采用statement格式进行二进制日志文件的记录，但是有些情况下使用ROW格式，有以下几种情况:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">表的存储引擎为NDB，这时对表的DML操作都会以ROW格式记录。</span><br><span class="line">使用了UUID()、USER()、CURRENT_USER()、FOUND_ROW()、ROW_COUNT()等不确定函数。</span><br><span class="line">使用了INSERT DELAY语句。</span><br><span class="line">使用了用户定义函数（UDF）。</span><br><span class="line">使用了临时表（temporary table）。</span><br></pre></td></tr></table></figure>

<h3 id="重做日志（redo-log）"><a href="#重做日志（redo-log）" class="headerlink" title="重做日志（redo log）"></a>重做日志（redo log）</h3><h4 id="作用：确保事务的持久性。"><a href="#作用：确保事务的持久性。" class="headerlink" title="作用：确保事务的持久性。"></a>作用：确保事务的持久性。</h4><p>　　防止在发生故障的时间点，尚有脏页未写入磁盘，在重启mysql服务的时候，根据redo log进行重做，从而达到事务的持久性这一特性。</p>
<h4 id="内容："><a href="#内容：" class="headerlink" title="内容："></a>内容：</h4><p>　　物理格式的日志，记录的是物理数据页面的修改的信息，其redo log是顺序写入redo log file的物理文件中去的。</p>
<h4 id="什么时候产生："><a href="#什么时候产生：" class="headerlink" title="什么时候产生："></a>什么时候产生：</h4><p>　　事务开始之后就产生redo log，redo log的落盘并不是随着事务的提交才写入的，而是在事务的执行过程中，便开始写入redo log文件中。</p>
<h4 id="什么时候释放："><a href="#什么时候释放：" class="headerlink" title="什么时候释放："></a>什么时候释放：</h4><p>　　当对应事务的脏页写入到磁盘之后，redo log的使命也就完成了，重做日志占用的空间就可以重用（被覆盖）。</p>
<h4 id="对应的物理文件："><a href="#对应的物理文件：" class="headerlink" title="对应的物理文件："></a>对应的物理文件：</h4><p>　　默认情况下，对应的物理文件位于数据库的data目录下的<code>ib_logfile1</code>和<code>ib_logfile2</code><br>　　innodb_log_group_home_dir 指定日志文件组所在的路径，默认./ ，表示在数据库的数据目录下。<br>　　innodb_log_files_in_group 指定重做日志文件组中文件的数量，默认2<br>　　关于文件的大小和数量，由一下两个参数配置<br>　　innodb_log_file_size 重做日志文件的大小。<br>　　innodb_mirrored_log_groups 指定了日志镜像文件组的数量，默认1</p>
<h4 id="其他："><a href="#其他：" class="headerlink" title="其他："></a>其他：</h4><p>　　很重要一点，redo log是什么时候写盘的？前面说了是在事物开始之后逐步写盘的。<br>　　之所以说重做日志是在事务开始之后逐步写入重做日志文件，而不一定是事务提交才写入重做日志缓存，<br>　　原因就是，重做日志有一个缓存区Innodb_log_buffer，Innodb_log_buffer的默认大小为8M(这里设置的16M),Innodb存储引擎先将重做日志写入innodb_log_buffer中。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> show variables like <span class="string">'%innodb_log_buffer_size%'</span>;</span></span><br><span class="line">+-----------------------+-----------------------+</span><br><span class="line">| Variable_name     	| Value 				|</span><br><span class="line">+-----------------------+-----------------------+</span><br><span class="line">|innodb_log_buffer_size | 16777216 				|</span><br><span class="line">+-----------------------+-----------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>　　然后会通过以下三种方式将innodb日志缓冲区的日志刷新到磁盘<br>　　1，Master Thread 每秒一次执行刷新Innodb_log_buffer到重做日志文件。<br>　　2，每个事务提交时会将重做日志刷新到重做日志文件。<br>　　3，当重做日志缓存可用空间 少于一半时，重做日志缓存被刷新到重做日志文件<br>　　由此可以看出，重做日志通过不止一种方式写入到磁盘，尤其是对于第一种方式，Innodb_log_buffer到重做日志文件是Master Thread线程的定时任务。<br>　　因此重做日志的写盘，并不一定是随着事务的提交才写入重做日志文件的，而是随着事务的开始，逐步开始的。<br>　　另外引用《MySQL技术内幕 Innodb 存储引擎》（page37）上的原话：<br>　　即使某个事务还没有提交，Innodb存储引擎仍然每秒会将重做日志缓存刷新到重做日志文件。<br>　　这一点是必须要知道的，因为这可以很好地解释再大的事务的提交（commit）的时间也是很短暂的。</p>
<h3 id="回滚日志（undo-log）"><a href="#回滚日志（undo-log）" class="headerlink" title="回滚日志（undo log）"></a>回滚日志（undo log）</h3><h4 id="作用："><a href="#作用：" class="headerlink" title="作用："></a>作用：</h4><p>　　保存了事务发生之前的数据的一个版本，可以用于回滚，同时可以提供多版本并发控制下的读（MVCC），也即非锁定读</p>
<h4 id="内容：-1"><a href="#内容：-1" class="headerlink" title="内容："></a>内容：</h4><p>　　逻辑格式的日志，在执行undo的时候，仅仅是将数据从逻辑上恢复至事务之前的状态，而不是从物理页面上操作实现的，这一点是不同于redo log的。</p>
<h4 id="什么时候产生：-1"><a href="#什么时候产生：-1" class="headerlink" title="什么时候产生："></a>什么时候产生：</h4><p>　　事务开始之前，将当前是的版本生成undo log，undo 也会产生 redo 来保证undo log的可靠性</p>
<h4 id="什么时候释放：-1"><a href="#什么时候释放：-1" class="headerlink" title="什么时候释放："></a>什么时候释放：</h4><p>　　当事务提交之后，undo log并不能立马被删除，<br>　　而是放入待清理的链表，由purge线程判断是否由其他事务在使用undo段中表的上一个事务之前的版本信息，决定是否可以清理undo log的日志空间。</p>
<h4 id="对应的物理文件：-1"><a href="#对应的物理文件：-1" class="headerlink" title="对应的物理文件："></a>对应的物理文件：</h4><p>MySQL5.6之前，undo表空间位于共享表空间的回滚段中，共享表空间的默认的名称是ibdata，位于数据文件目录中。<br>　　MySQL5.6之后，undo表空间可以配置成独立的文件，但是提前需要在配置文件中配置，完成数据库初始化后生效且不可改变undo log文件的个数<br>　　如果初始化数据库之前没有进行相关配置，那么就无法配置成独立的表空间了。<br>　　关于MySQL5.7之后的独立undo 表空间配置参数如下<br>　　innodb_undo_directory = /data/undospace/ –undo独立表空间的存放目录<br>　　innodb_undo_logs = 128 –回滚段为128KB<br>　　innodb_undo_tablespaces = 4 –指定有4个undo log文件</p>
<p>　　如果undo使用的共享表空间，这个共享表空间中又不仅仅是存储了undo的信息，共享表空间的默认为与MySQL的数据目录下面，其属性由参数innodb_data_file_path配置。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; show variables like &#39;%innodb_data_file_path%&#39;;</span><br><span class="line">+-----------------------+------------------------+</span><br><span class="line">| Variable_name     	| Value 				 |</span><br><span class="line">+-----------------------+------------------------+</span><br><span class="line">| innodb_data_file_path | ibdata1:12M:autoextend |</span><br><span class="line">+-----------------------+------------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<h4 id="其他：-1"><a href="#其他：-1" class="headerlink" title="其他："></a>其他：</h4><p>　　undo是在事务开始之前保存的被修改数据的一个版本，产生undo日志的时候，同样会伴随类似于保护事务持久化机制的redolog的产生。<br>　　默认情况下undo文件是保持在共享表空间的，也即ibdatafile文件中，当数据库中发生一些大的事务性操作的时候，要生成大量的undo信息，全部保存在共享表空间中的。<br>　　因此共享表空间可能会变的很大，默认情况下，也就是undo 日志使用共享表空间的时候，被“撑大”的共享表空间是不会也不能自动收缩的。<br>　　因此，mysql5.7之后的“独立undo 表空间”的配置就显得很有必要了。</p>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 基础命令</title>
    <url>/blog/2020/08/18/linux%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/blog/assets/css/APlayer.min.css"><script src="/blog/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="基础命令："><a href="#基础命令：" class="headerlink" title="基础命令："></a>基础命令：</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ls  ll  alias   </span><br><span class="line"></span><br><span class="line">ln -s 	源文件  目标文件				软连接</span><br><span class="line"></span><br><span class="line">查看文件权限： 文件属主，添加可执行权限</span><br><span class="line"></span><br><span class="line">ll 文件权限、文件属主： </span><br><span class="line"></span><br><span class="line">chown  -R amico:amico  /eig8t  </span><br><span class="line">将eig8t 文件夹下的所有内容，全部修改属主,属组为amico</span><br><span class="line"></span><br><span class="line">chmod +x start.sh    给脚本加可执行权限</span><br><span class="line">chmod -x start.sh 	给文件去掉可执行权限</span><br><span class="line"></span><br><span class="line">chmod  777   create_amico.sh    给文件加所有权限</span><br><span class="line"></span><br><span class="line">-rwx rwx rwx  1 root root       79 8Ղ  22 18:50      - 开头代表文件</span><br><span class="line"></span><br><span class="line">chmod  777   create_amico    给文件夹加所有权限</span><br><span class="line"></span><br><span class="line">drw xrw xrwx  1 root root       79 8Ղ  22 18:50 	   d 开头代表文件夹</span><br></pre></td></tr></table></figure>



<p>​    </p>
<p>使用手册：</p>
<p>tab —补全<br>man手册查看帮助、<br>help</p>
<p>例如：</p>
<p>进程查看，端口查看：<br>lsof -i:port   （yum -y install lsof ）  </p>
<p>ps -ef | grep  nginx</p>
<p>netstat -tunlp | grep  port|进程|进程PID</p>
<p>简单的检测http接口：</p>
<p>curl -I 内网ip:端口/参数     </p>
<p>例如：  curl -I  172.16.1.212:8080      返回是否 200 状态码</p>
<p>不通的情况： 考虑，接口问题、防火墙问题</p>
<p>接口问题：查找项目存放log   （tail -f /xxx/xxx/out.log）</p>
<p>如果是系统的软件问题一般 log 都会在 /var/log/ 下</p>
<p>journalctl -f   or   tailf /var/log/syslog   监听系统日志</p>
<p>tailf /xxx/project/out.log     监听项目日志</p>
<p>tail -200f /xxx/project/out.log  查看日志 后200 行</p>
<p>tail -500f /xxx/project/out.log |grep -C  20  “error”   显示后500行日志中 带error关键字的前后20行 </p>
<p>-A  打印匹配行的后5行<br>-B  打印匹配行的前5行</p>
<p>防火墙问题：<br>内网：<br>systemctl stop firewalld</p>
<p>关闭selinux:<br>cd /etc/selinux/config<br>sed -i “s/enforcing/disable/g” /etc/selinux/config<br>setenforce 0     关闭selinux</p>
<p>关闭 iptables:</p>
<p>iptables -nvL —查看当前规则<br>iptables -F — 关闭</p>
<hr>
<p>vim 修改基本操作：</p>
<p>:set nu   显示行数</p>
<p>:set nonu  取消显示行数</p>
<p>:167   到167 行</p>
<p>gg       回到编辑文件最开头<br>Shift +g   去到编辑文件最末尾</p>
<p>查找：</p>
<p>/source  正向查找，按n下一个</p>
<p>?source  反向查找， 按n上一个</p>
<p>替换：</p>
<p>:%s/ccccaa/amico/g      把文件中全部的 ccccaa 替换成 amico</p>
<p>:%s/39.108.250.194/3.3.3.3/g</p>
<p>:63,73s/old/new/g     </p>
<p>:%s#/swaggerui/usr/local#/opt#g     替换带有歧义的 文本内容的时候<br>                                    使用 # # #, 或 % % % ， 或 “&quot; 进行转义</p>
<p>sed -i ‘s%old%new%g’   /path/xxx.file</p>
<p>sed -i ‘s/ldnew#g’   /path/xxx.file </p>
<p>sed -i ‘s#old#new#g’   /path/xxx.file </p>
<p>批量注释、批量修改</p>
<p>i      插入，进入编辑状态<br>esc    回到非编辑状态</p>
<p>u   撤销修改<br>ctrl + r  还原撤销修改<br>Shift + A    在光标行的最后插入<br>o          在光标行的下一个进行插入</p>
<p>yy      复制一行<br>3yy   复制三行</p>
<p>dd    删除（剪切）光标所在行</p>
<p>3dd   删除（剪切）从光标开始的 三行</p>
<p>p      粘贴 上面剪切或者是 yy 复制的内容</p>
<p>批量注释：<br>1、  ctrl + v  键盘向下选择需要注释的行</p>
<p>2、  Shift  + i</p>
<p>3、  Shift  + #</p>
<p>4、 连按两次 Esc</p>
<p>取消批量注释：</p>
<p>1、 ctrl + v  键盘向下选择需要注释的行</p>
<p>2、 x    </p>
<p>查看磁盘、查看cpu、内存     vmstat 2 —&gt; 磁盘io等内容</p>
<p>top (Shift + p、 Shift  + m)    cpu 的 1、5、15分钟使用百分比/core        </p>
<p>Shift + m   按内存使用大小排序</p>
<p>Shift + p   按cpu使用大小排序</p>
<p>history     查看历史执行过的命令</p>
<p>!254    执行第254条历史命令</p>
<p>!!   执行上一条命令</p>
<p>ls /usr/local/src<br>cd !$      执行上一条命令的最后一个参数</p>
<p>free -m      查看内存</p>
<p>安装基础软件。 redis、zookeeper、jdk、nginx<br>安装版本选择原则： 不新不旧</p>
<p>redis为例：</p>
<p>一、<br>1.源码下载</p>
<h1 id="wget-http-download-redis-io-releases-redis-5-0-3-tar-gz"><a href="#wget-http-download-redis-io-releases-redis-5-0-3-tar-gz" class="headerlink" title="wget http://download.redis.io/releases/redis-5.0.3.tar.gz"></a>wget <a href="http://download.redis.io/releases/redis-5.0.3.tar.gz" target="_blank" rel="noopener">http://download.redis.io/releases/redis-5.0.3.tar.gz</a></h1><p>2.解压</p>
<h1 id="tar-xf-redis-4-0-11-tar-gz-C-usr-local"><a href="#tar-xf-redis-4-0-11-tar-gz-C-usr-local" class="headerlink" title="tar xf redis-4.0.11.tar.gz -C /usr/local/"></a>tar xf redis-4.0.11.tar.gz -C /usr/local/</h1><h1 id="cd-usr-local-redis-4-0-11"><a href="#cd-usr-local-redis-4-0-11" class="headerlink" title="cd /usr/local/redis-4.0.11"></a>cd /usr/local/redis-4.0.11</h1><h1 id="mv-redis-4-0-11-redis"><a href="#mv-redis-4-0-11-redis" class="headerlink" title="mv redis-4.0.11   redis"></a>mv redis-4.0.11   redis</h1><h1 id="make-amp-amp-make-install"><a href="#make-amp-amp-make-install" class="headerlink" title="make &amp;&amp; make install"></a>make &amp;&amp; make install</h1><p>编译过程有可能报缺什么编译环境。则缺什么装什么<br>(yum|apt-get  -y install  make gcc c   )</p>
<p>如果编译时报 “<strong>* 致命错误 *</strong> ”时，使用下面的命令进行编译</p>
<h1 id="make-MALLOC-libc"><a href="#make-MALLOC-libc" class="headerlink" title="make MALLOC=libc"></a>make MALLOC=libc</h1><p>安装完成</p>
<p>二、</p>
<h1 id="vim-etc-profile-加入长期环境变量"><a href="#vim-etc-profile-加入长期环境变量" class="headerlink" title="vim /etc/profile            加入长期环境变量"></a>vim /etc/profile            加入长期环境变量</h1><p>export PATH=$PATH:/usr/local/redis/src     可在任何地方执行 redis-server 启动命令</p>
<p>echo $PATH      输出当前系统上的 path变量</p>
<p>启动：<br>redis-server  /usr/local/redis/redis.conf </p>
<p>关闭：<br>redis-cli  -p 6379 shutdown </p>
<p>配置文件个别参数……</p>
<p>nginx 配置<br>nginx -t 、 nginx -s reload<br>systemctl restart nginx systemctl stop|start nginx    —yum或apt安装</p>
<p>环境变量<br>echo $SHELL —-   脚本 #!/bin/bash<br>echo $PATH</p>
<p>编写一个简单的启动脚本。以amico-service.sh 为例-</p>
<p>下面是 amico-service.sh 启动、停止、查看状态脚本。自己项目的对应修改路径即可</p>
<hr>
<p>#!/bin/bash</p>
<p>Base_dir=/usr/local/im-service</p>
<p>case $1 in </p>
<pre><code> start)
   bash $Base_dir/amico-im-service/bin/amico-im-service $1 
   sleep 1
   bash $Base_dir/amico-im-service1/bin/amico-im-service $1 

   echo -e &quot;\033[42;37m all service start done \033[0m&quot;
       ;;
  stop)
   bash $Base_dir/amico-im-service/bin/amico-im-service $1
   sleep 1
   bash $Base_dir/amico-im-service1/bin/amico-im-service $1

   echo -e &quot;\033[42;37m all service stop done \033[0m&quot;
   ;;
status) 
   bash $Base_dir/amico-im-service/bin/amico-im-service $1 
   sleep 1
   bash $Base_dir/amico-im-service1/bin/amico-im-service $1 
   ;;
     *) 
   echo &quot;Usage: $0 { start | stop | status }&quot;
   exit 1
   ;;</code></pre><p>esac</p>
<hr>
<p>安装软件：<br>    以Centos7 系列为例：</p>
<p>如果想安装某个知道名字的软件包，例如nginx，lrzsz<br>则：<br>    yum -y install nginx lrzsz </p>
<p>如果想安装指定版本的nginx (添加nginx yum 源后)</p>
<pre><code>yum --showduplicate list nginx         ---列出可安装的版本
yum -y install nginx-1:1.16.1-1.el7   ---安装指定版本</code></pre><p>知道某条命令，需要安装使用，但不知道要安装的包名：</p>
<p>例如： 知道 rz 上传命令，但  yum -y install rz 无法安装该包</p>
<pre><code>yum provides &quot;*/rz&quot;     或   yum whatprovides  &quot;*/rz&quot;

apt-file search &quot;*/rz&quot;  (Ubuntu)</code></pre><p>列出后，找到对应包后符合的：<br>    yum -y install lrzsz </p>
<p>文件上传下载： rz sz 前提安装 yum|apt-get -y install lrzsz </p>
<p>时间同步：<br>yum -y install ntpd || apt-get install -y ntpd </p>
<p>ntpdate  server.org.shanghai   时间服务器可网上找</p>
<p>cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</p>
<p>***  普通用户借权： sudo 前提 root 配置 /etc/sudoers </p>
<p>例如：<br>     sudo yum -y install lrzsz   </p>
<p>文件压缩：tar 、zip</p>
<p>文件解压： tar -xzf xxx.jdk.tar.gz  -C  /usr/local</p>
<p>文件压缩:  yum -y install unzip  tar </p>
<p>zip amico.zip -r /amico    或  tar -cvf  test.tar.gz  test/ </p>
<p>文件传输与登录：ssh、scp</p>
<p>ssh 默认 22 端口远程主机：</p>
<pre><code>ssh  amico@172.16.1.212 </code></pre><p>ssh 非默认 22 端口远程主机：</p>
<pre><code>ssh -p 2222  amico@172.16.1.212 </code></pre><p>scp 文件或文件夹 到远程非 默认端口主机：</p>
<pre><code>scp -P port -r dir amico@172.16.1.212    (-r 参数 ，scp复制文件夹)

scp -P port xxx.file amico@172.16.1.212 (互相拷贝文件)</code></pre><p>阿里云或内网主机查看出口ip：</p>
<p>curl ifconfig.me</p>
<p>查看机器内网ip：</p>
<p>ifconfig<br>ip addr </p>
<p>从给定链接下载文件到 /opt 目录下：<br>wget -P /opt/    <a href="https://www.baidu.com/xxx.file" target="_blank" rel="noopener">https://www.baidu.com/xxx.file</a>   </p>
<p>拉取代码：<br>git clone  <a href="https://github/xxx.project" target="_blank" rel="noopener">https://github/xxx.project</a> </p>
<p>更新代码：<br>git pull  <a href="https://github/xxx.project" target="_blank" rel="noopener">https://github/xxx.project</a></p>
<p>ss -tnl  查看端口</p>
<p>ss -tnl | grep “8080”</p>
<p>netstat -tunlp | grep “3306”  或   netstat -tunlp | grep “mysql”<br>查看tcp、udp端口</p>
<p>查找项目pid号。</p>
<ol>
<li>根据端口找进程pid</li>
</ol>
<p>pid=lsof -i:8055| awk ‘{print $2}’</p>
<p>寻找父进程</p>
<p>ps -ef | grep “pid”</p>
<p>ppid=<code>ps -ef | grep $pid | grep -v &#39;grep&#39;|  awk &#39;{print $3}&#39;</code></p>
<p>杀掉进程：</p>
<p>kill -9 $ppid   若 ppid 为 1 的情况下，则 kill -p $pid</p>
<p>查看进程使用内存：</p>
<p>ps aux |grep “30482”|grep -v “grep”|awk ‘{sum+=$6}; END{print sum}’</p>
<p>or </p>
<p>top -p 30482  (RES 单位为 /Kb)</p>
<p>查看磁盘可用空间：</p>
<p>df -h </p>
<p>查看某个文件大小：</p>
<p>du -sh ./xxx.file</p>
<p>hostname </p>
<p>hostnamectl   –查看linux服务器信息</p>
<p>cat /etc/redhat-release  </p>
]]></content>
      <categories>
        <category>操作系统</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>命令</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis</title>
    <url>/blog/2022/05/01/Redis/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/blog/assets/css/APlayer.min.css"><script src="/blog/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><strong>“Redis is an open source (BSD licensed), in-memory data structure store, used as a database, cache and message broker.”</strong> —— Redis是一个开放源代码（BSD许可）的内存中数据结构存储，用作数据库，缓存和消息代理。<em>(摘自官网)</em></p>
<p><strong>Redis</strong> 是一个开源，高级的键值存储和一个适用的解决方案，用于构建高性能，可扩展的 Web 应用程序。<strong>Redis</strong> 也被作者戏称为 <em>数据结构服务器</em> ，这意味着使用者可以通过一些命令，基于带有 TCP 套接字的简单 <em>服务器-客户端</em> 协议来访问一组 <strong>可变数据结构</strong> 。<em>(在 Redis 中都采用键值对的方式，只不过对应的数据结构不一样罢了)</em></p>
<a id="more"></a>

<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul>
<li><strong>异常快</strong> - Redis 非常快，每秒可执行大约 110000 次的设置(SET)操作，每秒大约可执行 81000 次的读取/获取(GET)操作。</li>
<li><strong>支持丰富的数据类型</strong> - Redis 支持开发人员常用的大多数数据类型，例如列表，集合，排序集和散列等等。这使得 Redis 很容易被用来解决各种问题，因为我们知道哪些问题可以更好使用地哪些数据类型来处理解决。</li>
<li><strong>操作具有原子性</strong> - 所有 Redis 操作都是原子操作，这确保如果两个客户端并发访问，Redis 服务器能接收更新的值。</li>
<li><strong>多实用工具</strong> - Redis 是一个多实用工具，可用于多种用例，如：缓存，消息队列(Redis 本地支持发布/订阅)，应用程序中的任何短期数据，例如，web应用程序中的会话，网页命中计数等。</li>
</ul>
<h2 id="基本数据结构"><a href="#基本数据结构" class="headerlink" title="基本数据结构"></a>基本数据结构</h2><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p>Redis 中的字符串是一种 <strong>动态字符串</strong>，这意味着使用者可以修改，它的底层实现有点类似于 Java 中的 <strong>ArrayList</strong>，有一个字符数组，从源码的 <strong>sds.h/sdshdr 文件</strong> 中可以看到 Redis 底层对于字符串的定义 <strong>SDS</strong>，即 <em>Simple Dynamic String</em> 结构：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Note: sdshdr5 is never used, we just access the flags byte directly.</span></span><br><span class="line"><span class="comment"> * However is here to document the layout of type 5 SDS strings. */</span></span><br><span class="line"><span class="function">struct <span class="title">__attribute__</span> <span class="params">((__packed__)</span>) sdshdr5 </span>&#123;</span><br><span class="line">    unsignedchar flags; <span class="comment">/* 3 lsb of type, and 5 msb of string length */</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">struct <span class="title">__attribute__</span> <span class="params">((__packed__)</span>) sdshdr8 </span>&#123;</span><br><span class="line">    uint8_t len; <span class="comment">/* used */</span></span><br><span class="line">    uint8_t alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    unsignedchar flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">struct <span class="title">__attribute__</span> <span class="params">((__packed__)</span>) sdshdr16 </span>&#123;</span><br><span class="line">    uint16_t len; <span class="comment">/* used */</span></span><br><span class="line">    uint16_t alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    unsignedchar flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">struct <span class="title">__attribute__</span> <span class="params">((__packed__)</span>) sdshdr32 </span>&#123;</span><br><span class="line">    uint32_t len; <span class="comment">/* used */</span></span><br><span class="line">    uint32_t alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    unsignedchar flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">struct <span class="title">__attribute__</span> <span class="params">((__packed__)</span>) sdshdr64 </span>&#123;</span><br><span class="line">    uint64_t len; <span class="comment">/* used */</span></span><br><span class="line">    uint64_t alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    unsignedchar flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>你会发现同样一组结构 Redis 使用泛型定义了好多次，<strong>为什么不直接使用 int 类型呢？</strong></p>
<p>因为当字符串比较短的时候，len 和 alloc 可以使用 byte 和 short 来表示，<strong>Redis 为了对内存做极致的优化，不同长度的字符串使用不同的结构体来表示。</strong></p>
<h4 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">设置</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> SET key newValue</span></span><br><span class="line">OK</span><br><span class="line"><span class="meta">#</span><span class="bash">获取</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> GET key</span></span><br><span class="line">"newValue"</span><br><span class="line"><span class="meta">#</span><span class="bash">判断是否存在</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> EXISTS key</span></span><br><span class="line">(integer) 1</span><br><span class="line"><span class="meta">#</span><span class="bash">删除</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> DEL key</span></span><br><span class="line">(integer) 1</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> GET key</span></span><br><span class="line">(nil)</span><br><span class="line"><span class="meta">#</span><span class="bash">批量设置键值对</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> SET key1 value1</span></span><br><span class="line">OK</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> SET key2 value2</span></span><br><span class="line">OK</span><br><span class="line"><span class="meta"> #</span><span class="bash"> 返回一个列表</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> MGET key1 key2 key3   </span></span><br><span class="line">1) "value1"</span><br><span class="line">2) "value2"</span><br><span class="line">3) (nil)</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> MSET key1 value1 key2 value2</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> MGET key1 key2</span></span><br><span class="line">1) "value1"</span><br><span class="line">2) "value2"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">过期和 SET 命令扩展</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> SET key value1</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> GET key</span></span><br><span class="line">"value1"</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> EXPIRE name 5    <span class="comment"># 5s 后过期</span></span></span><br><span class="line">...                # 等待 5s</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> GET key</span></span><br><span class="line">(nil)</span><br><span class="line"><span class="meta">#</span><span class="bash">setnx </span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> SETNX key value1  <span class="comment"># 如果 key 不存在则 SET 成功</span></span></span><br><span class="line">(integer) 1</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> SETNX key value1  <span class="comment"># 如果 key 存在则 SET 失败</span></span></span><br><span class="line">(integer) 0</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> GET key</span></span><br><span class="line">"value"             # 没有改变</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">计数</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"><span class="built_in">set</span> count 100</span></span><br><span class="line">"OK"</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">incr count</span></span><br><span class="line">"101"</span><br><span class="line"><span class="meta">#</span><span class="bash">返回原值的 GETSET 命令</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> SET key value</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> GETSET key value1</span></span><br><span class="line">"value"</span><br></pre></td></tr></table></figure>

<h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><p>Redis 的列表相当于 Java 语言中的 <strong>LinkedList</strong>，注意它是链表而不是数组。这意味着 list 的插入和删除操作非常快，时间复杂度为 O(1)，但是索引定位很慢，时间复杂度为 O(n)。</p>
<p>我们可以从源码的 <code>adlist.h/listNode</code> 来看到对其的定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Node, List, and Iterator are the only data structures used currently. */</span></span><br><span class="line"></span><br><span class="line">typedefstruct listNode &#123;</span><br><span class="line">    struct listNode *prev;</span><br><span class="line">    struct listNode *next;</span><br><span class="line">    <span class="keyword">void</span> *value;</span><br><span class="line">&#125; listNode;</span><br><span class="line"></span><br><span class="line">typedefstruct listIter &#123;</span><br><span class="line">    listNode *next;</span><br><span class="line">    <span class="keyword">int</span> direction;</span><br><span class="line">&#125; listIter;</span><br><span class="line"></span><br><span class="line">typedefstruct list &#123;</span><br><span class="line">    listNode *head;</span><br><span class="line">    listNode *tail;</span><br><span class="line">    <span class="keyword">void</span> *(*dup)(<span class="keyword">void</span> *ptr);</span><br><span class="line">    <span class="keyword">void</span> (*free)(<span class="keyword">void</span> *ptr);</span><br><span class="line">    <span class="keyword">int</span> (*match)(<span class="keyword">void</span> *ptr, <span class="keyword">void</span> *key);</span><br><span class="line">    unsignedlong len;</span><br><span class="line">&#125; list;</span><br></pre></td></tr></table></figure>



<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; LPUSH runoobkey redis</span><br><span class="line">(integer) 1</span><br><span class="line">redis 127.0.0.1:6379&gt; LPUSH runoobkey mongodb</span><br><span class="line">(integer) 2</span><br><span class="line">redis 127.0.0.1:6379&gt; LPUSH runoobkey mysql</span><br><span class="line">(integer) 3</span><br><span class="line">redis 127.0.0.1:6379&gt; LRANGE runoobkey 0 10</span><br><span class="line"></span><br><span class="line">1) "mysql"</span><br><span class="line">2) "mongodb"</span><br><span class="line">3) "redis"</span><br></pre></td></tr></table></figure>

<ul>
<li><code>LPUSH</code> 和 <code>RPUSH</code> 分别可以向 list 的左边（头部）和右边（尾部）添加一个新元素；</li>
<li><code>LRANGE</code> 命令可以从 list 中取出一定范围的元素；</li>
<li><code>LINDEX</code> 命令可以从 list 中取出指定下表的元素，相当于 Java 链表操作中的 <code>get(int index)</code> 操作；</li>
</ul>
<h3 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h3><p>Redis 中的字典相当于 Java 中的 <strong>HashMap</strong>，内部实现也差不多类似，都是通过 <strong>“数组 + 链表”</strong> 的链地址法来解决部分 <strong>哈希冲突</strong>，同时这样的结构也吸收了两种不同数据结构的优点。源码定义如 <code>dict.h/dictht</code> 定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">typedefstruct dictht &#123;</span><br><span class="line">    <span class="comment">// 哈希表数组</span></span><br><span class="line">    dictEntry **table;</span><br><span class="line">    <span class="comment">// 哈希表大小</span></span><br><span class="line">    unsignedlong size;</span><br><span class="line">    <span class="comment">// 哈希表大小掩码，用于计算索引值，总是等于 size - 1</span></span><br><span class="line">    unsignedlong sizemask;</span><br><span class="line">    <span class="comment">// 该哈希表已有节点的数量</span></span><br><span class="line">    unsignedlong used;</span><br><span class="line">&#125; dictht;</span><br><span class="line"></span><br><span class="line">typedefstruct dict &#123;</span><br><span class="line">    dictType *type;</span><br><span class="line">    <span class="keyword">void</span> *privdata;</span><br><span class="line">    <span class="comment">// 内部有两个 dictht 结构</span></span><br><span class="line">    dictht ht[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">long</span> rehashidx; <span class="comment">/* rehashing not in progress if rehashidx == -1 */</span></span><br><span class="line">    unsignedlong iterators; <span class="comment">/* number of iterators currently running */</span></span><br><span class="line">&#125; dict;</span><br></pre></td></tr></table></figure>

<p><code>table</code> 属性是一个数组，数组中的每个元素都是一个指向 <code>dict.h/dictEntry</code> 结构的指针，而每个 <code>dictEntry</code> 结构保存着一个键值对：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">typedefstruct dictEntry &#123;</span><br><span class="line">    <span class="comment">// 键</span></span><br><span class="line">    <span class="keyword">void</span> *key;</span><br><span class="line">    <span class="comment">// 值</span></span><br><span class="line">    union &#123;</span><br><span class="line">        <span class="keyword">void</span> *val;</span><br><span class="line">        uint64_t u64;</span><br><span class="line">        int64_t s64;</span><br><span class="line">        <span class="keyword">double</span> d;</span><br><span class="line">    &#125; v;</span><br><span class="line">    <span class="comment">// 指向下个哈希表节点，形成链表</span></span><br><span class="line">    struct dictEntry *next;</span><br><span class="line">&#125; dictEntry;</span><br></pre></td></tr></table></figure>

<p>可以从上面的源码中看到，<strong>实际上字典结构的内部包含两个 hashtable</strong>，通常情况下只有一个 hashtable 是有值的，但是在字典扩容缩容时，需要分配新的 hashtable，然后进行 <strong>渐进式搬迁</strong> <em>(下面说原因)</em>。</p>
<h4 id="渐进式-rehash"><a href="#渐进式-rehash" class="headerlink" title="渐进式 rehash"></a>渐进式 rehash</h4><p>大字典的扩容是比较耗时间的，需要重新申请新的数组，然后将旧字典所有链表中的元素重新挂接到新的数组下面，这是一个 O(n) 级别的操作，作为单线程的 Redis 很难承受这样耗时的过程，所以 Redis 使用 <strong>渐进式 rehash</strong> 小步搬迁：</p>
<p>渐进式 rehash 会在 rehash 的同时，保留新旧两个 hash 结构，如上图所示，查询时会同时查询两个 hash 结构，然后在后续的定时任务以及 hash 操作指令中，循序渐进的把旧字典的内容迁移到新字典中。当搬迁完成了，就会使用新的 hash 结构取而代之。</p>
<h4 id="基本操作-1"><a href="#基本操作-1" class="headerlink" title="基本操作"></a>基本操作</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> HSET books java <span class="string">"think in java"</span>    <span class="comment"># 命令行的字符串如果包含空格则需要使用引号包裹</span></span></span><br><span class="line">(integer) 1</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> HSET books python <span class="string">"python cookbook"</span></span></span><br><span class="line">(integer) 1</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> HGETALL books    <span class="comment"># key 和 value 间隔出现</span></span></span><br><span class="line">1) "java"</span><br><span class="line">2) "think in java"</span><br><span class="line">3) "python"</span><br><span class="line">4) "python cookbook"</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> HGET books java</span></span><br><span class="line">"think in java"</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> HSET books java <span class="string">"head first java"</span>  </span></span><br><span class="line">(integer) 0        # 因为是更新操作，所以返回 0</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> HMSET books java <span class="string">"effetive  java"</span> python <span class="string">"learning python"</span>    <span class="comment"># 批量操作</span></span></span><br><span class="line">OK</span><br></pre></td></tr></table></figure>

<h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p>Redis 的集合相当于 Java 语言中的 <strong>HashSet</strong>，它内部的键值对是无序、唯一的。它的内部实现相当于一个特殊的字典，字典中所有的 value 都是一个值 NULL。</p>
<h4 id="基本操作-2"><a href="#基本操作-2" class="headerlink" title="基本操作"></a>基本操作</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> SADD books java</span></span><br><span class="line">(integer) 1</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> SADD books java    <span class="comment"># 重复</span></span></span><br><span class="line">(integer) 0</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> SADD books python golang</span></span><br><span class="line">(integer) 2</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> SMEMBERS books    <span class="comment"># 注意顺序，set 是无序的</span></span></span><br><span class="line">1) "java"</span><br><span class="line">2) "python"</span><br><span class="line">3) "golang"</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> SISMEMBER books java    <span class="comment"># 查询某个 value 是否存在，相当于 contains</span></span></span><br><span class="line">(integer) 1</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> SCARD books    <span class="comment"># 获取长度</span></span></span><br><span class="line">(integer) 3</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> SPOP books     <span class="comment"># 弹出一个</span></span></span><br><span class="line">"java"</span><br></pre></td></tr></table></figure>



<h3 id="SoetedSet"><a href="#SoetedSet" class="headerlink" title="SoetedSet"></a>SoetedSet</h3><p>这可能使 Redis 最具特色的一个数据结构了，它类似于 Java 中 <strong>SortedSet</strong> 和 <strong>HashMap</strong> 的结合体，一方面它是一个 set，保证了内部 value 的唯一性，另一方面它可以为每个 value 赋予一个 score 值，用来代表排序的权重。</p>
<p>它的内部实现用的是一种叫做 <strong>「跳跃表」</strong> 的数据结构。</p>
<h4 id="基础操作"><a href="#基础操作" class="headerlink" title="基础操作"></a>基础操作</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> ZADD books 9.0 <span class="string">"think in java"</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> ZADD books 8.9 <span class="string">"java concurrency"</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> ZADD books 8.6 <span class="string">"java cookbook"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> ZRANGE books 0 -1     <span class="comment"># 按 score 排序列出，参数区间为排名范围</span></span></span><br><span class="line">1) "java cookbook"</span><br><span class="line">2) "java concurrency"</span><br><span class="line">3) "think in java"</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> ZREVRANGE books 0 -1  <span class="comment"># 按 score 逆序列出，参数区间为排名范围</span></span></span><br><span class="line">1) "think in java"</span><br><span class="line">2) "java concurrency"</span><br><span class="line">3) "java cookbook"</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> ZCARD books           <span class="comment"># 相当于 count()</span></span></span><br><span class="line">(integer) 3</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> ZSCORE books <span class="string">"java concurrency"</span>   <span class="comment"># 获取指定 value 的 score</span></span></span><br><span class="line">"8.9000000000000004"                # 内部 score 使用 double 类型进行存储，所以存在小数点精度问题</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> ZRANK books <span class="string">"java concurrency"</span>    <span class="comment"># 排名</span></span></span><br><span class="line">(integer) 1</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> ZRANGEBYSCORE books 0 8.91        <span class="comment"># 根据分值区间遍历 zset</span></span></span><br><span class="line">1) "java cookbook"</span><br><span class="line">2) "java concurrency"</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> ZRANGEBYSCORE books -inf 8.91 withscores  <span class="comment"># 根据分值区间 (-∞, 8.91] 遍历 zset，同时返回分值。inf 代表 infinite，无穷大的意思。</span></span></span><br><span class="line">1) "java cookbook"</span><br><span class="line">2) "8.5999999999999996"</span><br><span class="line">3) "java concurrency"</span><br><span class="line">4) "8.9000000000000004"</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> ZREM books <span class="string">"java concurrency"</span>             <span class="comment"># 删除 value</span></span></span><br><span class="line">(integer) 1</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> ZRANGE books 0 -1</span></span><br><span class="line">1) "java cookbook"</span><br><span class="line">2) "think in java"</span><br></pre></td></tr></table></figure>

<h2 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h2><p>RDB 是把内存中的数据集以快照形式写入磁盘，实际操作是通过 fork 子进程执行，采用二进制压缩存储；AOF 是以文本日志的形式记录 <strong>Redis</strong> 处理的每一个写入或删除操作。</p>
<h3 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h3><p><strong>RDB</strong> 把整个 Redis 的数据保存在单一文件中，比较适合用来做灾备，但缺点是快照保存完成之前如果宕机，这段时间的数据将会丢失，另外保存快照时可能导致服务短时间不可用。</p>
<h3 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h3><p><strong>AOF</strong> 对日志文件的写入操作使用的追加模式，有灵活的同步策略，支持每秒同步、每次修改同步和不同步，缺点就是相同规模的数据集，AOF 要大于 RDB，AOF 在运行效率上往往会慢于 RDB。</p>
<h2 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a>高可用</h2><p>来看 Redis 的高可用。Redis 支持主从同步，提供 Cluster 集群部署模式，通过 Sentinel哨兵来监控 Redis 主服务器的状态。当主挂掉时，在从节点中根据一定策略选出新主，并调整其他从 slaveof 到新主。</p>
<p>选主的策略简单来说有三个：</p>
<ul>
<li>slave 的 priority 设置的越低，优先级越高；</li>
<li>同等情况下，slave 复制的数据越多优先级越高；</li>
<li>相同的条件下 runid 越小越容易被选中。</li>
</ul>
<p>在 Redis 集群中，sentinel 也会进行多实例部署，sentinel 之间通过 Raft 协议来保证自身的高可用。</p>
<p>Redis Cluster 使用分片机制，在内部分为 16384 个 slot 插槽，分布在所有 master 节点上，每个 master 节点负责一部分 slot。数据操作时按 key 做 CRC16 来计算在哪个 slot，由哪个 master 进行处理。数据的冗余是通过 slave 节点来保障。</p>
<h2 id="哨兵模式"><a href="#哨兵模式" class="headerlink" title="哨兵模式"></a>哨兵模式</h2><p>哨兵必须用三个实例去保证自己的健壮性的，哨兵+主从并<strong>不能保证数据不丢失</strong>，但是可以保证集群的<strong>高可用</strong>。</p>
<ul>
<li>集群监控：负责监控 Redis master 和 slave 进程是否正常工作。</li>
<li>消息通知：如果某个 <strong>Redis</strong> 实例有故障，那么哨兵负责发送消息作为报警通知给管理员。</li>
<li>故障转移：如果 master node 挂掉了，会自动转移到 slave node 上。</li>
<li>配置中心：如果故障转移发生了，通知 client 客户端新的 master 地址。</li>
</ul>
<h2 id="主从"><a href="#主从" class="headerlink" title="主从"></a>主从</h2><p>提到这个，就跟我前面提到的数据持久化的<strong>RDB</strong>和<strong>AOF</strong>有着比密切的关系了。</p>
<p>我先说下为啥要用主从这样的架构模式，前面提到了单机<strong>QPS</strong>是有上限的，而且<strong>Redis</strong>的特性就是必须支撑读高并发的，那你一台机器又读又写，<strong>这谁顶得住啊</strong>，不当人啊！但是你让这个master机器去写，数据同步给别的slave机器，他们都拿去读，分发掉大量的请求那是不是好很多，而且扩容的时候还可以轻松实现水平扩容。</p>
<p>你启动一台slave 的时候，他会发送一个<strong>psync</strong>命令给master ，如果是这个slave第一次连接到master，他会触发一个全量复制。master就会启动一个线程，生成<strong>RDB</strong>快照，还会把新的写请求都缓存在内存中，<strong>RDB</strong>文件生成后，master会将这个<strong>RDB</strong>发送给slave的，slave拿到之后做的第一件事情就是写进本地的磁盘，然后加载进内存，然后master会把内存里面缓存的那些新命名都发给slave。之后的同步master会用<strong>AOF</strong>，增量的就像<strong>MySQL</strong>的<strong>Binlog</strong>一样，把日志增量同步给从服务。</p>
<h2 id="缓存常见问题"><a href="#缓存常见问题" class="headerlink" title="缓存常见问题"></a>缓存常见问题</h2><h3 id="缓存更新方式"><a href="#缓存更新方式" class="headerlink" title="缓存更新方式"></a>缓存更新方式</h3><p>这是决定在使用缓存时就该考虑的问题。</p>
<p>缓存的数据在数据源发生变更时需要对缓存进行更新，数据源可能是 DB，也可能是远程服务。更新的方式可以是主动更新。数据源是 DB 时，可以在更新完 DB 后就直接更新缓存。</p>
<p>当数据源不是 DB 而是其他远程服务，可能无法及时主动感知数据变更，这种情况下一般会选择对缓存数据设置失效期，也就是数据不一致的最大容忍时间。</p>
<p>这种场景下，可以选择失效更新，key 不存在或失效时先请求数据源获取最新数据，然后再次缓存，并更新失效期。</p>
<p>但这样做有个问题，如果依赖的远程服务在更新时出现异常，则会导致数据不可用。改进的办法是异步更新，就是当失效时先不清除数据，继续使用旧的数据，然后由异步线程去执行更新任务。这样就避免了失效瞬间的空窗期。另外还有一种纯异步更新方式，定时对数据进行分批更新。实际使用时可以根据业务场景选择更新方式。</p>
<h3 id="数据不一致"><a href="#数据不一致" class="headerlink" title="数据不一致"></a>数据不一致</h3><p>第二个问题是数据不一致的问题，可以说只要使用缓存，就要考虑如何面对这个问题。缓存不一致产生的原因一般是主动更新失败，例如更新 DB 后，更新 <strong>Redis</strong> 因为网络原因请求超时；或者是异步更新失败导致。</p>
<p>解决的办法是，如果服务对耗时不是特别敏感可以增加重试；如果服务对耗时敏感可以通过异步补偿任务来处理失败的更新，或者短期的数据不一致不会影响业务，那么只要下次更新时可以成功，能保证最终一致性就可以。</p>
<h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><p><strong>缓存穿透</strong>。产生这个问题的原因可能是外部的恶意攻击，例如，对用户信息进行了缓存，但恶意攻击者使用不存在的用户id频繁请求接口，导致查询缓存不命中，然后穿透 DB 查询依然不命中。这时会有大量请求穿透缓存访问到 DB。</p>
<p>解决的办法如下。</p>
<ol>
<li>对不存在的用户，在缓存中保存一个空对象进行标记，防止相同 ID 再次访问 DB。不过有时这个方法并不能很好解决问题，可能导致缓存中存储大量无用数据。</li>
<li>使用 <strong>BloomFilter</strong> 过滤器，BloomFilter 的特点是存在性检测，如果 BloomFilter 中不存在，那么数据一定不存在；如果 BloomFilter 中存在，实际数据也有可能会不存在。非常适合解决这类的问题。</li>
</ol>
<h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h3><p><strong>缓存击穿</strong>，就是某个热点数据失效时，大量针对这个数据的请求会穿透到数据源。</p>
<p>解决这个问题有如下办法。</p>
<ol>
<li>可以使用互斥锁更新，保证同一个进程中针对同一个数据不会并发请求到 DB，减小 DB 压力。</li>
<li>使用随机退避方式，失效时随机 sleep 一个很短的时间，再次查询，如果失败再执行更新。</li>
<li>针对多个热点 key 同时失效的问题，可以在缓存时使用固定时间加上一个小的随机数，避免大量热点 key 同一时刻失效。</li>
</ol>
<h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><p><strong>缓存雪崩</strong>，产生的原因是缓存挂掉，这时所有的请求都会穿透到 DB。</p>
<p>解决方法：</p>
<ol>
<li>使用快速失败的熔断策略，减少 DB 瞬间压力；</li>
<li>使用主从模式和集群模式来尽量保证缓存服务的高可用。</li>
</ol>
]]></content>
      <categories>
        <category>数据库</category>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL数据库事务</title>
    <url>/blog/2020/08/18/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/blog/assets/css/APlayer.min.css"><script src="/blog/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="MySQL数据库事务"><a href="#MySQL数据库事务" class="headerlink" title="MySQL数据库事务"></a>MySQL数据库事务</h1><p>本文所说的 MySQL 事务都是指在 InnoDB 引擎下，MyISAM 引擎是不支持事务的。</p>
<p>数据库事务指的是一组数据操作，事务内的操作要么就是全部成功，要么就是全部失败，什么都不做，其实不是没做，是可能做了一部分但是只要有一步失败，就要回滚所有操作，有点一不做二不休的意思。</p>
<a id="more"></a>

<p>假设一个网购付款的操作，用户付款后要涉及到订单状态更新、扣库存以及其他一系列动作，这就是一个事务，如果一切正常那就相安无事，一旦中间有某个环节异常，那整个事务就要回滚，总不能更新了订单状态但是不扣库存吧，这问题就大了。</p>
<h2 id="数据库事务特征：ACID"><a href="#数据库事务特征：ACID" class="headerlink" title="数据库事务特征：ACID"></a>数据库事务特征：ACID</h2><h3 id="原子性（Atomicity）"><a href="#原子性（Atomicity）" class="headerlink" title="原子性（Atomicity）"></a>原子性（Atomicity）</h3><p>一个事务（transaction）中的所有操作，或者全部完成，或者全部不完成，不会结束在中间某个环节.</p>
<h3 id="一致性（Consistent）"><a href="#一致性（Consistent）" class="headerlink" title="一致性（Consistent）"></a>一致性（Consistent）</h3><p>在事务开始之前和完成之后，数据都必须保持一致状态，必须保证数据库的完整性。也就是说，数据必须符合数据库的规则。</p>
<h3 id="隔离性（Isolation）"><a href="#隔离性（Isolation）" class="headerlink" title="隔离性（Isolation）"></a>隔离性（Isolation）</h3><p>数据库允许多个并发事务同时对数据进行操作，隔离性保证各个事务相互独立，事务处理时的中间状态对其它事务是不可见的，以此防止出现数据不一致状态。<strong>可通过事务隔离级别设置：包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）</strong></p>
<h3 id="持久性（Durability）"><a href="#持久性（Durability）" class="headerlink" title="持久性（Durability）"></a>持久性（Durability）</h3><p>事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</p>
<h2 id="脏读、幻读、不可重复读的概念"><a href="#脏读、幻读、不可重复读的概念" class="headerlink" title="脏读、幻读、不可重复读的概念"></a>脏读、幻读、不可重复读的概念</h2><p>以下几个概念是事务隔离级别要实际解决的问题，所以需要搞清楚都是什么意思。</p>
<h3 id="脏读：一个事务中访问到了另外一个事务未提交的数据"><a href="#脏读：一个事务中访问到了另外一个事务未提交的数据" class="headerlink" title="脏读：一个事务中访问到了另外一个事务未提交的数据"></a>脏读：一个事务中访问到了另外一个事务未提交的数据</h3><p>脏读指的是读到了其他事务未提交的数据，未提交意味着这些数据可能会回滚，也就是可能最终不会存到数据库中，也就是不存在的数据。读到了并一定最终存在的数据，这就是脏读。</p>
<table>
<thead>
<tr>
<th align="center">事务A</th>
<th align="center">事务B</th>
</tr>
</thead>
<tbody><tr>
<td align="center">账户5000</td>
<td align="center">账户5000</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">小明老婆花了3000</td>
</tr>
<tr>
<td align="center">小明查看账户2000（产生脏读）</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">取款操作发生未知错误，事务B回滚，账户还是5000（rollback）</td>
</tr>
<tr>
<td align="center">commit</td>
<td align="center">commit</td>
</tr>
</tbody></table>
<p>事务B更新账户为2000，但是在事务B commit之前，事务A查看账户时是事务B还未提交的数据，此时事务B出现错误执行rollback，而事务A拿到的还是2000，这就是脏读。</p>
<h3 id="不可重复读：同一个事务中重复读取时获得的数据不同"><a href="#不可重复读：同一个事务中重复读取时获得的数据不同" class="headerlink" title="不可重复读：同一个事务中重复读取时获得的数据不同"></a>不可重复读：同一个事务中重复读取时获得的数据不同</h3><p>不可重复读指的是在同一事务内，不同的时刻读到的同一批数据可能是不一样的，可能会受到其他事务的影响，比如其他事务改了这批数据并提交了。通常针对数据<strong>更新（UPDATE）</strong>操作。</p>
<table>
<thead>
<tr>
<th align="center">事务A</th>
<th align="center">事务B</th>
</tr>
</thead>
<tbody><tr>
<td align="center">账户5000</td>
<td align="center">账户5000</td>
</tr>
<tr>
<td align="center">小明查看账户5000</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">小明老婆花了3000（修改该账户）</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">commit</td>
</tr>
<tr>
<td align="center">小明查看账户2000</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">commit</td>
<td align="center"></td>
</tr>
</tbody></table>
<p>在事务A中事务B修改了该账户，所以两次得到的值不同。</p>
<h3 id="幻读：幻读是不可重复读的特殊场景，但是事务二的数据操作仅仅是插入和删除，不是修改数据，读取的记录数量前后不一致"><a href="#幻读：幻读是不可重复读的特殊场景，但是事务二的数据操作仅仅是插入和删除，不是修改数据，读取的记录数量前后不一致" class="headerlink" title="幻读：幻读是不可重复读的特殊场景，但是事务二的数据操作仅仅是插入和删除，不是修改数据，读取的记录数量前后不一致"></a>幻读：幻读是不可重复读的特殊场景，但是事务二的数据操作仅仅是插入和删除，不是修改数据，读取的记录数量前后不一致</h3><p>幻读是针对数据<strong>插入（INSERT）或删除（DELETE）</strong>操作来说的。假设事务A对某些行的内容作了更改，但是还未提交，此时事务B插入了与事务A更改前的记录相同的记录行，并且在事务A提交之前先提交了，而这时，在事务A中查询，会发现好像刚刚的更改对于某些数据未起作用，但其实是事务B刚插入进来的，让用户感觉很魔幻，感觉出现了幻觉，这就叫幻读。</p>
<table>
<thead>
<tr>
<th align="center">事务A</th>
<th align="center">事务B</th>
</tr>
</thead>
<tbody><tr>
<td align="center">查询id&gt;100的用户（只有101）</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">插入id=102的用户（John）</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">commit</td>
</tr>
<tr>
<td align="center">插入id=102的用户（主键冲突，幻读）</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">commit</td>
<td align="center"></td>
</tr>
</tbody></table>
<h3 id="幻读和不可重复读的区别"><a href="#幻读和不可重复读的区别" class="headerlink" title="幻读和不可重复读的区别"></a>幻读和不可重复读的区别</h3><p>由于很多人(当然也包括本人), 容易搞混 <code>不可重复读</code> 和 <code>幻读</code>, 这两者确实非常相似。</p>
<ul>
<li><code>不可重复读</code> 主要是说多次读取一条记录, 发现该记录中某些列值被==修改==过。</li>
<li><code>幻读</code> 主要是说多次读取<strong>一个范围内的记录</strong>(包括直接查询所有记录结果或者做聚合统计), 发现结果不一致(标准档案一般指<strong>记录增多</strong>, <strong>记录的减少</strong>应该也算是幻读)。(可以参考<a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-next-key-locking.html" target="_blank" rel="noopener">MySQL官方文档对 Phantom Rows 的介绍</a>)</li>
<li>对于 <code>幻读</code>, MySQL的InnoDB引擎默认的<code>RR</code>级别已经通过<code>MVCC（多版本并发控制）自动帮我们解决了</code>,具体可以参考《高性能MySQL》对 <code>RR</code> 隔离级别的描述</li>
</ul>
<p>总结：</p>
<p>（1）不可重复读是读取了其他事务更改的数据，针对<strong>update</strong>操作</p>
<p>解决：使用行级锁，锁定该行，事务A多次读取操作完成后才释放该锁，这个时候才允许其他事务更改刚才的数据。</p>
<p>（2）幻读是读取了其他事务新增的数据，针对<strong>insert与delete</strong>操作</p>
<p>解决：使用表级锁，锁定整张表，事务A多次读取数据总量之后才释放该锁，这个时候才允许其他事务新增数据。</p>
<h2 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h2><h3 id="READ-UNCOMMITTED-读未提交数据"><a href="#READ-UNCOMMITTED-读未提交数据" class="headerlink" title="READ UNCOMMITTED(读未提交数据)"></a>READ UNCOMMITTED(读未提交数据)</h3><p>MySQL 事务隔离其实是依靠锁来实现的，加锁自然会带来性能的损失。而读未提交隔离级别是不加锁的，所以它的性能是最好的，没有加锁、解锁带来的性能开销。但有利就有弊，这基本上就相当于裸奔啊，所以它连脏读的问题都没办法解决。</p>
<h3 id="READ-COMMITTED-读已提交数据"><a href="#READ-COMMITTED-读已提交数据" class="headerlink" title="READ COMMITTED(读已提交数据)"></a>READ COMMITTED(读已提交数据)</h3><p>读提交就是一个事务只能读到其他事务已经提交过的数据，也就是其他事务调用 commit 命令之后的数据。那脏数据问题迎刃而解了。</p>
<h3 id="REPEATABLE-READ-可重复读"><a href="#REPEATABLE-READ-可重复读" class="headerlink" title="REPEATABLE READ(可重复读)"></a>REPEATABLE READ(可重复读)</h3><p>可重复是对比不可重复而言的，不可重复读是指同一事物不同时刻读到的数据值可能不一致。而可重复读是指，事务不会读到其他事务对已有数据的修改，即使其他事务已提交，也就是说，事务开始时读到的已有数据是什么，在事务提交前的任意时刻，这些数据的值都是一样的。但是，对于其他事务新插入的数据是可以读到的，这也就引发了幻读问题。</p>
<h3 id="SERIALIZABLE-串行化"><a href="#SERIALIZABLE-串行化" class="headerlink" title="SERIALIZABLE(串行化)"></a>SERIALIZABLE(串行化)</h3><p>串行化是4种事务隔离级别中隔离效果最好的，解决了脏读、可重复读、幻读的问题，但是效果最差，它将事务的执行变为顺序执行，与其他三个隔离级别相比，它就相当于单线程，后一个事务的执行必须等待前一个事务结束。</p>
<p>读的时候加共享锁，也就是其他事务可以并发读，但是不能写。写的时候加排它锁，其他事务不能并发写也不能并发读。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>从上往下，隔离强度逐渐增强，性能逐渐变差。采用哪种隔离级别要根据系统需求权衡决定，不同的事务隔离级别会导致不同的问题：</p>
<table>
<thead>
<tr>
<th>隔离级别</th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻读</th>
</tr>
</thead>
<tbody><tr>
<td>Read uncommittied(读未提交数据)</td>
<td>可能</td>
<td>可能</td>
<td>可能</td>
</tr>
<tr>
<td>Read committied(读已提交数据)</td>
<td>不可能</td>
<td>可能</td>
<td>可能</td>
</tr>
<tr>
<td>Repea read(可重复读)</td>
<td>不可能</td>
<td>不可能</td>
<td>可能</td>
</tr>
<tr>
<td>Serializable(可序列化)</td>
<td>不可能</td>
<td>不可能</td>
<td>不可能</td>
</tr>
</tbody></table>
<h3 id="查看和设置事务隔离级别"><a href="#查看和设置事务隔离级别" class="headerlink" title="查看和设置事务隔离级别"></a>查看和设置事务隔离级别</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 查看事务隔离级别</span><br><span class="line">SELECT @@tx_isolation</span><br><span class="line">show variables like &#39;tx_isolation&#39;</span><br><span class="line"></span><br><span class="line">+---------------+-----------------+</span><br><span class="line">| Variable_name | Value           |</span><br><span class="line">+---------------+-----------------+</span><br><span class="line">| tx_isolation  | REPEATABLE-READ |</span><br><span class="line">+---------------+-----------------+</span><br><span class="line"></span><br><span class="line">#设置全局事务隔离级别</span><br><span class="line">mysql&gt; set global transaction isolation level read committed;</span><br></pre></td></tr></table></figure>

<p>修改隔离级别的语句是：set [作用域] transaction isolation level [事务隔离级别]，<br>SET [SESSION | GLOBAL] TRANSACTION ISOLATION LEVEL {READ UNCOMMITTED | READ COMMITTED | REPEATABLE READ | SERIALIZABLE}。</p>
<p>其中作用于可以是 SESSION 或者 GLOBAL，GLOBAL 是全局的，而 SESSION 只针对当前会话窗口。</p>
<h2 id="MySQL是如何实现事务隔离的？"><a href="#MySQL是如何实现事务隔离的？" class="headerlink" title="MySQL是如何实现事务隔离的？"></a>MySQL是如何实现事务隔离的？</h2><p>首先说读未提交，它是性能最好，也可以说它是最野蛮的方式，因为它压根儿就不加锁，所以根本谈不上什么隔离效果，可以理解为没有隔离。</p>
<p>再来说串行化。读的时候加共享锁，也就是其他事务可以并发读，但是不能写。写的时候加排它锁，其他事务不能并发写也不能并发读。</p>
<p>最后说读提交和可重复读。这两种隔离级别是比较复杂的，既要允许一定的并发，又想要兼顾的解决问题。</p>
<h3 id="实现可重复读"><a href="#实现可重复读" class="headerlink" title="实现可重复读"></a>实现可重复读</h3><p>为了解决不可重复读，或者为了实现可重复读，MySQL 采用了 MVVC (多版本并发控制) 的方式。</p>
<p>我们在数据库表中看到的一行记录可能实际上有多个版本，每个版本的记录除了有数据本身外，还要有一个表示版本的字段，记为 row trx_id，而这个字段就是使其产生的事务的 id，事务 ID 记为 transaction id，它在事务开始的时候向事务系统申请，按时间先后顺序递增。</p>
<h2 id="事务七种传播行为："><a href="#事务七种传播行为：" class="headerlink" title="事务七种传播行为："></a>事务七种传播行为：</h2><table>
<thead>
<tr>
<th><strong>事务传播行为类型</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td>PROPAGATION_REQUIRED</td>
<td>如果当前没有事务，就创建一个新事务，如果当前存在事务，就加入该事务。这是最常见的选择。</td>
</tr>
<tr>
<td>PROPAGATION_SUPPORTS</td>
<td>支持当前事务，如果当前没有事务，就以非事务方式执行。</td>
</tr>
<tr>
<td>PROPAGATION_MANDATORY</td>
<td>使用当前的事务，如果当前没有事务，就抛出异常。</td>
</tr>
<tr>
<td>PROPAGATION_REQUIRED_NEW</td>
<td>新建事务，如果当前存在事务，就把当前事务挂起。</td>
</tr>
<tr>
<td>PROPAGATION_NOT_SUPPORTED</td>
<td>以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。</td>
</tr>
<tr>
<td>PROPAGATION_NEVER</td>
<td>以非事务方式执行操作，如果当前存在事务，则抛出异常。</td>
</tr>
<tr>
<td>PROPAGATION_NESTED</td>
<td>如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与PROPAGATION_REQUIRED类似的操作。</td>
</tr>
</tbody></table>
<h2 id="InnoDB锁机制"><a href="#InnoDB锁机制" class="headerlink" title="InnoDB锁机制"></a>InnoDB锁机制</h2><p>锁机制用于管理对共享资源的并发访问。</p>
<h3 id="为什么要加锁？"><a href="#为什么要加锁？" class="headerlink" title="为什么要加锁？"></a>为什么要加锁？</h3><p>当多个用户并发地存取数据时，在数据库中就可能会产生多个事务同时操作同一行数据的情况，若对并发操作不加控制就可能会读取和存储不正确的数据，破坏数据的一致性。</p>
<p>一种典型的并发问题——丢失更新（其他锁问题及解决方法会在后面说到）：</p>
<h4 id="第一类丢失更新-回滚丢失，Lost-update-：-A事务撤销时，把已经提交的B事务的更新数据覆盖了。"><a href="#第一类丢失更新-回滚丢失，Lost-update-：-A事务撤销时，把已经提交的B事务的更新数据覆盖了。" class="headerlink" title="第一类丢失更新(回滚丢失，Lost update) ： A事务撤销时，把已经提交的B事务的更新数据覆盖了。"></a><strong>第一类丢失更新</strong>(回滚丢失，Lost update) ： A事务撤销时，把已经提交的B事务的更新数据覆盖了。</h4><table>
<thead>
<tr>
<th align="center">事务A</th>
<th align="center">事务B</th>
</tr>
</thead>
<tbody><tr>
<td align="center">开启事务A</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">开启事务B</td>
</tr>
<tr>
<td align="center">查询账户余额1000</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">查询并汇入1000元，余额改为2000元</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">提交事务commit</td>
</tr>
<tr>
<td align="center">取出1000元，把余额改为0元</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">撤销事务</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">余额1000（丢失更新）</td>
<td align="center"></td>
</tr>
</tbody></table>
<h4 id="第二类丢失更新-覆盖丢失-两次更新问题，Second-lost-update-：-A事务覆盖B事务已经提交的数据，造成B事务所做操作丢失"><a href="#第二类丢失更新-覆盖丢失-两次更新问题，Second-lost-update-：-A事务覆盖B事务已经提交的数据，造成B事务所做操作丢失" class="headerlink" title="第二类丢失更新(覆盖丢失/两次更新问题，Second lost update) ： A事务覆盖B事务已经提交的数据，造成B事务所做操作丢失"></a><strong>第二类丢失更新</strong>(覆盖丢失/两次更新问题，Second lost update) ： A事务覆盖B事务已经提交的数据，造成B事务所做操作丢失</h4><table>
<thead>
<tr>
<th align="center">事务A</th>
<th align="center">事务B</th>
</tr>
</thead>
<tbody><tr>
<td align="center"></td>
<td align="center">查询账户余额1000</td>
</tr>
<tr>
<td align="center">查询账户余额1000</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">取出1000元，把余额改为0元</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">commit</td>
</tr>
<tr>
<td align="center">汇入1000元</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">commit</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">余额2000（丢失更新）</td>
<td align="center"></td>
</tr>
</tbody></table>
<h3 id="InnoDB锁类型"><a href="#InnoDB锁类型" class="headerlink" title="InnoDB锁类型"></a>InnoDB锁类型</h3><p><img data-src="%E9%94%81.png" alt="锁"></p>
<h4 id="乐观锁与悲观锁是两种并发控制的思想，可用于解决丢失更新问题："><a href="#乐观锁与悲观锁是两种并发控制的思想，可用于解决丢失更新问题：" class="headerlink" title="乐观锁与悲观锁是两种并发控制的思想，可用于解决丢失更新问题："></a>乐观锁与悲观锁是两种并发控制的思想，可用于解决丢失更新问题：</h4><p>乐观锁会“乐观地”假定大概率不会发生并发更新冲突，访问、处理数据过程中不加锁，只在更新数据时再根据版本号或时间戳判断是否有冲突，有则处理，无则提交事务；</p>
<p>悲观锁会“悲观地”假定大概率会发生并发更新冲突，访问、处理数据前就加排他锁，在整个数据处理过程中锁定数据，事务提交或回滚后才释放锁；</p>
<h4 id="InnoDB支持多种锁粒度，默认使用行锁，锁粒度最小，锁冲突发生的概率最低，支持的并发度也最高，但系统消耗成本也相对较高；"><a href="#InnoDB支持多种锁粒度，默认使用行锁，锁粒度最小，锁冲突发生的概率最低，支持的并发度也最高，但系统消耗成本也相对较高；" class="headerlink" title="InnoDB支持多种锁粒度，默认使用行锁，锁粒度最小，锁冲突发生的概率最低，支持的并发度也最高，但系统消耗成本也相对较高；"></a>InnoDB支持多种锁粒度，默认使用行锁，锁粒度最小，锁冲突发生的概率最低，支持的并发度也最高，但系统消耗成本也相对较高；</h4><h4 id="共享锁（Shared-lock）与排他锁（Exclusive-lock）是InnoDB实现的两种标准的行锁；"><a href="#共享锁（Shared-lock）与排他锁（Exclusive-lock）是InnoDB实现的两种标准的行锁；" class="headerlink" title="共享锁（Shared lock）与排他锁（Exclusive lock）是InnoDB实现的两种标准的行锁；"></a>共享锁（Shared lock）与排他锁（Exclusive lock）是InnoDB实现的两种标准的行锁；</h4><h4 id="InnoDB有三种锁算法——记录锁、gap间隙锁、还有结合了记录锁与间隙锁的next-key锁，InnoDB对于行的查询加锁是使用的是next-key-locking这种算法，一定程度上解决了幻读问题；"><a href="#InnoDB有三种锁算法——记录锁、gap间隙锁、还有结合了记录锁与间隙锁的next-key锁，InnoDB对于行的查询加锁是使用的是next-key-locking这种算法，一定程度上解决了幻读问题；" class="headerlink" title="InnoDB有三种锁算法——记录锁、gap间隙锁、还有结合了记录锁与间隙锁的next-key锁，InnoDB对于行的查询加锁是使用的是next-key locking这种算法，一定程度上解决了幻读问题；"></a>InnoDB有三种锁算法——记录锁、gap间隙锁、还有结合了记录锁与间隙锁的next-key锁，InnoDB对于行的查询加锁是使用的是next-key locking这种算法，一定程度上解决了幻读问题；</h4><h4 id="意向锁是为了支持多种粒度锁同时存在；"><a href="#意向锁是为了支持多种粒度锁同时存在；" class="headerlink" title="意向锁是为了支持多种粒度锁同时存在；"></a>意向锁是为了支持多种粒度锁同时存在；</h4><h2 id="当前读与快照读"><a href="#当前读与快照读" class="headerlink" title="当前读与快照读"></a>当前读与快照读</h2><h3 id="当前读：即加锁读，读取记录的最新版本，会加锁保证其他并发事务不能修改当前记录，直至获取锁的事务释放锁；"><a href="#当前读：即加锁读，读取记录的最新版本，会加锁保证其他并发事务不能修改当前记录，直至获取锁的事务释放锁；" class="headerlink" title="当前读：即加锁读，读取记录的最新版本，会加锁保证其他并发事务不能修改当前记录，直至获取锁的事务释放锁；"></a>当前读：即加锁读，读取记录的最新版本，会加锁保证其他并发事务不能修改当前记录，直至获取锁的事务释放锁；</h3><p>使用当前读的操作主要包括：显式加锁的读操作与插入/更新/删除等写操作，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from table where ? lock in share mode;</span><br><span class="line">select * from table where ? for update;</span><br><span class="line">insert into table values (…);</span><br><span class="line">update table set ? where ?;</span><br><span class="line">delete from table where ?;</span><br></pre></td></tr></table></figure>

<p>注：当Update SQL被发给MySQL后，MySQL Server会根据where条件，读取第一条满足条件的记录，然后InnoDB引擎会将第一条记录返回，并加锁，待MySQL Server收到这条加锁的记录之后，会再发起一个Update请求，更新这条记录。一条记录操作完成，再读取下一条记录，直至没有满足条件的记录为止。因此，Update操作内部，就包含了当前读。同理，Delete操作也一样。Insert操作会稍微有些不同，简单来说，就是Insert操作可能会触发Unique Key的冲突检查，也会进行一个当前读。</p>
<h3 id="快照读：即不加锁读，读取记录的快照版本而非最新版本，通过MVCC实现；"><a href="#快照读：即不加锁读，读取记录的快照版本而非最新版本，通过MVCC实现；" class="headerlink" title="快照读：即不加锁读，读取记录的快照版本而非最新版本，通过MVCC实现；"></a>快照读：即不加锁读，读取记录的快照版本而非最新版本，通过MVCC实现；</h3><p>InnoDB默认的RR事务隔离级别下，不显式加『lock in share mode』与『for update』的『select』操作都属于快照读，保证事务执行过程中只有第一次读之前提交的修改和自己的修改可见，其他的均不可见；</p>
<h2 id="MVCC机制"><a href="#MVCC机制" class="headerlink" title="MVCC机制"></a>MVCC机制</h2><h3 id="什么是MVCC？"><a href="#什么是MVCC？" class="headerlink" title="什么是MVCC？"></a>什么是MVCC？</h3><p>MVCC，<strong>(Multi Version Concurrency Control的简称)</strong>，多版本并发控制。MVCC 是一种并发控制的方法，一般在数据库管理系统中，实现对数据库的并发访问。</p>
<p>可以认为MVCC是行级锁的一个变种，很多情况下避免了加锁操作，因此开销更低。</p>
<p>MVCC的实现，是通过保存数据在某个时间点的快照来实现的。也就是说不管需要执行多长时间，每个事务看到的数据都是一致的。</p>
<p>InnoDB的MVCC是通过在每行记录后面保存两个隐藏的列来实现的。这两个列，一个保存了行的创建时间，一个保存行的过期时间（或删除时间）。当然存储的并不是实际的时间值，而是<strong>系统版本号（system version number)</strong>。每开始一个新的事务，系统版本号都会自动递增。事务开始时刻的系统版本号会作为事务的版本号，用来和查询到的每行记录的版本号进行比较。</p>
<p>下面看一下在REPEATABLE READ隔离级别下，MVCC具体是如何操作的。</p>
<ul>
<li><p>SELECT</p>
<p>InnoDB会根据以下两个条件检查每行记录：</p>
<ol>
<li>InnoDB只查找版本早于当前事务版本的数据行（也就是，行的系统版本号小于或等于事务的系统版本号），这样可以确保事务读取的行，要么是在事务开始前已经存在的，要么是事务自身插入或者修改过的。</li>
<li>行的删除版本要么未定义，要么大于当前事务版本号。这可以确保事务读取到的行，在事务开始之前未被删除。</li>
</ol>
<p>只有符合上述两个条件的记录，才能返回作为查询结果</p>
</li>
<li><p>INSERT</p>
<p>InnoDB为新插入的每一行保存当前系统版本号作为行版本号。</p>
</li>
<li><p>DELETE</p>
<p>InnoDB为删除的每一行保存当前系统版本号作为行删除标识。</p>
</li>
<li><p>UPDATE</p>
<p>InnoDB为插入一行新记录，保存当前系统版本号作为行版本号，同时保存当前系统版本号到原来的行作为行删除标识。</p>
<p>保存这两个额外系统版本号，使大多数读操作都可以不用加锁。这样设计使得读数据操作很简单，性能很好，并且也能保证只会读取到符合标准的行，不足之处是每行记录都需要额外的存储空间，需要做更多的行检查工作，以及一些额外的维护工作</p>
</li>
</ul>
<p>MVCC只在<strong>可重复度和读已提交</strong>两个隔离级别下工作。因为读未提交总是读取最新的数据行，串行化则会对所有读取的行都加锁。</p>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>事务</tag>
        <tag>隔离级别</tag>
        <tag>MVCC</tag>
      </tags>
  </entry>
  <entry>
    <title>云服务器</title>
    <url>/blog/2022/05/01/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/blog/assets/css/APlayer.min.css"><script src="/blog/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="云服务器"><a href="#云服务器" class="headerlink" title="云服务器"></a>云服务器</h1><h2 id="什么是云服务器"><a href="#什么是云服务器" class="headerlink" title="什么是云服务器"></a>什么是云服务器</h2><p>云服务器(Elastic Compute Service, ECS)是性能卓越、稳定可靠、弹性扩展IaaS（Infrastructure as a Service）级别云计算服务。云服务器免去了采购IT硬件的前期准备，能够便捷、高效地使用服务器，实现计算资源的即开即用和弹性伸缩。</p>
<p>云服务器能够快速构建更稳定、安全的应用，降低开发运维的难度和整体IT成本，更专注于核心业务的创新。</p>
<a id="more"></a>

<h3 id="高可用性"><a href="#高可用性" class="headerlink" title="高可用性"></a>高可用性</h3><h3 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h3><h3 id="弹性"><a href="#弹性" class="headerlink" title="弹性"></a>弹性</h3><ul>
<li><p>计算弹性</p>
<ul>
<li><p>纵向的弹性。</p>
<p>即单台云服务器ECS的配置变更。普通IDC模式下，很难做到对单台服务器进行变更配置。</p>
</li>
<li><p>横向的弹性。</p>
<p>对于游戏应用或直播平台出现的高峰期，若在普通的IDC模式下，根本无法立即准备资源；而云计算却可以使用弹性的方式度过这样的高峰。当业务高峰消失时，可以将多余的资源释放掉，以减少业务成本。利用横向的扩展和缩减，配合阿里云的弹性伸缩，完全可以做到定时定量的伸缩，或者按照业务的负载进行伸缩。关于横向弹性的具体应用，请参见<a href="https://help.aliyun.com/document_detail/25857.html#concept-25857-zh" target="_blank" rel="noopener">什么是弹性伸缩</a>。</p>
</li>
</ul>
</li>
<li><p>存储弹性</p>
<p>当数据量增多时，对于普通的IDC方案，您只能不断增加服务器，而这样扩展的服务器数量是有限的。阿里云为您提供海量的存储，您可以按需购买，为存储提供最大保障。关于存储弹性的具体应用，请参见<a href="https://help.aliyun.com/document_detail/35095.html#concept-e1g-44g-ydb" target="_blank" rel="noopener">云盘扩容</a>。</p>
</li>
<li><p>网络弹性</p>
<p>阿里云的专有网络VPC的网络配置与普通IDC机房配置可以是完全相同的，并且可以拥有更灵活的拓展性。在阿里云，您可以实现各个可用区（机房）之间的互联互通、安全域隔离以及灵活的网络配置和规划。关于网络弹性的具体应用，请参见<a href="https://help.aliyun.com/document_detail/34217.html#concept-kbk-cpz-ndb" target="_blank" rel="noopener">专有网络</a>。</p>
</li>
</ul>
<h3 id="与普通IDC对比优势"><a href="#与普通IDC对比优势" class="headerlink" title="与普通IDC对比优势"></a>与普通IDC对比优势</h3><p>云服务器ECS与普通IDC的优势对比如下表所示。</p>
<table>
<thead>
<tr>
<th align="left">对比项</th>
<th align="left">云服务器ECS</th>
<th align="left">普通IDC</th>
</tr>
</thead>
<tbody><tr>
<td align="left">机房部署</td>
<td align="left">直流电服务器，绿色机房设计，PUE（Power Usage Effectiveness，电源利用效率）值低</td>
<td align="left">传统交流电服务器设计，PUE值高</td>
</tr>
<tr>
<td align="left">骨干机房，出口带宽大，独享带宽</td>
<td align="left">机房质量参差不齐，用户选择困难，以共享带宽为主</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">BGP（Border Gateway Protocol，边界网关协议）多线机房，全国访问流畅均衡</td>
<td align="left">以单线和双线为主</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">操作易用</td>
<td align="left">内置主流的操作系统，Windows正版激活</td>
<td align="left">需用户自备操作系统，自行安装</td>
</tr>
<tr>
<td align="left">可在线更换操作系统</td>
<td align="left">无法在线更换操作系统，需要用户重装</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">Web在线管理，简单方便</td>
<td align="left">没有在线管理工具，维护困难</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">手机验证密码设置，安全方便</td>
<td align="left">重置密码麻烦，且被破解的风险大</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">容灾备份</td>
<td align="left">三副本数据设计，单份损坏可在短时间内快速恢复</td>
<td align="left">用户自行搭建，使用普通存储设备，价格高昂</td>
</tr>
<tr>
<td align="left">用户自定义快照</td>
<td align="left">没有提供快照功能，无法做到自动故障恢复</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">硬件故障事故中可快速自动恢复</td>
<td align="left">数据损坏需用户修复</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">安全可靠</td>
<td align="left">有效阻止MAC欺骗和ARP攻击</td>
<td align="left">很难阻止MAC欺骗和ARP攻击</td>
</tr>
<tr>
<td align="left">有效防护DDoS攻击，可进行流量清洗和黑洞</td>
<td align="left">清洗和黑洞设备需要另外购买，价格昂贵</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">端口入侵扫描、挂马扫描、漏洞扫描等附加服务</td>
<td align="left">普遍存在漏洞挂马和端口扫描等问题</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">灵活扩展</td>
<td align="left">开通云服务器非常灵活，可以在线升级配置</td>
<td align="left">服务器交付周期长</td>
</tr>
<tr>
<td align="left">带宽升降自由</td>
<td align="left">带宽一次性购买，无法自由升降</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">在线使用负载均衡，轻松扩展应用</td>
<td align="left">硬件负载均衡，价格昂贵，设置也非常麻烦</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">节约成本</td>
<td align="left">使用成本门槛低</td>
<td align="left">使用成本门槛高</td>
</tr>
<tr>
<td align="left">无需一次性大投入</td>
<td align="left">一次性投入巨大，闲置浪费严重</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">按需购买，弹性付费，灵活应对业务变化</td>
<td align="left">无法按需购买，必须为业务峰值满配</td>
<td align="left"></td>
</tr>
</tbody></table>
<h2 id="为什么要用云服务器"><a href="#为什么要用云服务器" class="headerlink" title="为什么要用云服务器"></a>为什么要用云服务器</h2><ul>
<li>无需自建机房，无需采购以及配置硬件设施。</li>
<li>分钟级交付，快速部署，缩短应用上线周期。</li>
<li>快速接入部署在全球范围内的数据中心和BGP机房。</li>
<li>成本透明，按需使用，支持根据业务波动随时扩展和释放资源。</li>
<li>提供GPU和FPGA等异构计算服务器、弹性裸金属服务器以及通用的x86架构服务器。</li>
<li>支持通过内网访问其他阿里云服务，形成丰富的行业解决方案，降低公网流量成本。</li>
<li>提供虚拟防火墙、角色权限控制、内网隔离、防病毒攻击及流量监控等多重安全方案。</li>
<li>提供性能监控框架和主动运维体系。</li>
<li>提供行业通用标准API，提高易用性和适用性。</li>
</ul>
<h2 id="怎么使用云服务器"><a href="#怎么使用云服务器" class="headerlink" title="怎么使用云服务器"></a>怎么使用云服务器</h2><h3 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h3><p>云服务器ECS主要包含以下功能组件：</p>
<ul>
<li><a href="https://help.aliyun.com/document_detail/25374.html#concept-i1k-fv2-5db" target="_blank" rel="noopener">实例</a>：等同于一台虚拟服务器，内含CPU、内存、操作系统、网络配置、磁盘等基础的计算组件。实例的计算性能、内存性能和适用业务场景由实例规格决定，其具体性能指标包括实例vCPU核数、内存大小、网络性能等。</li>
<li><a href="https://help.aliyun.com/document_detail/25389.html#concept-qql-3zb-wdb" target="_blank" rel="noopener">镜像</a>：提供实例的操作系统、初始化应用数据及预装的软件。操作系统支持多种Linux发行版和多种Windows Server版本。</li>
<li><a href="https://help.aliyun.com/document_detail/63136.html#concept-pl4-tzb-wdb" target="_blank" rel="noopener">块存储</a>：块设备类型产品，具备高性能和低时延的特性。提供基于分布式存储架构的云盘以及基于物理机本地存储的本地盘。</li>
<li><a href="https://help.aliyun.com/document_detail/25391.html#concept-qft-2zw-ydb" target="_blank" rel="noopener">快照</a>：某一时间点一块云盘的数据状态文件。常用于数据备份、数据恢复和制作自定义镜像等。</li>
<li><a href="https://help.aliyun.com/document_detail/25387.html#concept-o2y-mqw-ydb" target="_blank" rel="noopener">安全组</a>：由同一地域内具有相同保护需求并相互信任的实例组成，是一种虚拟防火墙，用于设置实例的网络访问控制。</li>
<li><a href="https://help.aliyun.com/document_detail/61651.html?spm=a2c4g.11186623.2.20.6e8350bfHzPQ8Y#concept-nfj-dz2-5db" target="_blank" rel="noopener">网络</a>：<ul>
<li><a href="https://help.aliyun.com/document_detail/34217.html#concept-kbk-cpz-ndb" target="_blank" rel="noopener">专有网络（Virtual Private Cloud）</a>：逻辑上彻底隔离的云上私有网络。可以自行分配私网IP地址范围、配置路由表和网关等。</li>
<li>经典网络：所有经典网络类型实例都建立在一个共用的基础网络上。</li>
</ul>
</li>
</ul>
<p><img data-src="p85840.png" alt="p85840"></p>
<h3 id="购买云服务器"><a href="#购买云服务器" class="headerlink" title="购买云服务器"></a>购买云服务器</h3><h4 id="如何选择配置"><a href="#如何选择配置" class="headerlink" title="如何选择配置"></a>如何选择配置</h4><h5 id="普通的个人小型网站，个人博客等小流量网站"><a href="#普通的个人小型网站，个人博客等小流量网站" class="headerlink" title="普通的个人小型网站，个人博客等小流量网站"></a>普通的个人小型网站，个人博客等小流量网站</h5><p>可选择低配置的腾讯云服务器<br>推荐配置：CPU：1核、内存1G或2G、硬盘40G、带宽：1M或2M</p>
<h5 id="论坛、门户类网站"><a href="#论坛、门户类网站" class="headerlink" title="论坛、门户类网站"></a>论坛、门户类网站</h5><p>论坛、门户类网站，用户活跃性与访问量较高，需要有足够的服务器资源空间和带宽，提升访问速度。<br>推荐配置：CPU：2核、内存：4G、硬盘200-500G、带宽：5-10M</p>
<h5 id="品牌官网类网站"><a href="#品牌官网类网站" class="headerlink" title="品牌官网类网站"></a>品牌官网类网站</h5><p>对官网、品牌较为重视的政府、企业等， 需要保证网站浏览更加流利顺畅，提升政府、品牌形象。<br>推荐配置：CPU：4核、内存：8G、硬盘150G、带宽：5M</p>
<h5 id="视频、购物类网站：视频、购物类网站"><a href="#视频、购物类网站：视频、购物类网站" class="headerlink" title="视频、购物类网站：视频、购物类网站"></a>视频、购物类网站：视频、购物类网站</h5><p>包含庞大的数据信息， 需要保证迅速的信息处理能力保证网站的点播、交易正常进行。<br>推荐配置：CPU：8核、内存：16G、硬盘300G以上、带宽：10M以上</p>
<h5 id="游戏、软件类网站"><a href="#游戏、软件类网站" class="headerlink" title="游戏、软件类网站"></a>游戏、软件类网站</h5><p>对开发、测试、环境要求较高的游戏软件类网站，需要较高的资源配置带来更强劲的计算性能，保证业务需求。<br>推荐配置：CPU：16核、内存：32G、硬盘：500G、带宽：10M以上</p>
<h4 id="阿里云优惠活动"><a href="#阿里云优惠活动" class="headerlink" title="阿里云优惠活动"></a><a href="https://www.aliyun.com/product/ecs?spm=5176.12825654.eofdhaal5.2.36672c4aRbyxXO" target="_blank" rel="noopener">阿里云</a>优惠活动</h4><h5 id="阿里云小站"><a href="#阿里云小站" class="headerlink" title="阿里云小站"></a><a href="https://www.aliyun.com/minisite/goods?userCode=o3qwwn4m" target="_blank" rel="noopener">阿里云小站</a></h5><h4 id="腾讯云优惠活动"><a href="#腾讯云优惠活动" class="headerlink" title="腾讯云优惠活动"></a><a href="https://cloud.tencent.com/product/cvm" target="_blank" rel="noopener">腾讯云</a>优惠活动</h4><h5 id="星星海SA2云服务器"><a href="#星星海SA2云服务器" class="headerlink" title="星星海SA2云服务器"></a><a href="https://cloud.tencent.com/act/pro/starlake?fromSource=gwzcw.1293314.1293314.1293314&cps_key=2d38bc39c4bd798861417be7ca167f7c" target="_blank" rel="noopener">星星海SA2云服务器</a></h5><h5 id="腾讯云代金券"><a href="#腾讯云代金券" class="headerlink" title="腾讯云代金券"></a><a href="https://www.tengxunyun8.com/url/daijinquan.html" target="_blank" rel="noopener">腾讯云代金券</a></h5><h5 id="商标服务专用代金券"><a href="#商标服务专用代金券" class="headerlink" title="商标服务专用代金券"></a><a href="https://tm.cloud.tencent.com/promotion?from=12646" target="_blank" rel="noopener">商标服务专用代金券</a></h5>]]></content>
      <categories>
        <category>服务器</category>
      </categories>
      <tags>
        <tag>服务器</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL锁</title>
    <url>/blog/2020/08/18/MySQL%E9%94%81/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/blog/assets/css/APlayer.min.css"><script src="/blog/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="MySQL锁"><a href="#MySQL锁" class="headerlink" title="MySQL锁"></a>MySQL锁</h1><p>加锁是实现数据库并发控制的一个非常重要的技术。当事务在对某个数据对象进行操作前，先向系统发出请求，对其加锁。加锁后事务就对该数据对象有了一定的控制，在该事务释放锁之前，其他的事务不能对此数据对象进行更新操作。</p>
<a id="more"></a>

<h2 id="什么是锁？"><a href="#什么是锁？" class="headerlink" title="什么是锁？"></a>什么是锁？</h2><blockquote>
<p>锁是计算机协调多个进程或者多个线程之间并发访问同一资源的机制。在数据库系统中，除了传统的计算机资源(CPU、RAM、I/O)的争用以外，数据也是一种供许多用户共享的资源。如何保证数据并发访问的一致性和有效性是所有数据库系统需要考虑的问题。锁冲突也是影响数据库并发访问性能的一个重要因素。从这个角度来讲，锁对于数据库尤其重要，也更加复杂。</p>
</blockquote>
<p><strong>锁是计算机协调多个进程或线程并发访问某一资源的机制</strong>。</p>
<ul>
<li>锁保证数据并发访问的一致性、有效性。</li>
<li>锁冲突也是影响数据库并发访问性能的一个重要因素。</li>
<li>锁是MySQL在服务器层和存储引擎层的的并发控制。<img data-src="mysql%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%80%BB%E8%BE%91%E6%9E%B6%E6%9E%84.jpg" alt="mysql服务器逻辑架构"></li>
</ul>
<h2 id="为什么要加锁？"><a href="#为什么要加锁？" class="headerlink" title="为什么要加锁？"></a>为什么要加锁？</h2><p>数据库是一个多用户使用的共享资源。当多个用户并发地存取数据时，在数据库中就会产生多个事务同时存取同一数据的情况。若对并发操作不加控制就可能会读取和存储不正确的数据，破坏数据库的一致性。</p>
<p><strong>锁是用于管理对公共资源的并发控制。</strong>也就是说在并发的情况下，会出现资源竞争，所以需要加锁。</p>
<p>加锁解决了多用户环境下保证数据库完整性和一致性。</p>
<p>Lock的对象是事务，用来锁定的是数据库中的对象，如表、页、行。并且一般lock的对象仅在事务commit或rollback后进行释放（不同事务隔离级别释放的时间可能不同）。</p>
<h2 id="锁分类"><a href="#锁分类" class="headerlink" title="锁分类"></a>锁分类</h2><p><img data-src="%E9%94%81.png" alt="锁"></p>
<h3 id="共享锁-读锁-S-锁-share-lock"><a href="#共享锁-读锁-S-锁-share-lock" class="headerlink" title="共享锁||读锁||S 锁(share lock)"></a>共享锁||读锁||S 锁(share lock)</h3><p>其他事务可以读，但不能写。允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁。</p>
<h3 id="排他锁-写锁-X-锁-exclusive）"><a href="#排他锁-写锁-X-锁-exclusive）" class="headerlink" title="排他锁||写锁||X 锁(exclusive）"></a>排他锁||写锁||X 锁(exclusive）</h3><p>其他事务不能读取，也不能写。允许获得排他锁的事务更新数据，阻止其他事务取得相同数据集的共享读锁和排他写锁。</p>
<p>类型细分：</p>
<ul>
<li>意向共享锁(IS Lock/intent share lock)</li>
<li>意向排他锁||互斥锁(IX Lock/intent exclusive lock)</li>
</ul>
<h3 id="悲观锁-保守锁（pessimistic-locking）"><a href="#悲观锁-保守锁（pessimistic-locking）" class="headerlink" title="悲观锁||保守锁（pessimistic locking）:"></a>悲观锁||保守锁（pessimistic locking）:</h3><p>假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作</p>
<p>悲观锁是数据库层面加锁，都会阻塞去等待锁。</p>
<h3 id="乐观锁-optimistic-locking-："><a href="#乐观锁-optimistic-locking-：" class="headerlink" title="乐观锁(optimistic locking)："></a>乐观锁(optimistic locking)：</h3><p>假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。</p>
<p>乐观锁是一种思想，具体实现是，表中有一个版本字段，第一次读的时候，获取到这个字段。处理完业务逻辑开始更新的时候，需要再次查看该字段的值是否和第一次的一样。如果一样更新，反之拒绝。之所以叫乐观，因为这个模式没有从数据库加锁，等到更新的时候再判断是否可以更新。</p>
<p>缺点：并发很高的时候，多了很多无用的重试。乐观锁，不能解决脏读的问题。</p>
<h2 id="锁策略-锁的粒度-粒度维度-lock-granularity"><a href="#锁策略-锁的粒度-粒度维度-lock-granularity" class="headerlink" title="锁策略:锁的粒度/粒度维度(lock granularity)"></a>锁策略:锁的粒度/粒度维度(lock granularity)</h2><p>锁的开销是较为昂贵的，<strong>锁策略其实就是保证了线程安全的同时获取最大的性能之间的平衡策略</strong>。</p>
<h3 id="行级锁-row-level-locking"><a href="#行级锁-row-level-locking" class="headerlink" title="行级锁(row-level locking)"></a>行级锁(row-level locking)</h3><p><strong>行锁</strong>：即只允许事务读一行数据。行锁的粒度是在每一条行数据，当然也带来了最大开销，但是行锁可以最大限度的支持并发处理。</p>
<p>开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。</p>
<h3 id="表级锁-table-level-locking"><a href="#表级锁-table-level-locking" class="headerlink" title="表级锁(table-level locking)"></a>表级锁(table-level locking)</h3><p><strong>表锁</strong>：允许事务在行级上的锁和表级上的锁同时存在。锁定整个表，开销最小，但是也阻塞了整个表。</p>
<p>开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。</p>
<p>表级锁更适合于以查询为主，并发用户少，只有少量按索引条件更新数据的应用，如Web 应用。</p>
<ul>
<li>若一个用户正在执行写操作，会获取排他的“写锁”，这可能会锁定整个表，阻塞其他用户的读、写操作；</li>
<li>若一个用户正在执行读操作，会先获取共享锁“读锁”，这个锁运行其他读锁并发的对这个表进行读取，互不干扰。只要没有写锁的进入，读锁可以是并发读取统一资源的。</li>
</ul>
<p>Mysql的表级别锁分为两类：元数据锁（Metadata Lock，MDL）、表锁。</p>
<h4 id="元数据锁（Metadata-Lock，MDL）"><a href="#元数据锁（Metadata-Lock，MDL）" class="headerlink" title="元数据锁（Metadata Lock，MDL）"></a>元数据锁（Metadata Lock，MDL）</h4><p>元数据锁(MDL) 不需要显式使用，在访问一个表的时候会被自动加上。这个特性需要MySQL5.5版本以上才会支持，</p>
<ul>
<li>当对一个表做增删改查的时候，该表会被加MDL读锁</li>
<li>当对表做结构变更的时候，加MDL写锁</li>
</ul>
<h4 id="MDL锁规则："><a href="#MDL锁规则：" class="headerlink" title="MDL锁规则："></a>MDL锁规则：</h4><ul>
<li>读锁之间不互斥，所以可以多线程多同一张表进行增删改查。</li>
<li>读写锁、写锁之间是互斥的，为了保证表结构变更的安全性，所以如果要多线程对同一个表加字段等表结构操作，就会变成串行化，需要进行锁等待。</li>
<li>MDL的写锁优先级比MDL读锁的优先，但是可以设置<code>max_write_lock_count</code>系统变量来改变这种情况，当写锁请求超过这个变量设置的数后，MDL读锁的优先级会比MDL写锁的优先级高。（默认情况下，这个数字会很大，所以不用担心写锁的优先级下降）</li>
<li>MDL的锁释放必须要等到事务结束才会释放</li>
</ul>
<h3 id="页面锁-page-level-locking"><a href="#页面锁-page-level-locking" class="headerlink" title="页面锁(page-level locking)"></a>页面锁(page-level locking)</h3><p>页级锁定是 MySQL 中比较独特的一种锁定级别，在其他数据库管理软件中也并不是太常见。</p>
<p>页面锁开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。</p>
<p>页级锁定的特点是锁定颗粒度介于行级锁定与表级锁之间，所以获取锁定所需要的资源开销，以及所能提供的并发处理能力也同样是介于上面二者之间。另外，页级锁定和行级锁定一样，会发生死锁。</p>
<p>在数据库实现资源锁定的过程中，随着锁定资源颗粒度的减小，锁定相同数据量的数据所需要消耗的内存数量是越来越多的，实现算法也会越来越复杂。</p>
<p>不过，随着锁定资源颗粒度的减小，应用程序的访问请求遇到锁等待的可能性也会随之降低，系统整体并发度也随之提升。</p>
<p><strong>使用页级锁定的主要是 BerkeleyDB 存储引擎</strong>。</p>
<h3 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h3><p>MySQL 提供全局锁来对整个数据库实例加锁。</p>
<p><strong>FLUSH TABLES WITH READ LOCK</strong> </p>
<p>这条语句一般都是用来备份的，当执行这条语句后，数据库所有打开的表都会被关闭，并且使用全局读锁锁定数据库的所有表，同时，其他线程的更新语句（增删改），数据定义语句（建表，修改表结构）和更新类的事务提交都会被阻塞。</p>
<p>在mysql 8.0 以后，对于备份，mysql可以直接使用备份锁。</p>
<p><strong>LOCK INSTANCE FOR BACKUP UNLOCK INSTANCE</strong></p>
<p>这个锁的作用范围更广，这个锁会阻止文件的创建，重命名，删除，包括 REPAIR TABLE TRUNCATE TABLE, OPTIMIZE TABLE操作以及账户的管理都会被阻塞。当然这些操作对于内存临时表来说是可以执行的，为什么内存表不受这些限制呢？因为内存表不需要备份，所以也就没必要满足这些条件。</p>
<h3 id="MySQL不同的存储引擎支持不同的锁机制"><a href="#MySQL不同的存储引擎支持不同的锁机制" class="headerlink" title="MySQL不同的存储引擎支持不同的锁机制"></a>MySQL不同的存储引擎支持不同的锁机制</h3><p>所有的存储引擎都以自己的方式显现了锁机制，服务器层完全不了解存储引擎中的锁实现：</p>
<ul>
<li><p>MyISAM、MEMORY、CSV存储引擎采用的是表级锁（table-level locking）</p>
</li>
<li><p>BDB(Berkeley DB) 存储引擎采用的是页面锁（page-level locking），但也支持表级锁</p>
</li>
<li><p>InnoDB 存储引擎既支持行级锁（row-level locking），也支持表级锁，但默认情况下是采用行级锁。</p>
</li>
<li><ul>
<li>InnoDB行锁是通过给索引上的索引项加锁来实现的，InnoDB这种行锁实现特点意味着：只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁！</li>
<li>行级锁都是基于索引的，如果一条SQL语句用不到索引是不会使用行级锁的，会使用表级锁。行级锁的缺点是：由于需要请求大量的锁资源，所以速度慢，内存消耗大。</li>
</ul>
</li>
</ul>
<p><strong>默认情况下，表锁和行锁都是自动获得的， 不需要额外的命令</strong>。</p>
<p>但是在有的情况下， 用户需要明确地进行锁表或者进行事务的控制， 以便确保整个事务的完整性，这样就需要使用事务控制和锁定语句来完成。</p>
<p><strong>InnoDB与MyISAM的最大不同有两点：一是支持事务（TRANSACTION）；二是采用了行级锁</strong>。</p>
<p>Innodb存储引擎由于实现了行级锁定，虽然在锁定机制的实现方面所带来的性能损耗可能比表级锁定会要更高一些，但是在整体并发处理能力方面要远远优于MyISAM的表级锁定的。当系统并发量较高的时候，Innodb的整体性能和MyISAM相比就会有比较明显的优势了。</p>
<p>但是，Innodb的行级锁定同样也有其脆弱的一面，当我们使用不当的时候，可能会让Innodb的整体性能表现不仅不能比MyISAM高，甚至可能会更差。</p>
<h2 id="InnoDB行级锁和表级锁"><a href="#InnoDB行级锁和表级锁" class="headerlink" title="InnoDB行级锁和表级锁"></a>InnoDB行级锁和表级锁</h2><h3 id="InnoDB锁模式"><a href="#InnoDB锁模式" class="headerlink" title="InnoDB锁模式"></a>InnoDB锁模式</h3><table>
<thead>
<tr>
<th>行锁类型</th>
<th>锁功能</th>
<th>锁兼容性</th>
<th>加锁</th>
<th>释放锁</th>
</tr>
</thead>
<tbody><tr>
<td>共享锁（读锁，S锁）</td>
<td>允许获取共享锁的事务读数据</td>
<td>与共享锁兼容，与排它锁不兼容</td>
<td>只有Serializable隔离级别会默认为读加共享锁；其他隔离级别下可以显式使用select…lock in share mode为读加共享锁</td>
<td>在事务提交或回滚后会自动释放锁；</td>
</tr>
<tr>
<td>排它锁（写锁，X锁）</td>
<td>允许获取排它锁的事务更新或删除数据</td>
<td>共享锁，排它锁都不兼容</td>
<td>在默认的Reapeatable Read隔离级别下，InnoDB会自动为增删改操作的行加排它锁；也可以显式使用select … for update为读加排它锁</td>
<td>同上</td>
</tr>
</tbody></table>
<p>InnoDB 实现了以下两种类型的行锁：</p>
<ul>
<li><strong>共享锁（S-shared</strong>）：允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁。</li>
<li><strong>排他锁（X-exclusive）</strong>：允许获得排他锁的事务更新数据，阻止其他事务取得相同数据集的共享读锁和排他写锁。</li>
</ul>
<p>为了支持在不同粒度上进行加锁操作(允许行锁和表锁共存，实现多粒度锁机制)，InnoDB 还有两种内部使用的意向锁（Intention Locks），这两种意向锁都是表锁：</p>
<ul>
<li><p><strong>意向共享锁（IS- intent share lock）</strong>事务想要获得一张表中某几行的共享锁</p>
<p>事务打算给数据行加行共享锁，事务在给一个数据行加共享锁前必须先取得该表的 IS 锁。</p>
</li>
<li><p><strong>意向排他锁（IX -intent exclusive lock）</strong>事务想要获得一张表中某几行的排他锁</p>
<p>事务打算给数据行加行排他锁，事务在给一个数据行加排他锁前必须先取得该表的 IX 锁。</p>
</li>
</ul>
<p>由于InnoDB存储引擎支持的是行级别的锁，因此意向锁其实不会阻塞除全表扫以外的任何请求。故表级意向锁与行级锁的兼容性如下所示</p>
<p><img data-src="%E9%94%81%E6%A8%A1%E5%BC%8F%E5%85%BC%E5%AE%B9.jpg" alt="锁模式兼容"></p>
<p>如果一个事务请求的锁模式与当前的锁兼容， InnoDB 就将请求的锁授予该事务； 反之， 如果两者不兼容，该事务就要等待锁释放</p>
<p><img data-src="mysql%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84.jpg" alt="mysql数据存储结构"></p>
<p>若将上锁的对象看成一棵树，那么对最下层的对象上锁，也就是对最细粒度的对象进行上锁，那么首先需要对粗粒度的对象上锁。例上图，如果需要对页上的记录r进行上X锁，那么分别需要对数据库A、表、页上意向锁IX，最后对记录r上X锁。若其中任何一个部分导致等待，那么该操作需要等待粗粒度锁的完成。举例来说，在对记录r加X锁之前，已经有事务对表1进行了S表锁，那么表1上已存在S锁，之后事务需要对记录r在表1上加上IX，由于不兼容，所以该事务需要等待表锁操作的完成。</p>
<h3 id="意向锁到底有什么作用？"><a href="#意向锁到底有什么作用？" class="headerlink" title="意向锁到底有什么作用？"></a>意向锁到底有什么作用？</h3><p><strong>Innodb的意向锁主要用户多粒度的锁并存的情况</strong>。比如事务A要在一个表上加S锁，如果表中的一行已被事务B加了X锁，那么该锁的申请也应被阻塞。如果表中的数据很多，逐行检查锁标志的开销将很大，系统的性能将会受到影响。为了解决这个问题，可以在表级上引入新的锁类型来表示其所属行的加锁情况，这就引出了“意向锁”的概念。</p>
<p>举个例子，如果表中记录1亿，事务A把其中有几条记录上了行锁了，这时事务B需要给这个表加表级锁，如果没有意向锁的话，那就要去表中查找这一亿条记录是否上锁了。如果存在意向锁，那么假如事务Ａ在更新一条记录之前，先加意向锁，再加Ｘ锁，事务B先检查该表上是否存在意向锁，存在的意向锁是否与自己准备加的锁冲突，如果有冲突，则等待直到事务Ａ释放，而无须逐条记录去检测。事务Ｂ更新表时，其实无须知道到底哪一行被锁了，它只要知道反正有一行被锁了就行了。</p>
<p><strong>主要作用是处理行锁和表锁之间的矛盾，能够显示“某个事务正在某一行上持有了锁，或者准备去持有锁“</strong></p>
<h3 id="InnoDB-行锁实现方式："><a href="#InnoDB-行锁实现方式：" class="headerlink" title="InnoDB 行锁实现方式："></a>InnoDB 行锁实现方式：</h3><p><strong>行锁是加在索引上的</strong></p>
<h4 id="聚集-主键-索引"><a href="#聚集-主键-索引" class="headerlink" title="聚集(主键)索引"></a>聚集(主键)索引</h4><p><img data-src="%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95.jpg" alt="聚集索引"></p>
<h4 id="辅助-普通-索引"><a href="#辅助-普通-索引" class="headerlink" title="辅助(普通)索引"></a>辅助(普通)索引</h4><p><img data-src="%E8%BE%85%E5%8A%A9%E7%B4%A2%E5%BC%95.jpg" alt="辅助索引"></p>
<p><strong>Innodb中的索引数据结构是 B+ 树，数据是有序排列的，从根节点到叶子节点一层层找到对应的数据</strong>。</p>
<p>普通索引，也叫做辅助索引，叶子节点存放的是主键值。主键上的索引叫做聚集索引，表里的每一条记录都存放在主键的叶子节点上。当通过辅助索引select 查询数据的时候，会先在辅助索引中找到对应的主键值，然后用主键值在聚集索引中找到该条记录。</p>
<p>举个例子，用name=Alice来查询的时候，会先找到对应的主键值是18 ，然后用18在下面的聚集索引中找到name=Alice的记录内容是 77 和 Alice。</p>
<p><strong>表中每一行的数据，是组织存放在聚集索引中的，所以叫做索引组织表</strong>。</p>
<ul>
<li><strong>InnoDB 行锁是通过给索引上的索引项加锁来实现的</strong>，这一点 MySQL 与 Oracle 不同，后者是通过在数据块中对相应数据行加锁来实现的。InnoDB 这种行锁实现特点意味着：只有通过索引条件检索数据，InnoDB 才使用行级锁，否则，InnoDB 将使用表锁！</li>
<li><strong>不论是使用主键索引、唯一索引或普通索引，InnoDB 都会使用行锁来对数据加锁</strong>。</li>
<li><strong>只有执行计划真正使用了索引，才能使用行锁</strong>：即便在条件中使用了索引字段，但是否使用索引来检索数据是由 MySQL 通过判断不同执行计划的代价来决定的，如果 MySQL 认为全表扫描效率更高，比如对一些很小的表，它就不会使用索引，这种情况下 InnoDB 将使用表锁，而不是行锁。因此，在分析锁冲突时，别忘了检查 SQL 的执行计划（可以通过 explain 检查 SQL 的执行计划），以确认是否真正使用了索引。（更多阅读：<a href="https://link.zhihu.com/?target=http%3A//mp.weixin.qq.com/s/h4B84UmzAUJ81iBY_FXNOg">MySQL索引总结</a>）</li>
<li><strong>由于 MySQL 的行锁是针对索引加的锁，不是针对记录加的锁，所以虽然多个session是访问不同行的记录， 但是如果是使用相同的索引键， 是会出现锁冲突的</strong>（后使用这些索引的session需要等待先使用索引的session释放锁后，才能获取锁）。 应用设计的时候要注意这一点。</li>
</ul>
<h3 id="行锁的算法（算法维度）"><a href="#行锁的算法（算法维度）" class="headerlink" title="行锁的算法（算法维度）"></a>行锁的算法（算法维度）</h3><h4 id="记录锁-Record-Lock"><a href="#记录锁-Record-Lock" class="headerlink" title="记录锁(Record Lock)"></a>记录锁(Record Lock)</h4><p>事务加锁后锁住的只是表的某一条记录。</p>
<p><img data-src="%E8%AE%B0%E5%BD%95%E9%94%81.jpg" alt="记录锁"></p>
<p><strong>记录锁出现条件：</strong>精准条件命中，并且命中的条件字段是唯一索引；</p>
<p>例如：update user_info set name=’张三’ where id=1 ,这里的id是唯一索引。</p>
<p>Record Lock总是会去锁住索引记录，如果InnoDB存储引擎表在建立的时候没有设置任何一个索引，那么这时InnoDB存储引擎会使用隐式的主键来进行锁定。</p>
<p><strong>记录锁的作用</strong>：加了记录锁之后可以避免数据在查询的时候被修改的重复读问题，也避免了在修改的事务未提交前被其他事务读取的脏读问题。</p>
<h4 id="间隙锁-gap-lcok-："><a href="#间隙锁-gap-lcok-：" class="headerlink" title="间隙锁(gap lcok )："></a>间隙锁(gap lcok )：</h4><p><strong>当我们用范围条件而不是相等条件检索数据，并请求共享或排他锁时，InnoDB会给符合条件的已有数据记录的索引项加锁；对于键值在条件范围内但并不存在的记录，叫做“间隙（GAP)”，InnoDB也会对这个“间隙”加锁，这种锁机制就是所谓的间隙锁</strong>。</p>
<h5 id="间隙锁的目的："><a href="#间隙锁的目的：" class="headerlink" title="间隙锁的目的："></a>间隙锁的目的：</h5><ol>
<li>防止幻读，以满足相关隔离级别的要求；</li>
<li>满足恢复和复制的需要：</li>
</ol>
<h5 id="产生间隙锁的条件（RR事务隔离级别下）："><a href="#产生间隙锁的条件（RR事务隔离级别下）：" class="headerlink" title="产生间隙锁的条件（RR事务隔离级别下）："></a>产生间隙锁的条件（RR事务隔离级别下）：</h5><ol>
<li>使用普通索引锁定；</li>
<li>使用多列唯一索引；</li>
<li>使用唯一索引锁定多行记录。</li>
</ol>
<p>以上情况，都会产生间隙锁</p>
<p>MySQL 通过 BINLOG 录入执行成功的 INSERT、UPDATE、DELETE 等更新数据的 SQL 语句，并由此实现 MySQL 数据库的恢复和主从复制。MySQL 的恢复机制（复制其实就是在 Slave Mysql 不断做基于 BINLOG 的恢复）有以下特点：</p>
<ul>
<li>一是 MySQL 的恢复是 SQL 语句级的，也就是重新执行 BINLOG 中的 SQL 语句。</li>
<li>二是 MySQL 的 Binlog 是按照事务提交的先后顺序记录的， 恢复也是按这个顺序进行的。</li>
</ul>
<p>由此可见，<strong>MySQL 的恢复机制要求：在一个事务未提交前，其他并发事务不能插入满足其锁定条件的任何记录，也就是不允许出现幻读</strong>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#查看间隙锁是否禁用</span><br><span class="line">show variables like &#39;innodb_locks_unsafe_for_binlog&#39;;</span><br></pre></td></tr></table></figure>

<p><code>innodb_locks_unsafe_for_binlog</code>：默认值为OFF，即启用间隙锁。因为此参数是只读模式，如果想要禁用间隙锁，需要修改 my.cnf（windows是my.ini） 重新启动才行。</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在 my.cnf 里面的[mysqld]添加</span></span><br><span class="line"><span class="attr">[mysqld]</span></span><br><span class="line"><span class="attr">innodb_locks_unsafe_for_binlog</span> = <span class="string">1</span></span><br></pre></td></tr></table></figure>

<h4 id="临键锁-Next-Key-Lock"><a href="#临键锁-Next-Key-Lock" class="headerlink" title="临键锁(Next-Key Lock)"></a>临键锁(Next-Key Lock)</h4><p>临键锁是InnoDB的行锁默认算法，它是记录锁和间隙锁的组合，临键锁会把查询出来的记录锁住，同时也会把该范围查询内的所有间隙空间也会锁住，再之它会把相邻的下一个区间也会锁住。</p>
<p><strong>临键锁出现条件：</strong>范围查询并命中，查询命中了索引。</p>
<p>比如下面表的数据执行 select * from user_info where id&gt;1 and id&lt;=13 for update ;</p>
<p>会锁住ID为 1,5,10的记录；同时会锁住，1至5,5至10,10至15的区间。</p>
<p><strong>临键锁的作用</strong>：结合记录锁和间隙锁的特性，临键锁避免了在范围查询时出现脏读、重复读、幻读问题。加了临键锁之后，在范围区间内数据不允许被修改和插入。</p>
<p>Next-Key Lock是结合了Gap Lock和Record Lock的一种锁定算法，在Next-Key Lock算法下，InnoDB对于行的查询都是采用这种锁定算法。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><table>
<thead>
<tr>
<th>行锁算法</th>
<th>锁定内容</th>
</tr>
</thead>
<tbody><tr>
<td>Record lock</td>
<td>记录锁，锁定一个行记录</td>
</tr>
<tr>
<td>Gap lock</td>
<td>间隙锁，锁定一个区间，但不包含锁定记录</td>
</tr>
<tr>
<td>Next-Key lock</td>
<td>记录锁+间隙锁，锁定行记录+区间，MySql 防止幻读，就是使用此锁实现</td>
</tr>
</tbody></table>
<p>记录锁、间隙锁、临键锁都是排它锁</p>
<p>InnoDB所有的行锁算法都是基于<strong>索引实现</strong>的，锁定的也都是索引或索引区间；</p>
<p>不同的事务隔离级别、不同的索引类型、是否为等值查询，使用的行锁算法也会有所不同；下面仅以InnoDB默认的RR隔离级别、等值查询为例，介绍几种行锁算法：</p>
<table>
<thead>
<tr>
<th>等值查询使用的索引类型</th>
<th>锁定内容</th>
</tr>
</thead>
<tbody><tr>
<td>主键（聚簇索引）</td>
<td>对聚簇索引记录+Record Lock</td>
</tr>
<tr>
<td>唯一索引</td>
<td>对辅助索引记录+Record Lock；<br />对聚簇索引记录+Record Lock</td>
</tr>
<tr>
<td>普通索引</td>
<td>对聚簇索引记录+Record Lock；<br />对相关辅助索引+Next-Key lock</td>
</tr>
<tr>
<td>不适用索引</td>
<td>对聚簇索引全表+Next-Key lock</td>
</tr>
</tbody></table>
<h3 id="InnoDB加锁方法："><a href="#InnoDB加锁方法：" class="headerlink" title="InnoDB加锁方法："></a>InnoDB加锁方法：</h3><ul>
<li><p><strong>意向锁是 InnoDB 自动加的， 不需用户干预</strong>。</p>
</li>
<li><p><strong>对于 UPDATE、 DELETE 和 INSERT 语句， InnoDB 会自动给涉及数据集加排他锁（X)</strong>；</p>
</li>
<li><p><strong>对于普通 SELECT 语句，InnoDB 不会加任何锁</strong>；</p>
<p>事务可以通过以下语句显式给记录集加共享锁或排他锁：</p>
</li>
<li><ul>
<li>共享锁（S）：SELECT * FROM table_name WHERE … LOCK IN SHARE MODE。 其他 session 仍然可以查询记录，并也可以对该记录加 share mode 的共享锁。但是如果当前事务需要对该记录进行更新操作，则很有可能造成死锁。</li>
<li>排他锁（X）：SELECT * FROM table_name WHERE … FOR UPDATE。其他 session 可以查询该记录，但是不能对该记录加共享锁或排他锁，而是等待获得锁</li>
</ul>
</li>
</ul>
<h4 id="隐式锁定："><a href="#隐式锁定：" class="headerlink" title="隐式锁定："></a>隐式锁定：</h4><p>InnoDB在事务执行过程中，使用两阶段锁协议：</p>
<ul>
<li>随时都可以执行锁定，InnoDB会根据隔离级别在需要的时候自动加锁；</li>
<li>锁只有在执行commit或者rollback的时候才会释放，并且所有的锁都是在同一时刻被释放。</li>
</ul>
<h4 id="显式锁定-："><a href="#显式锁定-：" class="headerlink" title="显式锁定 ："></a>显式锁定 ：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select ... lock in share mode &#x2F;&#x2F;共享锁 </span><br><span class="line">select ... for update &#x2F;&#x2F;排他锁</span><br></pre></td></tr></table></figure>

<h4 id="for-update-和-lock-in-share-mode-的区别："><a href="#for-update-和-lock-in-share-mode-的区别：" class="headerlink" title="for update 和 lock in share mode 的区别："></a>for update 和 lock in share mode 的区别：</h4><p>前一个上的是排他锁（X 锁），一旦一个事务获取了这个锁，其他的事务是没法在这些数据上执行 for update ；后一个是共享锁，多个事务可以同时的对相同数据执行 lock in share mode。</p>
<h3 id="显式锁定对性能影响-performance-impact-："><a href="#显式锁定对性能影响-performance-impact-：" class="headerlink" title="显式锁定对性能影响(performance impact)："></a>显式锁定对性能影响(performance impact)：</h3><p>select for update 语句，相当于一个 update 语句。在业务繁忙的情况下，如果事务没有及时的commit或者rollback 可能会造成其他事务长时间的等待，从而影响数据库的并发使用效率。</p>
<p>select lock in share mode 语句是一个给查找的数据上一个共享锁（S 锁）的功能，它允许其他的事务也对该数据上S锁，但是不能够允许对该数据进行修改。如果不及时的commit 或者rollback 也可能会造成大量的事务等待。</p>
<h3 id="InnoDB-在不同隔离级别下的一致性读及锁的差异："><a href="#InnoDB-在不同隔离级别下的一致性读及锁的差异：" class="headerlink" title="InnoDB 在不同隔离级别下的一致性读及锁的差异："></a>InnoDB 在不同隔离级别下的一致性读及锁的差异：</h3><p>锁和多版本数据（MVCC）是 InnoDB 实现一致性读和 ISO/ANSI SQL92 隔离级别的手段。</p>
<p>因此，在不同的隔离级别下，InnoDB 处理 SQL 时采用的一致性读策略和需要的锁是不同的：</p>
<p><img data-src="InnoDB%E4%B8%8D%E5%90%8C%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E4%B8%8B%E9%94%81%E6%AF%94%E8%BE%831.jpg" alt="InnoDB不同隔离级别下锁比较1"></p>
<p><img data-src="InnoDB%E4%B8%8D%E5%90%8C%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E4%B8%8B%E9%94%81%E6%AF%94%E8%BE%832.jpg" alt="InnoDB不同隔离级别下锁比较2"></p>
<p>对于许多 SQL，隔离级别越高，InnoDB 给记录集加的锁就越严格（尤其是使用范围条件的时候），产生锁冲突的可能性也就越高，从而对并发性事务处理性能的 影响也就越大。</p>
<h3 id="InnoDB-行锁优化建议"><a href="#InnoDB-行锁优化建议" class="headerlink" title="InnoDB 行锁优化建议"></a>InnoDB 行锁优化建议</h3><p>合理利用 InnoDB 的行级锁定，做到扬长避短</p>
<ol>
<li>尽可能让所有的数据检索都通过索引来完成，从而避免 InnoDB 因为无法通过索引键加锁而升级为表级锁定。</li>
<li>合理设计索引，让 InnoDB 在索引键上面加锁的时候尽可能准确，尽可能的缩小锁定范围，避免造成不必要的锁定而影响其他 Query 的执行。</li>
<li>尽可能减少基于范围的数据检索过滤条件，避免因为间隙锁带来的负面影响而锁定了不该锁定的记录。</li>
<li>尽量控制事务的大小，减少锁定的资源量和锁定时间长度。</li>
<li>在业务环境允许的情况下，尽量使用较低级别的事务隔离，以减少 MySQL 因为实现事务隔离级别所带来的附加成本。</li>
</ol>
<h3 id="InnoDB什么时候加表锁"><a href="#InnoDB什么时候加表锁" class="headerlink" title="InnoDB什么时候加表锁"></a>InnoDB什么时候加表锁</h3><p>对于 InnoDB 表，在绝大部分情况下都应该使用行级锁，因为事务和行锁往往是我们之所以选择 InnoDB 表的理由。</p>
<p>事务需要更新大部分或全部数据，表又比较大，如果使用默认的行锁，不仅这个事务执行效率低，而且可能造成其他事务长时间锁等待和锁冲突，这种情况下可以考虑使用表锁来提高该事务的执行速度。</p>
<p>事务涉及多个表，比较复杂，很可能引起死锁，造成大量事务回滚。这种情况也可以考虑一次性锁定事务涉及的表，从而避免死锁、减少数据库因事务回滚带来的开销。</p>
<p>在 InnoDB 下，使用表锁要注意以下两点：</p>
<ol>
<li>使用 LOCK TABLES 虽然可以给 InnoDB 加表级锁，但必须说明的是，表锁不是由 InnoDB 存储引擎层管理的，而是由其上一层──MySQL Server 负责的。仅当 autocommit=0（不自动提交，默认是自动提交的）、InnoDB_table_locks=1（默认设置）时，InnoDB 层才能知道 MySQL 加的表锁，MySQL Server 也才能感知 InnoDB 加的行锁。这种情况下，InnoDB 才能自动识别涉及表级锁的死锁，否则，InnoDB 将无法自动检测并处理这种死锁。</li>
<li>在用 LOCK TABLES 对 InnoDB 表加锁时要注意，要将 AUTOCOMMIT 设为 0，否则 MySQL 不会给表加锁。事务结束前，不要用 UNLOCK TABLES 释放表锁，因为 UNLOCK TABLES 会隐含地提交事务。COMMIT 或 ROLLBACK 并不能释放用 LOCK TABLES 加的表级锁，必须用 UNLOCK TABLES 释放表锁。</li>
</ol>
<p>正确的方式见如下语句，例如，如果需要写表 t1 并从表 t 读，可以按如下做：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SET AUTOCOMMIT&#x3D;0;</span><br><span class="line">LOCK TABLES t1 WRITE, t2 READ, ...;</span><br><span class="line">[do something with tables t1 and t2 here];</span><br><span class="line">COMMIT;</span><br><span class="line">UNLOCK TABLES;</span><br></pre></td></tr></table></figure>

<h2 id="MyISAM-表锁"><a href="#MyISAM-表锁" class="headerlink" title="MyISAM 表锁"></a>MyISAM 表锁</h2><h3 id="MyISAM表级锁模式："><a href="#MyISAM表级锁模式：" class="headerlink" title="MyISAM表级锁模式："></a>MyISAM表级锁模式：</h3><ul>
<li><strong>表共享读锁 （Table Read Lock）</strong>：不会阻塞其他用户对同一表的读请求，但会阻塞对同一表的写请求；</li>
<li><strong>表独占写锁 （Table Write Lock）</strong>：会阻塞其他用户对同一表的读和写操作；</li>
</ul>
<p><strong>MyISAM 表的读操作与写操作之间，以及写操作之间是串行的</strong>。当一个线程获得对一个表的写锁后， 只有持有锁的线程可以对表进行更新操作。 其他线程的读、 写操作都会等待，直到锁被释放为止。</p>
<p>默认情况下，<strong>写锁比读锁具有更高的优先级</strong>：当一个锁释放时，这个锁会优先给写锁队列中等候的获取锁请求，然后再给读锁队列中等候的获取锁请求。 （This ensures that updates to a table are not “starved” even when there is heavy SELECT activity for the table. However, if there are many updates for a table, SELECT statements wait until there are no more updates.）。</p>
<p>这也正是 MyISAM 表不太适合于有大量更新操作和查询操作应用的原因，因为，大量的更新操作会造成查询操作很难获得读锁，从而可能永远阻塞。同时，一些需要长时间运行的查询操作，也会使写线程“饿死” ，应用中应尽量避免出现长时间运行的查询操作（在可能的情况下可以通过使用中间表等措施对SQL语句做一定的“分解” ，使每一步查询都能在较短时间完成，从而减少锁冲突。如果复杂查询不可避免，应尽量安排在数据库空闲时段执行，比如一些定期统计可以安排在夜间执行）。</p>
<p>可以设置改变读锁和写锁的优先级：</p>
<ul>
<li>通过指定启动参数low-priority-updates，使MyISAM引擎默认给予读请求以优先的权利。</li>
<li>通过执行命令SET LOW_PRIORITY_UPDATES=1，使该连接发出的更新请求优先级降低。</li>
<li>通过指定INSERT、UPDATE、DELETE语句的LOW_PRIORITY属性，降低该语句的优先级。</li>
<li>给系统参数max_write_lock_count设置一个合适的值，当一个表的读锁达到这个值后，MySQL就暂时将写请求的优先级降低，给读进程一定获得锁的机会。</li>
</ul>
<h3 id="MyISAM加表锁方法："><a href="#MyISAM加表锁方法：" class="headerlink" title="MyISAM加表锁方法："></a>MyISAM加表锁方法：</h3><ul>
<li>在执行查询语句（SELECT）前，会自动给涉及的表加读锁</li>
<li>在执行更新操作（UPDATE、DELETE、INSERT 等）前，会自动给涉及的表加写锁</li>
</ul>
<p>这个过程并不需要用户干预，因此，用户一般不需要直接用 LOCK TABLE 命令给 MyISAM 表显式加锁。</p>
<p><strong>在自动加锁的情况下，MyISAM 总是一次获得 SQL 语句所需要的全部锁，这也正是 MyISAM 表不会出现死锁（Deadlock Free）的原因</strong>。</p>
<p>MyISAM存储引擎支持并发插入，以减少锁定表的读和写操作之间的争用：</p>
<p>如果MyISAM表在数据文件中间没有空闲块，则行始终插入数据文件的末尾。 在这种情况下，你可以自由混合并发使用MyISAM表的INSERT和SELECT语句而不需要加锁——你可以在其他线程进行读操作的时候，同时将行插入到MyISAM表中。 文件中间的空闲块可能是从表格中间删除或更新的行而产生的。 如果文件中间有空闲快，则并发插入会被禁用，但是当所有空闲块都填充有新数据时，它又会自动重新启用。 要控制此行为，可以使用MySQL的concurrent_insert系统变量。</p>
<p>如果你使用LOCK TABLES显式获取表锁，则可以请求READ LOCAL锁而不是READ锁，以便在锁定表时，其他会话可以使用并发插入。</p>
<ul>
<li>当concurrent_insert设置为0时，不允许并发插入。</li>
<li>当concurrent_insert设置为1时，如果MyISAM表中没有空洞（即表的中间没有被删除的行），MyISAM允许在一个线程读表的同时，另一个线程从表尾插入记录。这也是MySQL的默认设置。</li>
<li>当concurrent_insert设置为2时，无论MyISAM表中有没有空洞，都允许在表尾并发插入记录。</li>
</ul>
<p>显示锁sql语句</p>
<ul>
<li>共享读锁：lock table tableName read</li>
<li>独占写锁：lock table tableName write</li>
<li>同时加多锁：lock table t1 write，t2 read</li>
<li>批量解锁：unlock tables</li>
</ul>
<h3 id="MyISAM-表锁优化建议"><a href="#MyISAM-表锁优化建议" class="headerlink" title="MyISAM 表锁优化建议"></a>MyISAM 表锁优化建议</h3><h4 id="缩短锁定时间"><a href="#缩短锁定时间" class="headerlink" title="缩短锁定时间"></a>缩短锁定时间</h4><ol>
<li>唯一的办法就是让我们的 Query 执行时间尽可能的短</li>
<li>尽量减少大的复杂 Query，将复杂 Query 分拆成几个小的 Query 分布进行。</li>
<li>尽可能的建立足够高效的索引，让数据检索更迅速。</li>
<li>尽量让 MyISAM 存储引擎的表只存放必要的信息，控制字段类型。</li>
<li>利用合适的机会优化 MyISAM 表数据文件。</li>
</ol>
<h4 id="分离能并行的操作"><a href="#分离能并行的操作" class="headerlink" title="分离能并行的操作"></a>分离能并行的操作</h4><p>MyISAM 存储引擎有一个控制是否打开 Concurrent Insert 功能的参数选项：</p>
<ul>
<li>concurrent_insert=2，无论 MyISAM 表中有没有空洞，都允许在表尾并发插入记录。</li>
<li>concurrent_insert=1，如果 MyISAM 表中没有空洞（即表的中间没有被删除的行），MyISAM 允许在一个进程读表的同时，另一个进程从表尾插入记录。这也是 MySQL 的默认设置。</li>
<li>concurrent_insert=0，不允许并发插入</li>
</ul>
<p>可以利用 MyISAM 存储引擎的并发插入特性，来解决应用中对同一表查询和插入的锁争用。</p>
<p>例如，将 concurrent_insert 系统变量设为 2，总是允许并发插入；同时，通过定期在系统空闲时段执行 OPTIMIZE TABLE 语句来整理空间碎片，收回因删除记录而产生的中间空洞。</p>
<h3 id="合理利用读写优先级"><a href="#合理利用读写优先级" class="headerlink" title="合理利用读写优先级"></a>合理利用读写优先级</h3><ol>
<li>通过执行命令 SET LOW_PRIORITY_UPDATES=1，使该连接读比写的优先级高，如果我们的系统是一个以读为主，可以设置此参数，如果以写为主，则不用设置。</li>
<li>通过指定 INSERT、UPDATE、DELETE 语句的 LOW_PRIORITY 属性，降低该语句的优先级。</li>
<li>MySQL 也提供了一种折中的办法来调节读写冲突，即给系统参数 max_write_lock_count 设置一个合适的值，当一个表的读锁达到这个值后，MySQL 就暂时将写请求的优先级降低，给读进程一定获得锁的机会。</li>
<li>需要长时间运行的查询操作，也会使写进程“饿死”，尽量避免出现长时间运行的查询操作，不要总想用一条 SELECT 语句来解决问题，因为这种看似巧妙的 SQL 语句，往往比较复杂，执行时间较长。</li>
<li>多表级联。事务涉及多个表，比较复杂的关联查询，很可能引起死锁，造成大量事务回滚，这种情况若能一次性锁定事务涉及的表，从而可以避免死锁、减少数据库因事务回滚带来的开销。</li>
</ol>
<h2 id="死锁（Deadlock-Free）"><a href="#死锁（Deadlock-Free）" class="headerlink" title="死锁（Deadlock Free）"></a>死锁（Deadlock Free）</h2><ul>
<li><p><strong>死锁产生：</strong></p>
</li>
<li><ul>
<li>死锁是指两个或多个事务在同一资源上相互占用，并请求锁定对方占用的资源，从而导致恶性循环。</li>
<li>当事务试图以不同的顺序锁定资源时，就可能产生死锁。多个事务同时锁定同一个资源时也可能会产生死锁。</li>
<li>锁的行为和顺序和存储引擎相关。以同样的顺序执行语句，有些存储引擎会产生死锁有些不会——死锁有双重原因：真正的数据冲突；存储引擎的实现方式。</li>
</ul>
</li>
<li><p><strong>检测死锁：</strong>数据库系统实现了各种死锁检测和死锁超时的机制。InnoDB存储引擎能检测到死锁的循环依赖并立即返回一个错误。</p>
</li>
<li><p><strong>死锁恢复：</strong>死锁发生以后，只有部分或完全回滚其中一个事务，才能打破死锁，InnoDB目前处理死锁的方法是，将持有最少行级排他锁的事务进行回滚。所以事务型应用程序在设计时必须考虑如何处理死锁，多数情况下只需要重新执行因死锁回滚的事务即可。</p>
</li>
<li><p><strong>外部锁的死锁检测：</strong>发生死锁后，InnoDB 一般都能自动检测到，并使一个事务释放锁并回退，另一个事务获得锁，继续完成事务。但在涉及外部锁，或涉及表锁的情况下，InnoDB 并不能完全自动检测到死锁， 这需要通过设置锁等待超时参数 innodb_lock_wait_timeout 来解决</p>
</li>
<li><p><strong>死锁影响性能：</strong>死锁会影响性能而不是会产生严重错误，因为InnoDB会自动检测死锁状况并回滚其中一个受影响的事务。在高并发系统上，当许多线程等待同一个锁时，死锁检测可能导致速度变慢。 有时当发生死锁时，禁用死锁检测（使用innodb_deadlock_detect配置选项）可能会更有效，这时可以依赖innodb_lock_wait_timeout设置进行事务回滚。</p>
</li>
</ul>
<h3 id="MyISAM避免死锁："><a href="#MyISAM避免死锁：" class="headerlink" title="MyISAM避免死锁："></a>MyISAM避免死锁：</h3><p><strong>在自动加锁的情况下，MyISAM 表不会出现死锁</strong>(MyISAM 总是一次获得 SQL 语句所需要的全部锁)。</p>
<h3 id="InnoDB避免死锁："><a href="#InnoDB避免死锁：" class="headerlink" title="InnoDB避免死锁："></a>InnoDB避免死锁：</h3><ul>
<li>为了在单个InnoDB表上执行多个并发写入操作时避免死锁，可以在事务开始时通过为预期要修改的每个元祖（行）使用SELECT … FOR UPDATE语句来获取必要的锁，即使这些行的更改语句是在之后才执行的。</li>
<li>在事务中，如果要更新记录，应该直接申请足够级别的锁，即排他锁，而不应先申请共享锁、更新时再申请排他锁，因为这时候当用户再申请排他锁时，其他事务可能又已经获得了相同记录的共享锁，从而造成锁冲突，甚至死锁</li>
<li>如果事务需要修改或锁定多个表，则应在每个事务中以相同的顺序使用加锁语句。 在应用中，如果不同的程序会并发存取多个表，应尽量约定以相同的顺序来访问表，这样可以大大降低产生死锁的机会</li>
<li>通过SELECT … LOCK IN SHARE MODE获取行的读锁后，如果当前事务再需要对该记录进行更新操作，则很有可能造成死锁。</li>
<li>改变事务隔离级别，如降低隔离级别（如果业务允许，将隔离级别调低也是较好的选择，比如将隔离级别从RR调整为RC，可以避免掉很多因为gap锁造成的死锁）</li>
<li>为表添加合理的索引。可以看到如果不走索引将会为表的每一行记录添加上锁，死锁的概率大大增大。</li>
</ul>
<p>如果出现死锁，可以用 SHOW INNODB STATUS 命令来确定最后一个死锁产生的原因。返回结果中包括死锁相关事务的详细信息，如引发死锁的 SQL 语句，事务已经获得的锁，正在等待什么锁，以及被回滚的事务等。据此可以分析死锁产生的原因和改进措施。</p>
<h3 id="MyISAM避免死锁：-1"><a href="#MyISAM避免死锁：-1" class="headerlink" title="MyISAM避免死锁："></a>MyISAM避免死锁：</h3><p><strong>在自动加锁的情况下，MyISAM 表不会出现死锁</strong>(MyISAM 总是一次获得 SQL 语句所需要的全部锁)。</p>
<h3 id="InnoDB避免死锁：-1"><a href="#InnoDB避免死锁：-1" class="headerlink" title="InnoDB避免死锁："></a>InnoDB避免死锁：</h3><ul>
<li>为了在单个InnoDB表上执行多个并发写入操作时避免死锁，可以在事务开始时通过为预期要修改的每个元祖（行）使用SELECT … FOR UPDATE语句来获取必要的锁，即使这些行的更改语句是在之后才执行的。</li>
<li>在事务中，如果要更新记录，应该直接申请足够级别的锁，即排他锁，而不应先申请共享锁、更新时再申请排他锁，因为这时候当用户再申请排他锁时，其他事务可能又已经获得了相同记录的共享锁，从而造成锁冲突，甚至死锁</li>
<li>如果事务需要修改或锁定多个表，则应在每个事务中以相同的顺序使用加锁语句。 在应用中，如果不同的程序会并发存取多个表，应尽量约定以相同的顺序来访问表，这样可以大大降低产生死锁的机会</li>
<li>通过SELECT … LOCK IN SHARE MODE获取行的读锁后，如果当前事务再需要对该记录进行更新操作，则很有可能造成死锁。</li>
<li>改变事务隔离级别，如降低隔离级别（如果业务允许，将隔离级别调低也是较好的选择，比如将隔离级别从RR调整为RC，可以避免掉很多因为gap锁造成的死锁）</li>
<li>为表添加合理的索引。可以看到如果不走索引将会为表的每一行记录添加上锁，死锁的概率大大增大。</li>
</ul>
<p>如果出现死锁，可以用 SHOW INNODB STATUS 命令来确定最后一个死锁产生的原因。返回结果中包括死锁相关事务的详细信息，如引发死锁的 SQL 语句，事务已经获得的锁，正在等待什么锁，以及被回滚的事务等。据此可以分析死锁产生的原因和改进措施。</p>
<h2 id="死锁案例"><a href="#死锁案例" class="headerlink" title="死锁案例"></a>死锁案例</h2><h3 id="不同表相同记录行锁冲突"><a href="#不同表相同记录行锁冲突" class="headerlink" title="不同表相同记录行锁冲突"></a>不同表相同记录行锁冲突</h3><p>这种情况很好理解，事务A和事务B操作两张表，但出现循环等待锁情况。</p>
<h3 id="相同表记录行锁冲突"><a href="#相同表记录行锁冲突" class="headerlink" title="相同表记录行锁冲突"></a>相同表记录行锁冲突</h3><p>这种情况比较常见，之前遇到两个job在执行数据批量更新时，jobA处理的的id列表为[1,2,3,4]，而job处理的id列表为[8,9,10,4,2]，这样就造成了死锁。</p>
<h3 id="不同索引锁冲突"><a href="#不同索引锁冲突" class="headerlink" title="不同索引锁冲突"></a>不同索引锁冲突</h3><p>这种情况比较隐晦，事务A在执行时，除了在二级索引加锁外，还会在聚簇索引上加锁，在聚簇索引上加锁的顺序是[1,4,2,3,5]，而事务B执行时，只在聚簇索引上加锁，加锁顺序是[1,2,3,4,5]，这样就造成了死锁的可能性。</p>
<h3 id="gap锁冲突"><a href="#gap锁冲突" class="headerlink" title="gap锁冲突"></a>gap锁冲突</h3><p>innodb在RR级别下，如下的情况也会产生死锁，比较隐晦。不清楚的同学可以自行根据上节的gap锁原理分析下。</p>
<p>结论：<strong>在MySQL/InnoDB中，所谓的读不加锁，并不适用于所有的情况，而是隔离级别相关的。Serializable隔离级别，读不加锁就不再成立，所有的读操作，都是当前读</strong>。</p>
<h2 id="一些优化锁性能的建议"><a href="#一些优化锁性能的建议" class="headerlink" title="一些优化锁性能的建议"></a>一些优化锁性能的建议</h2><ul>
<li><p>尽量使用较低的隔离级别；</p>
</li>
<li><p>精心设计索引， 并尽量使用索引访问数据， 使加锁更精确， 从而减少锁冲突的机会</p>
</li>
<li><p>选择合理的事务大小，小事务发生锁冲突的几率也更小</p>
</li>
<li><p>给记录集显示加锁时，最好一次性请求足够级别的锁。比如要修改数据的话，最好直接申请排他锁，而不是先申请共享锁，修改时再请求排他锁，这样容易产生死锁</p>
</li>
<li><p>不同的程序访问一组表时，应尽量约定以相同的顺序访问各表，对一个表而言，尽可能以固定的顺序存取表中的行。这样可以大大减少死锁的机会</p>
</li>
<li><p>尽量用相等条件访问数据，这样可以避免间隙锁对并发插入的影响</p>
</li>
<li><p>不要申请超过实际需要的锁级别</p>
</li>
<li><p>除非必须，查询时不要显示加锁。 MySQL的MVCC可以实现事务中的查询不用加锁，优化事务性能；MVCC只在COMMITTED READ（读提交）和REPEATABLE READ（可重复读）两种隔离级别下工作</p>
</li>
<li><p>对于一些特定的事务，可以使用表锁来提高处理速度或减少死锁的可能</p>
</li>
</ul>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>锁</tag>
        <tag>死锁</tag>
      </tags>
  </entry>
  <entry>
    <title>商城实战</title>
    <url>/blog/2022/05/01/%E5%95%86%E5%9F%8E/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/blog/assets/css/APlayer.min.css"><script src="/blog/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="商城"><a href="#商城" class="headerlink" title="商城"></a>商城</h1><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><h3 id="安装Oracle-VM-VirtualBox虚拟机"><a href="#安装Oracle-VM-VirtualBox虚拟机" class="headerlink" title="安装Oracle VM VirtualBox虚拟机"></a>安装<a href="https://www.virtualbox.org/" target="_blank" rel="noopener">Oracle VM VirtualBox</a>虚拟机</h3><p><a href="https://www.virtualbox.org/wiki/Downloads" target="_blank" rel="noopener">下载地址</a></p>
<h3 id="安装Vagrant"><a href="#安装Vagrant" class="headerlink" title="安装Vagrant"></a>安装<a href="https://www.vagrantup.com/" target="_blank" rel="noopener">Vagrant</a></h3><p><a href="https://www.vagrantup.com/downloads" target="_blank" rel="noopener">下载地址</a></p>
<h3 id="安装Docker"><a href="#安装Docker" class="headerlink" title="安装Docker"></a>安装<a href="https://www.docker.com/" target="_blank" rel="noopener">Docker</a></h3><p><a href="https://docs.docker.com/get-docker/" target="_blank" rel="noopener">文档地址</a></p>
<a id="more"></a>

<h4 id="卸载旧版本"><a href="#卸载旧版本" class="headerlink" title="卸载旧版本"></a>卸载旧版本</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo yum remove docker \</span></span><br><span class="line">                  docker-client \</span><br><span class="line">                  docker-client-latest \</span><br><span class="line">                  docker-common \</span><br><span class="line">                  docker-latest \</span><br><span class="line">                  docker-latest-logrotate \</span><br><span class="line">                  docker-logrotate \</span><br><span class="line">                  docker-engine</span><br></pre></td></tr></table></figure>

<h4 id="设置存储库"><a href="#设置存储库" class="headerlink" title="设置存储库"></a>设置存储库</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo yum install -y yum-utils</span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo yum-config-manager \</span></span><br><span class="line">    --add-repo \</span><br><span class="line">    https://download.docker.com/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure>

<h4 id="安装Docker引擎-此处下载较慢可查看下一节阿里云加速"><a href="#安装Docker引擎-此处下载较慢可查看下一节阿里云加速" class="headerlink" title="安装Docker引擎(此处下载较慢可查看下一节阿里云加速)"></a>安装Docker引擎(此处下载较慢可查看下一节阿里云加速)</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo yum install docker-ce docker-ce-cli containerd.io</span></span><br><span class="line"><span class="meta">#</span><span class="bash">启动docker</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo systemctl start docker</span></span><br><span class="line"><span class="meta">#</span><span class="bash">查看docker版本</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker -v</span></span><br><span class="line"><span class="meta">#</span><span class="bash">设置docker开机自启</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo systemctl <span class="built_in">enable</span> docker</span></span><br></pre></td></tr></table></figure>

<h4 id="配置阿里云镜像加速"><a href="#配置阿里云镜像加速" class="headerlink" title="配置阿里云镜像加速"></a>配置阿里云镜像加速</h4><p>加速器地址：<a href="https://t92zxvdg.mirror.aliyuncs.com" target="_blank" rel="noopener">https://t92zxvdg.mirror.aliyuncs.com</a></p>
<h5 id="安装／升级Docker客户端"><a href="#安装／升级Docker客户端" class="headerlink" title="安装／升级Docker客户端"></a>安装／升级Docker客户端</h5><p>推荐安装1.10.0以上版本的Docker客户端，参考文档 <a href="https://developer.aliyun.com/article/110806" target="_blank" rel="noopener">docker-ce</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> step 1: 安装必要的一些系统工具</span></span><br><span class="line">sudo yum install -y yum-utils device-mapper-persistent-data lvm2</span><br><span class="line"><span class="meta">#</span><span class="bash"> Step 2: 添加软件源信息</span></span><br><span class="line">sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br><span class="line"><span class="meta">#</span><span class="bash"> Step 3: 更新并安装 Docker-CE</span></span><br><span class="line">sudo yum makecache fast</span><br><span class="line">sudo yum -y install docker-ce</span><br><span class="line"><span class="meta">#</span><span class="bash"> Step 4: 开启Docker服务</span></span><br><span class="line">sudo service docker start</span><br></pre></td></tr></table></figure>



<h5 id="配置镜像加速器"><a href="#配置镜像加速器" class="headerlink" title="配置镜像加速器"></a>配置镜像加速器</h5><p>针对Docker客户端版本大于 1.10.0 的用户，可以通过修改daemon配置文件/etc/docker/daemon.json来使用加速器</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">创建目录</span></span><br><span class="line">sudo mkdir -p /etc/docker</span><br><span class="line">sudo tee /etc/docker/daemon.json &lt;&lt;-'EOF'</span><br><span class="line">&#123;</span><br><span class="line">  "registry-mirrors": ["https://t92zxvdg.mirror.aliyuncs.com"]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line"><span class="meta">#</span><span class="bash">重新加载</span></span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure>

<h3 id="安装mysql"><a href="#安装mysql" class="headerlink" title="安装mysql"></a>安装<a href="https://hub.docker.com/_/mysql?tab=tags" target="_blank" rel="noopener">mysql</a></h3><h4 id="查询docker镜像"><a href="#查询docker镜像" class="headerlink" title="查询docker镜像"></a>查询docker镜像</h4><ul>
<li><p><a href="https://hub.docker.com/" target="_blank" rel="noopener">docker hub</a>:直接搜索自己需要的版本</p>
</li>
<li><pre><code class="shell"><span class="meta">#</span><span class="bash"> 查找镜像</span>
<span class="meta">$</span><span class="bash"> docker search mysql</span>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#### 下载镜像</span><br><span class="line"></span><br><span class="line">~~~shell</span><br><span class="line"># :后跟版本，不指定则默认为最新版</span><br><span class="line">$ docker pull mysql:5.7</span><br></pre></td></tr></table></figure>


</code></pre>
</li>
</ul>
<h4 id="创建容器并运行"><a href="#创建容器并运行" class="headerlink" title="创建容器并运行"></a>创建容器并运行</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker run -p 3306:3306 --name mysql \</span></span><br><span class="line">-v /mydata/mysql/log:/var/log/mysql \</span><br><span class="line">-v /mydata/mysql/data:/var/lib/mysql \</span><br><span class="line">-v /mydata/mysql/conf:/etc/mysql \</span><br><span class="line">-e MYSQL_ROOT_PASSWORD=root \</span><br><span class="line">-d mysql:5.7</span><br></pre></td></tr></table></figure>

<ul>
<li><code>-p 3306:3306</code> :将容器的 3306 端口映射到主机的 3306 端口。</li>
<li><code>--name</code> ：指定容器名称</li>
<li><code>-v /mydata/mysql/log:/var/log/mysql</code>:将主机的 /mydata/mysql/log目录挂载到容器的 /var/log/mysql目录。</li>
<li><code>-e MYSQL_ROOT_PASSWORD=root</code>:初始化root密码</li>
<li><code>-d mysql:5.7</code>:使用镜像mysql:5.7，以后台运行，并返回容器ID</li>
</ul>
<h4 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker <span class="built_in">exec</span> -it mysql /bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash">查看mysql文件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> whereis mysql</span></span><br></pre></td></tr></table></figure>

<h4 id="修改mysql默认字符集UTF-8配置"><a href="#修改mysql默认字符集UTF-8配置" class="headerlink" title="修改mysql默认字符集UTF-8配置"></a>修改mysql默认字符集UTF-8配置</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> vim /mydata/mysql/conf/my.cnf</span></span><br><span class="line"><span class="meta">#</span><span class="bash">修改完成后重启mysql</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker restart mysql</span></span><br></pre></td></tr></table></figure>

<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">[client]</span></span><br><span class="line"><span class="meta">default-character-set</span>=<span class="string">utf8</span></span><br><span class="line"></span><br><span class="line"><span class="attr">[mysql]</span></span><br><span class="line"><span class="meta">default-character-set</span>=<span class="string">utf8</span></span><br><span class="line"></span><br><span class="line"><span class="attr">[mysqld]</span></span><br><span class="line"><span class="attr">init_connect</span>=<span class="string">'SET collation_connection = utf8_unicode_ci'</span></span><br><span class="line"><span class="attr">init_connect</span>=<span class="string">'SET NAMES utf8'</span></span><br><span class="line"><span class="meta">character-set-server</span>=<span class="string">utf8</span></span><br><span class="line"><span class="meta">collation-server</span>=<span class="string">utf8_unicode_ci</span></span><br><span class="line"><span class="attr">skip-character-set-client-handshake</span></span><br><span class="line"><span class="attr">skip-name-resolve</span></span><br></pre></td></tr></table></figure>

<h4 id="设置自启动"><a href="#设置自启动" class="headerlink" title="设置自启动"></a>设置自启动</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker update mysql --restart=always</span></span><br></pre></td></tr></table></figure>



<h3 id="安装Redis"><a href="#安装Redis" class="headerlink" title="安装Redis"></a>安装<a href="https://hub.docker.com/_/redis?tab=tags" target="_blank" rel="noopener">Redis</a></h3><h4 id="下载redis最新镜像"><a href="#下载redis最新镜像" class="headerlink" title="下载redis最新镜像"></a>下载redis最新镜像</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker pull redis</span></span><br></pre></td></tr></table></figure>

<h4 id="创建配置文件"><a href="#创建配置文件" class="headerlink" title="创建配置文件"></a>创建配置文件</h4><p><a href="http://www.redis.cn/topics/config.html" target="_blank" rel="noopener">官网配置</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">创建目录</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> mkdir -p /mydata/redis/conf</span></span><br><span class="line"><span class="meta">#</span><span class="bash">创建文件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> touch /mydata/redis/conf/redis.conf</span></span><br></pre></td></tr></table></figure>

<h4 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> vim /mydata/redis/conf/redis.conf</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 开启aof持久化到硬盘</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> appendonly yes</span></span><br></pre></td></tr></table></figure>

<h4 id="启动容器"><a href="#启动容器" class="headerlink" title="启动容器"></a>启动容器</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -p 6379:6379 --name redis \</span><br><span class="line">-v /mydata/redis/data:/data \</span><br><span class="line">-v /mydata/redis/conf/redis.conf:/etc/redis/redis.conf \</span><br><span class="line">-d redis redis-server /etc/redis/redis.conf</span><br></pre></td></tr></table></figure>

<h4 id="运行redis"><a href="#运行redis" class="headerlink" title="运行redis"></a>运行redis</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker <span class="built_in">exec</span> -it redis redis-cli</span></span><br></pre></td></tr></table></figure>

<h4 id="设置docker自启动"><a href="#设置docker自启动" class="headerlink" title="设置docker自启动"></a>设置docker自启动</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker update redis --restart=always</span></span><br></pre></td></tr></table></figure>



<h3 id="安装nodejs"><a href="#安装nodejs" class="headerlink" title="安装nodejs"></a>安装<a href="https://nodejs.org/en/" target="_blank" rel="noopener">nodejs</a></h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">查看版本号</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> node -v</span></span><br><span class="line"><span class="meta">#</span><span class="bash">配置淘宝镜像</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> npm config <span class="built_in">set</span> registry <span class="string">"https://registry.npm.taobao.org"</span></span></span><br></pre></td></tr></table></figure>







]]></content>
      <categories>
        <category>项目实战</category>
      </categories>
      <tags>
        <tag>项目实战</tag>
      </tags>
  </entry>
  <entry>
    <title>云服务器创建swap分区</title>
    <url>/blog/2022/05/01/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%88%9B%E5%BB%BAswap%E5%88%86%E5%8C%BA/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/blog/assets/css/APlayer.min.css"><script src="/blog/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="云服务器创建swap分区"><a href="#云服务器创建swap分区" class="headerlink" title="云服务器创建swap分区"></a>云服务器创建swap分区</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>随着云服务的普及，很多人都购买了云主机来部署一些简单的服务，但通常出于成本的考虑，不会购买特别大型的机器，在有限的硬件资源下，如何让服务器响应更快？如何避免应用出现内存不足的错误？最简单的方法就是增加交换空间(Swap)。</p>
<a id="more"></a>

<p>Swap是存储盘上的一块自留地，操作系统可以在这里暂存一些内存里放不下的东西。这从某种程度上相当于增加了服务器的可用内存。虽然从swap读写比内存慢，但总比没有好，算是内存不够时的安全网。如果没有swap，则服务器一旦内存不足，就会开始终止应用以释放内存，甚至会崩溃，这会让你丢失一些还没来得及保存的数据，或者造成宕机。有些应用明确要求系统配置swap以确保数据访问的可靠性。</p>
<p>Swap分区作用:当系统的物理内存不够用的时候，就需要将物理内存中的一部分空间释放出来，以供当前运行的程序使用。那些被释放的空间可能来自一些很长时间没有什么操作的程序，这些被释放的空间被临时保存到Swap空间中，等到那些程序要运行时，再从Swap中恢复保存的数据到内存中。这样，系统总是在物理内存不够时，才进行Swap交换。</p>
<p>在Windows系统中，这种交换空间叫做虚拟内存，可以在系统-&gt;高级-&gt;性能-&gt;虚拟内存中进行配置。Linux系统下的交换空间配置略为不方便。因此，本文参考了网上的多篇博文，总结记录了在CentOS 7系统的云服务器上创建并启用swap文件的过程中的命令和注意事项。</p>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><h3 id="检查系统的Swap信息"><a href="#检查系统的Swap信息" class="headerlink" title="检查系统的Swap信息"></a>检查系统的Swap信息</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">查看swap使用情况,如果该命令没有返回出结果，则代表该系统尚未配置过swap。</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> swapon -s</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">查看内存状态</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> free -m</span></span><br></pre></td></tr></table></figure>

<h3 id="检查可用的存储空间"><a href="#检查可用的存储空间" class="headerlink" title="检查可用的存储空间"></a>检查可用的存储空间</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">检查磁盘可用空间</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> df -h</span></span><br></pre></td></tr></table></figure>

<p>合适的swap空间是多大？关于这个问题有很多种选择，这取决于你的应用需求和你个人的偏好。一般来说，内存容量的一到两倍就是个不错的选择。Redhat官方推荐的swap大小设置如下：</p>
<p><img data-src="swap%E5%A4%A7%E5%B0%8F.png" alt="swap大小"></p>
<h2 id="定义swap文件大小及位置"><a href="#定义swap文件大小及位置" class="headerlink" title="定义swap文件大小及位置"></a>定义swap文件大小及位置</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> dd <span class="keyword">if</span>=/dev/zero of=/swapfile bs=1k count=2048000</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>of:创建swap文件分区的名称</p>
</li>
<li><p>bs:blocksizes，每个块大小为1k</p>
</li>
<li><p>count=2048000</p>
</li>
<li><p>总大小为 bs * count = 2G的文件。</p>
</li>
</ul>
<p><strong>注意</strong>：此处不使用<code>fallocate</code>命令来创建swap文件，<code>fallocate</code>可能比快<code>dd</code>，但它不适合创建交换文件，并且不受交换相关工具的支持。</p>
<h2 id="创建swap"><a href="#创建swap" class="headerlink" title="创建swap"></a>创建swap</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">更改swap文件权限，确保只有root权限才可读。</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> chmod 600 /swapfile</span></span><br><span class="line"><span class="meta">#</span><span class="bash">基于该文件用于创建swap</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> mkswap /swapfile</span></span><br></pre></td></tr></table></figure>

<h2 id="启动swap"><a href="#启动swap" class="headerlink" title="启动swap"></a>启动swap</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> swapon /swapfile</span></span><br></pre></td></tr></table></figure>

<h2 id="系统自启动"><a href="#系统自启动" class="headerlink" title="系统自启动"></a>系统自启动</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">       设备名      地址  格式  参数类型 不备份 不检查</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="string">"/swapfile swap swap defaults 0 0"</span> &gt;&gt;/etc/fstab</span></span><br></pre></td></tr></table></figure>

<h2 id="删除分区"><a href="#删除分区" class="headerlink" title="删除分区"></a>删除分区</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> swapoff /swapfile</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> swapoff -a &gt;/dev/null</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rm -rf /swapfile</span></span><br></pre></td></tr></table></figure>

<h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><h3 id="Swappiness"><a href="#Swappiness" class="headerlink" title="Swappiness"></a>Swappiness</h3><p><code>swappiness</code>参数决定了系统将数据从内存交换到swap空间的频率，数值设置在0到100之间，代表系统将数据从内存交换到swap空间的力度。</p>
<p>该数值越接近于0，系统越倾向于不进行swap，仅在必要的时候进行swap操作。由于swap要比内存慢很多，因此减少对swap的依赖意味着更高的系统性能。</p>
<p>该数值越接近于100，系统越倾向于多进行swap。有些应用的内存使用习惯更适合于这种情况，这也于服务器的用途有关。输入如下命令查看当前的swappiness数值：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cat /proc/sys/vm/swappiness</span></span><br></pre></td></tr></table></figure>

<p>CentOS 7默认设置了30的swappiness，这对于大部分桌面系统和本地服务器是比较中庸的数值。对于VPS系统而言，可能接近于0的值是更加合适的。使用<code>sysctl</code>命令可以修改swappiness。比如将swappiness设为10：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">重启失效</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sysctl vm.swappiness=10</span></span><br><span class="line"><span class="meta">#</span><span class="bash">永久有效</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> vim /etc/sysctl.conf</span></span><br><span class="line"><span class="meta">#</span><span class="bash">如果没有，加到文件末尾</span></span><br><span class="line"> vm.swappiness=10</span><br></pre></td></tr></table></figure>

<h3 id="缓存压力（Cache-Pressure-）"><a href="#缓存压力（Cache-Pressure-）" class="headerlink" title="缓存压力（Cache Pressure ）"></a>缓存压力（Cache Pressure ）</h3><p>该配置项涉及特殊文件系统元文件条目的存储。对此类信息的频繁读取是非常消耗性能的，所以延长其在缓存的保存时间可以提升系统的性能。通过<code>proc</code>文件系统查看缓存压力的当前设定值：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cat /proc/sys/vm/vfs_cache_pressure</span></span><br></pre></td></tr></table></figure>

<p>这个数值是比较高的，意味着系统从缓存中移除inode信息的速度比较快。一个保守一些的数值是50，使用<code>sysctl</code>命令进行设置：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">重启失效</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sysctl vm.vfs_cache_pressure=50</span></span><br><span class="line"><span class="meta">#</span><span class="bash">永久有效，编辑/etc/sysctl.conf</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> vim /etc/sysctl.conf</span></span><br><span class="line"><span class="meta">#</span><span class="bash">修改配置项vm.vfs_cache_pressure,若果没有，则将其添加到末尾</span></span><br><span class="line">vm.vfs_cache_pressure=50</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>至此，我们的系统内存就获得了一些喘气的空间。有了swap空间可以有效避免一些常见的问题。</p>
<p>如果你仍然会遇到内存不足（OOM，out of memory）的错误信息，或者你的系统不能运行你需要的应用，那么最好的方法是优化你的应用配置或者升级你的服务器，不过配置swap空间也不失为一个灵活的节省方案。</p>
]]></content>
      <categories>
        <category>服务器</category>
      </categories>
      <tags>
        <tag>服务器</tag>
      </tags>
  </entry>
  <entry>
    <title>Git多账号</title>
    <url>/blog/2022/05/01/%E4%BD%BF%E7%94%A8SSH%E7%AE%A1%E7%90%86Git%E5%A4%9A%E8%B4%A6%E5%8F%B7/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/blog/assets/css/APlayer.min.css"><script src="/blog/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="使用SSH管理Git多账号"><a href="#使用SSH管理Git多账号" class="headerlink" title="使用SSH管理Git多账号"></a>使用SSH管理Git多账号</h1><h2 id="HTTPS-和-SSH-的区别："><a href="#HTTPS-和-SSH-的区别：" class="headerlink" title="HTTPS 和 SSH 的区别："></a>HTTPS 和 SSH 的区别：</h2><ul>
<li>HTTPS可以随意克隆github上的项目，而不管是谁的；而SSH则是你必须是你要克隆的项目的拥有者或管理员，且需要先添加 SSH key ，否则无法克隆。</li>
<li>https url 在push的时候是需要验证用户名和密码的；而 SSH 在push的时候，是不需要输入用户名的，如果配置SSH key的时候设置了密码，则需要输入密码的，否则直接是不需要输入<br>密码的。</li>
</ul>
<a id="more"></a>

<h2 id="生成ssh公钥"><a href="#生成ssh公钥" class="headerlink" title="生成ssh公钥"></a>生成ssh公钥</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">默认</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ssh-keygen -t rsa -C <span class="string">"xxxxx@xxxxx.com"</span>  </span></span><br><span class="line"><span class="meta">#</span><span class="bash">指定公钥位置和名称</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ssh-keygen -t rsa -f ~/.ssh/id_github_rsa -C <span class="string">"xxxxx@xxxxx.com"</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>-t</code> 指定密钥类型，默认是 rsa ，可以省略</li>
<li><code>-C</code>设置注释文字，比如邮箱</li>
<li><code>-f</code> 指定密钥文件存储文件名</li>
</ul>
<p><strong>提示</strong>：如果本地没有.ssh文件夹，则使用默认创建公钥方式，不配置，直接回车。</p>
<h2 id="临时添加验证"><a href="#临时添加验证" class="headerlink" title="临时添加验证"></a>临时添加验证</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ssh-agent bash</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ssh-add id_github_rsa</span></span><br></pre></td></tr></table></figure>

<h2 id="配置config"><a href="#配置config" class="headerlink" title="配置config"></a>配置config</h2><p>在 <code>~/.ssh</code>目录下新建一个<code>config</code>文件，添加如下内容（其中Host和HostName填写git服务器的域名，IdentityFile指定私钥的路径）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># gitee</span><br><span class="line">Host gitee.com</span><br><span class="line">    HostName gitee.com</span><br><span class="line">    PreferredAuthentications publickey</span><br><span class="line">    IdentityFile ~&#x2F;.ssh&#x2F;id_github_rsa</span><br><span class="line"># github</span><br><span class="line">Host github.com</span><br><span class="line">    HostName github.com</span><br><span class="line">    PreferredAuthentications publickey</span><br><span class="line">    IdentityFile ~&#x2F;.ssh&#x2F;id_github_rsa</span><br></pre></td></tr></table></figure>

<h2 id="查看所有已添加密钥"><a href="#查看所有已添加密钥" class="headerlink" title="查看所有已添加密钥"></a>查看所有已添加密钥</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ssh-add -l</span></span><br></pre></td></tr></table></figure>

<h2 id="添加ssh有关信息"><a href="#添加ssh有关信息" class="headerlink" title="添加ssh有关信息"></a>添加ssh有关信息</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cat ~/.ssh/id_github_rsa</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC6eNtGpNGwstc....</span></span><br></pre></td></tr></table></figure>

<p>复制生成后的 ssh key，通过仓库主页 <strong>「管理」-&gt;「部署公钥管理」-&gt;「添加部署公钥」</strong> ，添加生成的 public key 添加到仓库中。</p>
<h2 id="验证是否连接成功"><a href="#验证是否连接成功" class="headerlink" title="验证是否连接成功"></a>验证是否连接成功</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ssh -T git@gitee.com</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ssh -T git@github.com</span></span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>工具</category>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM系列(四)垃圾收集器</title>
    <url>/blog/2022/08/01/JVM%E7%B3%BB%E5%88%97(%E5%9B%9B)%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/blog/assets/css/APlayer.min.css"><script src="/blog/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h2><p><img data-src="%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95.png" alt="垃圾收集算法"></p>
<h3 id="分代收集理论"><a href="#分代收集理论" class="headerlink" title="分代收集理论"></a>分代收集理论</h3><p>当前虚拟机的垃圾收集都采用分代收集算法，这种算法没有什么新的思想，只是根据对象存活周期的不同将内存分为几块。一般将java堆分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。</p>
<p>比如在新生代中，每次收集都会有大量对象(近99%)死去，所以可以选择复制算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。而老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集。注意，“标记-清除”或“标记-整理”算法会比复制算法慢10倍以上。</p>
<h3 id="标记-复制算法"><a href="#标记-复制算法" class="headerlink" title="标记-复制算法"></a>标记-复制算法</h3><p>为了解决效率问题，“复制”收集算法出现了。它可以将内存分为大小相同的两块，每次使用其中的一块。当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。这样就使每次的内存回收都是对内存区间的一半进行回收。</p>
<img data-src="标记复制算法.jpeg" alt="标记复制算法" style="zoom: 50%;" />

<h3 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h3><p>算法分为“标记”和“清除”阶段:标记存活的对象,统一回收所有未标记的对象(一般选择这种);也可以反过来,标记出所有需要回收的对象,在标记完成后统一回收所有被标记的对象.它是最基础的收集算法,比较简单,但是会带来两个明显的问题:</p>
<ol>
<li>效率问题(如果需要标记的对象太多,效率不高)</li>
<li>空间问题(标记清除后产生大量不连续的碎片)</li>
</ol>
<img data-src="标记清除法.jpeg" alt="标记清除法" style="zoom:50%;" />

<h3 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h3><p>根据老年代的特点特出的一种标记算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象回收，而是让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存。</p>
<p><img data-src="%E6%A0%87%E8%AE%B0%E6%95%B4%E7%90%86%E7%AE%97%E6%B3%95.jpeg" alt="标记整理算法"></p>
<h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><p><img data-src="%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8.png" alt="垃圾收集器"></p>
<p><strong>如果说收集算法是内存回收的方法论,那么垃圾收集器就是内存回收的具体实现.</strong></p>
<p>虽然我们对各个收集器进行比较，但并非为了挑选出一个最好的收集器。因为直到现在为止还没有最好的垃圾收集器出现，更加没有万能的垃圾收集器，<strong>我们能做的就是根据具体应用场景选择适合自己的垃圾收集器</strong>。试想一下：如果有一种任何场景下都适用的完美收集器存在，那么我们的Java虚拟机就不会实现那么多不同的垃圾收集器了。</p>
<h3 id="Serial收集器-XX-UseSerialGC-XX-UseSerialOldGC"><a href="#Serial收集器-XX-UseSerialGC-XX-UseSerialOldGC" class="headerlink" title="Serial收集器(-XX:+UseSerialGC -XX:+UseSerialOldGC)"></a>Serial收集器(-XX:+UseSerialGC -XX:+UseSerialOldGC)</h3><p>Serial（串行）收集器是最基本、历史最悠久的垃圾收集器了。大家看名字就知道这个收集器是一个单线程收集器了。它的 <strong>“单线程”</strong> 的意义不仅仅意味着它只会使用一条垃圾收集线程去完成垃圾收集工作，更重要的是它在进行垃圾收集工作的时候必须暂停其他所有的工作线程（ <strong>“Stop The World”</strong> ），直到它收集结束。</p>
<p><strong>新生代采用复制算法，老年代采用标记-整理算法。</strong></p>
<p><img data-src="serial%E6%94%B6%E9%9B%86%E5%99%A8.jpeg" alt="serial收集器"></p>
<p>虚拟机的设计者们当然知道Stop The World带来的不良用户体验，所以在后续的垃圾收集器设计中停顿时间在不断缩短（仍然还有停顿，寻找最优秀的垃圾收集器的过程仍然在继续）。</p>
<p>但是Serial收集器有没有优于其他垃圾收集器的地方呢？当然有，它<strong>简单而高效（与其他收集器的单线程相比）</strong>。Serial收集器由于没有线程交互的开销，自然可以获得很高的单线程收集效率。</p>
<p><strong>Serial Old收集器是Serial收集器的老年代版本</strong>，它同样是一个单线程收集器。它主要有两大用途：一种用途是在JDK1.5以及以前的版本中与Parallel Scavenge收集器搭配使用，<strong>另一种用途是作为CMS收集器的后备方案</strong>。</p>
<h3 id="Parallel-Scavenge收集器-XX-UseParallelGC-年轻代-XX-UseParallelOldGC-老年代"><a href="#Parallel-Scavenge收集器-XX-UseParallelGC-年轻代-XX-UseParallelOldGC-老年代" class="headerlink" title="Parallel Scavenge收集器(-XX:+UseParallelGC(年轻代) -XX:+UseParallelOldGC(老年代))"></a>Parallel Scavenge收集器(-XX:+UseParallelGC(年轻代) -XX:+UseParallelOldGC(老年代))</h3><p><strong>Parallel</strong>收集器其实<strong>就是Serial收集器的多线程版本</strong>，除了使用多线程进行垃圾收集外，其余行为（控制参数、收集算法、回收策略等等）和Serial收集器类似。默认的收集线程数跟cpu核数相同，当然也可以用参数(-XX:ParallelGCThreads)指定收集线程数，但是一般不推荐修改。</p>
<p><strong>Parallel Scavenge收集器关注点是吞吐量（高效率的利用CPU）。CMS等垃圾收集器的关注点更多的是用户线程的停顿时间（提高用户体验）。所谓吞吐量就是CPU中用于运行用户代码的时间与CPU总消耗时间的比值。</strong> Parallel Scavenge收集器提供了很多参数供用户找到最合适的停顿时间或最大吞吐量，如果对于收集器运作不太了解的话，可以选择把内存管理优化交给虚拟机去完成也是一个不错的选择。</p>
<p><strong>新生代采用复制算法，老年代采用标记-整理算法。</strong></p>
<p><img data-src="parallel%E6%94%B6%E9%9B%86%E5%99%A8.jpeg" alt="parallel收集器"></p>
<p><strong>Parallel Old收集器是Parallel Scavenge收集器的老年代版本</strong>。使用多线程和“标记-整理”算法。在注重吞吐量以及CPU资源的场合，都可以优先考虑 Parallel Scavenge收集器和Parallel Old收集器(<strong>JDK8默认的新生代和老年代收集器</strong>)。</p>
<h3 id="ParNew收集器-XX-UseParNewGC"><a href="#ParNew收集器-XX-UseParNewGC" class="headerlink" title="ParNew收集器(-XX:+UseParNewGC)"></a>ParNew收集器(-XX:+UseParNewGC)</h3><p>ParNew收集器其实<strong>跟Parallel收集器很类似</strong>，区别主要在于它可以和CMS收集器配合使用。</p>
<p><strong>新生代采用复制算法，老年代采用标记-整理算法。</strong></p>
<p><img data-src="parnew%E6%94%B6%E9%9B%86%E5%99%A8.jpeg" alt="parnew收集器"></p>
<p>它是许多运行在Server模式下的虚拟机的首要选择，除了Serial收集器外，只有它能与CMS收集器（真正意义上的并发收集器，后面会介绍到）配合工作。</p>
<h3 id="CMS收集器-XX-UseConcMarkSweepGC-old"><a href="#CMS收集器-XX-UseConcMarkSweepGC-old" class="headerlink" title="CMS收集器(-XX:+UseConcMarkSweepGC(old))"></a>CMS收集器(-XX:+UseConcMarkSweepGC(old))</h3><p><strong>CMS(Concurrent Mark Sweep)收集器是一种以获取最短回收停顿时间为目标的收集器.它非常符合在注重用户体验的应用上使用,它是HotSpot虚拟机第一款真正意义上的并发收集器,它第一次实现了让垃圾收集器与用户线程(基本上)同时工作.</strong></p>
<p>从名字中的<strong>Mark Sweep</strong>这两个词可以看出，CMS收集器是一种 <strong>“标记-清除”算法</strong>实现的，它的运作过程相比于前面几种垃圾收集器来说更加复杂一些。整个过程分为四个步骤：</p>
<ul>
<li><strong>初始标记</strong>:暂停所有的其他线程(STW),并记录下<strong>GC Roots直接能引用的对象,速度很快.</strong></li>
<li><strong>并发标记</strong>:并发标记阶段就是从<strong>GC Roots的直接关联对象开始遍历整个对象图的过程</strong>,这个过程耗时较长但是不需要停顿用户线程,可以<strong>与垃圾收集线程一起并发运行</strong>.因为用户程序继续运行,可能会有导致已经标记过的对象状态发生改变.</li>
<li><strong>重新标记</strong>:重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录(<strong>主要是处理漏标问题</strong>),这个阶段的停顿时间一般会比初始标记阶段时间稍长,远远比并发标记阶段时间短.<strong>主要用到三色标记里的增量更新算法做重新标记</strong>.</li>
<li><strong>并发清理</strong>:开启用户线程,同时GC线程开始对未标记的区域做清扫.这个阶段如果有新增对象会被标记为黑色不做任何处理(<strong>三色标记算法</strong>)</li>
<li><strong>并发重置</strong>:重置本次GC过程中的标记数据.</li>
</ul>
<p><img data-src="CMS%E7%AE%97%E6%B3%95.jpeg" alt="CMS算法"></p>
<p>从它的名字就可以看出它是一款优秀的垃圾收集器，主要优点：<strong>并发收集、低停顿</strong>。但是它有下面几个明显的缺点：</p>
<ul>
<li><p>对CPU资源敏感（会和服务抢资源）；</p>
</li>
<li><p>无法处理<strong>浮动垃圾</strong>(在并发标记和并发清理阶段又产生垃圾，这种浮动垃圾只能等到下一次gc再清理了)；</p>
</li>
<li><p>它使用的回收算法-<strong>“标记-清除”算法</strong>会导致收集结束时会有<strong>大量空间碎片</strong>产生，当然通过参数-XX:+UseCMSCompactAtFullCollection可以让jvm在执行完标记清除后再做整理</p>
</li>
<li><p>执行过程中的不确定性，会存在上一次垃圾回收还没执行完，然后垃圾回收又被触发的情况，<strong>特别是在并发标记和并发清理阶段会出现</strong>，一边回收，系统一边运行，也许没回收完就再次触发full gc，也就是”<strong>concurrent mode failure</strong>“，<strong>此时会进入stop the world，用serial old垃圾收集器来回收</strong></p>
</li>
</ul>
<p>CMS的相关核心参数:</p>
<ol>
<li>-XX:+UseConcMarkSeepGC:启用CMS</li>
<li>-XX:ConcGCThread:并发的GC线程数</li>
<li>-XX:+UseCMSCompactAtFullCollection:FullGC之后做压缩整理(减少碎片)</li>
<li>-XX:CMSFullGCsBeforeCompaction:多少次FullGC之后压缩一次,默认是0,代表每次FullGC后压缩一次</li>
<li>-XX:CMSInitiatingOccupancyFraction:当老年代使用达到该比例时会触发FullGC(默认时92,单位百分比)</li>
<li>-XX:+UseCMSInitatingOccupancyOnly:只使用设定的回收阈值(-XX:CMSInitiatingOccupancyFraction设定的值),如果不指定,JVM仅在第一次使用设定值,后续则会自动调整</li>
<li>-XX:+CMSScavengeBeforeRemork:在CMS GC前启动一次minor gc,降低CMS GC标记阶段(也会对很多年轻代一起做标记,如果在minor gc就干掉了很多垃圾对象,标记阶段就会减少一些标记时间)时的开销,一般CMS的GC耗时80%都在标记阶段</li>
<li>-XX:+CMSParallelInitalMarkEnabled:表示在初始化标记的时候多线程执行,缩短STW</li>
<li>-XX:+CMSParallelRemarkEnabled:在重新标记的时候多线程执行,缩短STW</li>
</ol>
<h2 id="亿级流量电商系统如何优化JVM参数设置-ParNew-CMS"><a href="#亿级流量电商系统如何优化JVM参数设置-ParNew-CMS" class="headerlink" title="亿级流量电商系统如何优化JVM参数设置(ParNew + CMS)"></a>亿级流量电商系统如何优化JVM参数设置(ParNew + CMS)</h2><p>大型电商系统后端现在一般都是拆分为多个子系统部署的，比如，商品系统，库存系统，订单系统，促销系统，会员系统等等。</p>
<p>我们这里以比较核心的订单系统为例 </p>
<p><img data-src="%E7%94%B5%E5%95%86%E8%AE%A2%E5%8D%95%E7%B3%BB%E7%BB%9F.png" alt="电商订单系统"></p>
<p><strong>对于8G内存，我们一般是分配4G内存给JVM，正常的JVM参数配置如下：</strong></p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">-Xms3072M</span> <span class="string">-Xmx3072M -Xss1M -XX:MetaspaceSize=256M -XX:MaxMetaspaceSize=256M  -XX:SurvivorRatio=8</span></span><br></pre></td></tr></table></figure>

<p>之前说过，这样设置可能会由于动态对象年龄判断原则导致频繁full gc。</p>
<p>于是更新JVM参数设置:</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">-Xms3072M</span> <span class="string">-Xmx3072M -Xmn2048M -Xss1M -XX:MetaspaceSize=256M -XX:MaxMetaspaceSize=256M  -XX:SurvivorRatio=8</span></span><br></pre></td></tr></table></figure>

<img data-src="运行时内存模型.png" alt="运行时内存模型" style="zoom:80%;" />

<p>这样就降低了因为对象动态年龄判断原则导致的对象频繁进入老年代的问题，其实<strong>很多优化无非就是让短期存活的对象尽量都留在survivor里，不要进入老年代，这样在minor gc的时候这些对象都会被回收，不会进到老年代从而导致full gc</strong>。</p>
<p>对于对象年龄应该为多少才移动到老年代比较合适，本例中一次minor gc要间隔二三十秒，大多数对象一般在几秒内就会变为垃圾，完全可以将默认的15岁改小一点，比如改为5，那么意味着对象要经过5次minor gc才会进入老年代，整个时间也有一两分钟了，如果对象这么长时间都没被回收，完全可以认为这些对象是会存活的比较长的对象，可以移动到老年代，而不是继续一直占用survivor区空间。</p>
<p>对于多大的对象直接进入老年代(参数-XX:PretenureSizeThreshold)，这个一般可以结合系统看下有没有什么大对象生成，预估下大对象的大小，一般来说设置为1M就差不多了，很少有超过1M的大对象，这些对象一般就是你系统初始化分配的缓存对象，比如大的缓存List，Map之类的对象。</p>
<p>可以适当调整JVM参数如下：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">-Xms3072M</span> <span class="string">-Xmx3072M -Xmn2048M -Xss1M  -XX:MetaspaceSize=256M -XX:MaxMetaspaceSize=256M  -XX:SurvivorRatio=8  </span></span><br><span class="line"><span class="meta">-XX</span>:<span class="string">MaxTenuringThreshold=5 -XX:PretenureSizeThreshold=1M</span></span><br></pre></td></tr></table></figure>

<p>对于JDK8默认的垃圾回收器是-XX:+UseParallelGC(年轻代)和-XX:+UseParallelOldGC(老年代)，如果内存较大(超过4个G，只是经验值)，系统对停顿时间比较敏感，我们可以使用<strong>ParNew+CMS(</strong>-XX:+UseParNewGC -XX:+UseConcMarkSweepGC<strong>)</strong></p>
<p>对于老年代CMS的参数如何设置我们可以思考下，首先我们想下当前这个系统有哪些对象可能会长期存活躲过5次以上minor gc最终进入老年代。</p>
<p>无非就是那些Spring容器里的Bean，线程池对象，一些初始化缓存数据对象等，这些加起来充其量也就几十MB。</p>
<p>还有就是某次minor gc完了之后还有超过一两百M的对象存活，那么就会直接进入老年代，比如突然某一秒瞬间要处理五六百单，那么每秒生成的对象可能有一百多M，再加上整个系统可能压力剧增，一个订单要好几秒才能处理完，下一秒可能又有很多订单过来。</p>
<p>我们可以估算下大概每隔五六分钟出现一次这样的情况，那么大概半小时到一小时之间就可能因为老年代满了触发一次Full GC，Full GC的触发条件还有我们之前说过的<strong>老年代空间分配担保机制</strong>，历次的minor gc挪动到老年代的对象大小肯定是非常小的，所以几乎不会在minor gc触发之前由于老年代空间分配担保失败而产生full gc，其实在半小时后发生full gc，这时候已经过了抢购的最高峰期，后续可能几小时才做一次FullGC。</p>
<p>对于碎片整理，因为都是1小时或几小时才做一次FullGC，是可以每做完一次就开始碎片整理，或者两到三次之后再做一次也行。</p>
<p>综上，只要年轻代参数设置合理，老年代CMS的参数设置基本都可以用默认值，如下所示：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">-Xms3072M</span> <span class="string">-Xmx3072M -Xmn2048M -Xss1M  -XX:MetaspaceSize=256M -XX:MaxMetaspaceSize=256M  -XX:SurvivorRatio=8 </span></span><br><span class="line"><span class="meta">-XX</span>:<span class="string">MaxTenuringThreshold=5 -XX:PretenureSizeThreshold=1M -XX:+UseParNewGC -XX:+UseConcMarkSweepGC </span></span><br><span class="line"><span class="meta">-XX</span>:<span class="string">CMSInitiatingOccupancyFraction=92 -XX:+UseCMSCompactAtFullCollection -XX:CMSFullGCsBeforeCompaction=3</span></span><br></pre></td></tr></table></figure>

<h2 id="垃圾收集底层算法实现"><a href="#垃圾收集底层算法实现" class="headerlink" title="垃圾收集底层算法实现"></a>垃圾收集底层算法实现</h2><h3 id="三色标记"><a href="#三色标记" class="headerlink" title="三色标记"></a>三色标记</h3><p><strong>在并发标记的过程中,因为标记期间应用线程还在继续跑,对象间的引用可能发生变化,多标和漏标的情况就有可能发生.漏标的问题主要引入了三色标记算法来解决.</strong></p>
<p><strong>三色标记算法是把Gc roots可达性分析遍历对象过程中遇到的对象， 按照“是否访问过”这个条件标记成以下三种颜色：</strong></p>
<ul>
<li><p><strong>黑色</strong>： 表示对象已经被垃圾收集器访问过， 且这个对象的所有引用都已经扫描过。 黑色的对象代表已经扫描过， 它是安全存活的， 如果有其他对象引用指向了黑色对象， 无须重新扫描一遍。 黑色对象不可能直接（不经过灰色对象） 指向某个白色对象。</p>
</li>
<li><p><strong>灰色</strong>： 表示对象已经被垃圾收集器访问过， 但这个对象上至少存在一个引用还没有被扫描过。</p>
</li>
<li><p><strong>白色</strong>： 表示对象尚未被垃圾收集器访问过。 显然在可达性分析刚刚开始的阶段， 所有的对象都是白色的， 若在分析结束的阶段， 仍然是白色的对象， 即代表不可达。</p>
<p><img data-src="%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0.png" alt="三色标记"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 垃圾收集算法细节之三色标记</span></span><br><span class="line"><span class="comment"> * 为了简化例子，代码写法可能不规范，请忽略</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreeColorRemark</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        A a = <span class="keyword">new</span> A();</span><br><span class="line">        <span class="comment">//开始做并发标记</span></span><br><span class="line">        D d = a.b.d;  <span class="comment">//1.读</span></span><br><span class="line">        a.b.d = <span class="keyword">null</span>;   <span class="comment">//2.写</span></span><br><span class="line">        a.d = d;   <span class="comment">//3.写</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    B b = <span class="keyword">new</span> B();</span><br><span class="line">    D d = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">    C c = <span class="keyword">new</span> C();</span><br><span class="line">    D d = <span class="keyword">new</span> D();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="多标-浮动垃圾"><a href="#多标-浮动垃圾" class="headerlink" title="多标-浮动垃圾"></a>多标-浮动垃圾</h3><p>在并发标记过程中，如果由于方法运行结束导致部分局部变量(gcroot)被销毁，这个gcroot引用的对象之前又被扫描过(被标记为非垃圾对象)，那么本轮GC不会回收这部分内存。这部分本应该回收但是没有回收到的内存，被称之为“<strong>浮动垃圾</strong>”。浮动垃圾并不会影响垃圾回收的正确性，只是需要等到下一轮垃圾回收中才被清除。</p>
<p>另外，<strong>针对并发标记(还有并发清理)开始后产生的新对象，通常的做法是直接全部当成黑色</strong>，本轮不会进行清除。这部分对象期间可能也会变为垃圾，这也算是浮动垃圾的一部分。</p>
<p><img data-src="%E5%A4%9A%E6%A0%87.webp" alt="多标"></p>
<h3 id="漏标-读写屏障"><a href="#漏标-读写屏障" class="headerlink" title="漏标-读写屏障"></a>漏标-读写屏障</h3><p>漏标会导致被引用的对象被当成垃圾误删除，这是严重bug，必须解决，有两种解决方案： <strong>增量更新（Incremental Update） 和原始快照（Snapshot At The Beginning，SATB） 。</strong></p>
<p>漏标必须要同时满足以下两个条件：</p>
<ol>
<li>赋值器插入了一条或者多条从黑色对象到白色对象的新引用；</li>
<li>赋值器删除了全部从灰色对象到该白色对象的直接或间接引用。</li>
</ol>
<p><img data-src="%E6%BC%8F%E6%A0%87.webp" alt="漏标"></p>
<h4 id="增量更新"><a href="#增量更新" class="headerlink" title="增量更新"></a>增量更新</h4><p>当黑色对象插入新的指向白色对象的引用关系时， 就将这个新插入的引用记录下来，等并发扫描结束之后， 再将这些记录过的引用关系中的黑色对象为根，重新扫描一次。 这可以简化理解为， <strong>黑色对象一旦新插入了指向白色对象的引用之后， 就把发出引用的对象涂成灰色</strong>。</p>
<img data-src="增量更新.png" alt="增量更新" style="zoom:67%;" />

<h4 id="原始快照"><a href="#原始快照" class="headerlink" title="原始快照"></a>原始快照</h4><p>当灰色对象要删除指向白色对象的引用关系时， 就将这个要删除的引用记录下来， 在并发扫描结束之后， 再将这些记录过的引用关系中的灰色对象为根，重新扫描一次，这样就能扫描到白色的对象，将白色对象直接标记为灰色(<strong>目的就是让这种对象在本轮gc清理中能存活下来，待下一轮gc的时候重新扫描，这个对象也有可能是浮动垃圾</strong>)</p>
<img data-src="原始快照.png" alt="原始快照" style="zoom:67%;" />

<h4 id="写屏障"><a href="#写屏障" class="headerlink" title="写屏障"></a>写屏障</h4><p>以上无论是对引用关系记录的插入还是删除， 虚拟机的记录操作都是通过<strong>写屏障</strong>实现的。 </p>
<p>给某个对象的成员变量赋值时，其底层代码大概长这样：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* @param field 某对象的成员变量，如 a.b.d </span></span><br><span class="line"><span class="comment">* @param new_value 新值，如 null</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">oop_field_store</span><span class="params">(oop* field, oop new_value)</span> </span>&#123; </span><br><span class="line">    *field = new_value; <span class="comment">// 赋值操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所谓的写屏障，其实就是指在赋值操作前后，加入一些处理（可以参考AOP的概念）：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">oop_field_store</span><span class="params">(oop* field, oop new_value)</span> </span>&#123;  </span><br><span class="line">    pre_write_barrier(field);          <span class="comment">// 写屏障-写前操作</span></span><br><span class="line">    *field = new_value; </span><br><span class="line">    post_write_barrier(field, value);  <span class="comment">// 写屏障-写后操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="写屏障实现增量更新"><a href="#写屏障实现增量更新" class="headerlink" title="写屏障实现增量更新"></a>写屏障实现增量更新</h5><p>当对象A的成员变量的引用发生变化时，比如新增引用（a.d = d），我们可以利用写屏障，将A<strong>新的成员变量引用</strong>对象D记录下来：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">post_write_barrier</span><span class="params">(oop* field, oop new_value)</span> </span>&#123;  </span><br><span class="line">    remark_set.add(new_value);  <span class="comment">// 记录新引用的对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="写屏障实现SATB"><a href="#写屏障实现SATB" class="headerlink" title="写屏障实现SATB"></a>写屏障实现SATB</h5><p>当对象B的成员变量的引用发生变化时，比如引用消失（a.b.d = null），我们可以利用写屏障，将B<strong>原来成员变量的引用</strong>对象D记录下来：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pre_write_barrier</span><span class="params">(oop* field)</span> </span>&#123;</span><br><span class="line">    oop old_value = *field;    <span class="comment">// 获取旧值</span></span><br><span class="line">    remark_set.add(old_value); <span class="comment">// 记录原来的引用对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="读屏障"><a href="#读屏障" class="headerlink" title="读屏障"></a>读屏障</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">oop <span class="title">oop_field_load</span><span class="params">(oop* field)</span> </span>&#123;</span><br><span class="line">    pre_load_barrier(field); <span class="comment">// 读屏障-读取前操作</span></span><br><span class="line">    <span class="keyword">return</span> *field;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>读屏障是直接针对第一步：D d = a.b.d，当读取成员变量时，一律记录下来：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pre_load_barrier</span><span class="params">(oop* field)</span> </span>&#123;  </span><br><span class="line">    oop old_value = *field;</span><br><span class="line">    remark_set.add(old_value); <span class="comment">// 记录读取到的对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>现代追踪式（可达性分析）的垃圾回收器几乎都借鉴了三色标记的算法思想，尽管实现的方式不尽相同：比如白色/黑色集合一般都不会出现（但是有其他体现颜色的地方）、灰色集合可以通过栈/队列/缓存日志等方式进行实现、遍历方式可以是广度/深度遍历等等。</p>
<p>对于读写屏障，以Java HotSpot VM为例，其并发标记时对漏标的处理方案如下：</p>
<ul>
<li><strong>CMS：写屏障 + 增量更新</strong></li>
<li><strong>G1，Shenandoah：写屏障 + SATB</strong></li>
<li><strong>ZGC：读屏障</strong></li>
</ul>
<p>工程实现中，读写屏障还有其他功能，比如写屏障可以用于记录跨代/区引用的变化，读屏障可以用于支持移动对象的并发执行等。功能之外，还有性能的考虑，所以对于选择哪种，每款垃圾回收器都有自己的想法。</p>
<h4 id="为什么G1用SATB？CMS用增量更新？"><a href="#为什么G1用SATB？CMS用增量更新？" class="headerlink" title="为什么G1用SATB？CMS用增量更新？"></a>为什么G1用SATB？CMS用增量更新？</h4><p><strong>我的理解</strong>：SATB相对增量更新效率会高(当然SATB可能造成更多的浮动垃圾)，因为不需要在重新标记阶段再次深度扫描被删除引用对象，而CMS对增量引用的根对象会做深度扫描，G1因为很多对象都位于不同的region，CMS就一块老年代区域，重新深度扫描对象的话G1的代价会比CMS高，所以G1选择SATB不深度扫描对象，只是简单标记，等到下一轮GC再深度扫描。</p>
<h2 id="记忆集与卡表"><a href="#记忆集与卡表" class="headerlink" title="记忆集与卡表"></a>记忆集与卡表</h2><p>在新生代做GCRoots可达性扫描过程中可能会碰到跨代引用的对象，这种如果又去对老年代再去扫描效率太低了。</p>
<p>为此，在新生代可以引入记录集（<strong>Remember Set</strong>）的数据结构（记录从非收集区到收集区的指针集合），避免把整个老年代加入GCRoots扫描范围。事实上并不只是新生代、 老年代之间才有跨代引用的问题， 所有涉及部分区域收集（Partial GC） 行为的垃圾收集器， 典型的如G1、 ZGC和Shenandoah收集器， 都会面临相同的问题。</p>
<p>垃圾收集场景中，收集器只需通过记忆集判断出某一块非收集区域是否存在指向收集区域的指针即可，无需了解跨代引用指针的全部细节。</p>
<h3 id="跨代引用"><a href="#跨代引用" class="headerlink" title="跨代引用"></a>跨代引用</h3><p>所谓跨代引用就是老年代的对象引用了新生代的对象，或者新生代的对象引用了老年代的对象。那对于这种情况我们的GC在进行扫描的时候不可能直接把我们的整个堆都扫描完，那这样效率也太低了。所以这时候就需要开辟了一小块空间，维护这种引用，而不必让GC扫描整个堆区域。</p>
<h3 id="记忆集"><a href="#记忆集" class="headerlink" title="记忆集"></a>记忆集</h3><p>记忆集也叫rememberSet，垃圾收集器在新生代中建立了记忆集这样的数据结构，用来避免把整个老年代加入到GC ROOTS的扫描范围中。对于记忆集来说，我们可以理解为他是一个抽象类，那么具体实现它的方法将由子类去完成。这里我们简单列举一下实现记忆集的三种方式：<br>1.字长精度<br>2.对象精度<br>3.卡精度（卡表）</p>
<h3 id="卡表"><a href="#卡表" class="headerlink" title="卡表"></a>卡表</h3><p>HotSpot使用一种叫做“卡表”(<strong>Cardtable</strong>)的方式实现记忆集，也是目前最常用的一种方式。关于卡表与记忆集的关系， 可以类比为Java语言中HashMap与Map的关系。</p>
<p>卡表是使用一个字节数组实现：CARD_TABLE[ ]，每个元素对应着其标识的内存区域一块特定大小的内存块，称为“卡页”。</p>
<p>HotSpot使用的卡页是2^9大小，即512字节</p>
<img data-src="记忆集与卡表.png" alt="记忆集与卡表" style="zoom:67%;" />

<p>一个卡页中可包含多个对象，只要有一个对象的字段存在跨代指针，其对应的卡表的元素标识就变成1，表示该元素变脏，否则为0.</p>
<p>GC时，只要筛选本收集区的卡表中变脏的元素加入GCRoots里。</p>
<p><strong>卡表的维护</strong></p>
<p>卡表变脏上面已经说了，但是需要知道如何让卡表变脏，即发生引用字段赋值时，如何更新卡表对应的标识为1。</p>
<p>Hotspot使用<strong>写屏障</strong>维护卡表状态。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库</title>
    <url>/blog/2020/08/18/%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/blog/assets/css/APlayer.min.css"><script src="/blog/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><p>数据库就是一个存储数据的仓库，它将数据按照特定的规律存储在磁盘上。为了方便用户组织和管理数据，其专门提供了数据库管理系统。</p>
<a id="more"></a>

<h2 id="发展三个阶段"><a href="#发展三个阶段" class="headerlink" title="发展三个阶段"></a>发展三个阶段</h2><p>数据库管理系统（DBMS）是数据库的核心软件之一，是位于用户与操作系统之间的数据管理软件，用于建立，使用和维护数据库。</p>
<p>数据冗余是指数据之间的重复，也可以说是同一数据存储在不同数据文件中的现象。</p>
<h3 id="人工管理阶段"><a href="#人工管理阶段" class="headerlink" title="人工管理阶段"></a>人工管理阶段</h3><p>在计算机出现之前，人们主要利用纸张和计算工具（如算盘和计算尺）来进行数据的记录和计算，依靠大脑来管理和利用数据。</p>
<p>到了 20 世纪 50 年代中期， 这时计算机刚刚开始萌芽，还没有类似于磁盘等专门管理数据的存储设备，只有纸带、卡片、磁带等外存。所以计算机只能局限于科学技术方面，主要用于科学计算。</p>
<p>人工管理阶段的特点如下：</p>
<ul>
<li>数据不能长期保存</li>
<li>不便于查询数据</li>
<li>数据不能共享，冗余度大</li>
<li>数据不具有独立性</li>
</ul>
<h3 id="文件系统阶段"><a href="#文件系统阶段" class="headerlink" title="文件系统阶段"></a>文件系统阶段</h3><p>在 20 世纪 50 年代后期到 20 世纪 60 年代中期，计算机中的磁盘和磁鼓等直接存取设备开始普及。这时，可以将数据存储在计算机的磁盘上。这些数据都以文件的形式存储，然后通过文件系统来管理这些文件。</p>
<p>文件系统阶段的特点如下：</p>
<ul>
<li>数据可以长期保存</li>
<li>数据由文件系统来管理</li>
<li>数据冗余大，共享性差</li>
<li>数据独立性差</li>
<li>无法应对突发事故（文件误删，磁盘故障等）</li>
</ul>
<h3 id="数据库系统阶段"><a href="#数据库系统阶段" class="headerlink" title="数据库系统阶段"></a>数据库系统阶段</h3><p>在 20 世纪 60 年代后期，随着网络技术的发展，计算机软/硬件的进步，出现了数据库技术，该阶段就是所谓的数据库系统阶段。</p>
<p>数据库系统阶段使用专门的数据库来管理数据，用户可以在数据库系统中建立数据库，然后在数据库中建立表，最后将数据存储在这些表中。用户可以直接通过数据库管理系统来查询表中的数据。</p>
<p>相对于文件系统来说，数据库系统实现了数据结构化。在文件系统中，独立文件内部的数据一般是有结构的，但文件之间不存在联系，因此整体来说是没有结构的。 数据库系统虽然也常常分成许多单独的数据文件，但是它更注意同一数据库中各数据文件之间的相互联系。</p>
<p>数据库系统阶段的特点如下：</p>
<ul>
<li>数据由数据库管理系统统一管理和控制</li>
<li>数据共享性高，冗余度低</li>
<li>数据独立性强</li>
<li>数据粒度小</li>
</ul>
<p><code>数据粒度是数据库中数据的细化程度。细化程度越高，粒度越小；细化程度越低，粒度越大。</code></p>
<table>
<thead>
<tr>
<th>数据管理的3个阶段</th>
<th>人工管理（20 世纪 50 年代中期）</th>
<th>文件系统（50 年代末至 60 年代中期）</th>
<th>数据库系统（60 年代后期）</th>
</tr>
</thead>
<tbody><tr>
<td>应用背景</td>
<td>科学计算</td>
<td>科学计算、管理</td>
<td>大规模数据、分布数据的管理</td>
</tr>
<tr>
<td>硬件背景</td>
<td>无直接存取存储设备</td>
<td>磁带、磁盘、磁鼓</td>
<td>大容量磁盘、可擦写光盘、按需增容磁带机等</td>
</tr>
<tr>
<td>软件背景</td>
<td>无专门管理的软件</td>
<td>利用操作系统的文件系统</td>
<td>由 DBMS 支撑</td>
</tr>
<tr>
<td>数据处理方式</td>
<td>批处理</td>
<td>联机实时处理、批处理</td>
<td>联机实时处理、批处理、分布处理</td>
</tr>
<tr>
<td>数据的管理者</td>
<td>用户/程序管理</td>
<td>文件系统代理</td>
<td>DBMS 管理</td>
</tr>
<tr>
<td>数据应用及其扩充</td>
<td>面向某一应用程序难以扩充</td>
<td>面向某一应用系统、不易扩充</td>
<td>面向多种应用系统、容易扩充</td>
</tr>
<tr>
<td>数据的共享性</td>
<td>无共享、冗余度极大</td>
<td>共享性差、冗余度大</td>
<td>共享性好、冗余度小</td>
</tr>
<tr>
<td>数据的独立性</td>
<td>数据的独立性差</td>
<td>物理独立性好、逻辑独立性差</td>
<td>具有高度的物理独立性、具有较好的逻辑独立性</td>
</tr>
<tr>
<td>数据的结构化</td>
<td>数据无结构</td>
<td>记录内有结构、整体无结构</td>
<td>统一数据模型、整体结构化</td>
</tr>
<tr>
<td>数据的安全性</td>
<td>应用程序保护</td>
<td>文件系统保护</td>
<td>由 DBMS 提供完善的安全保护</td>
</tr>
</tbody></table>
<h2 id="数据库是什么？"><a href="#数据库是什么？" class="headerlink" title="数据库是什么？"></a>数据库是什么？</h2><p><strong>数据</strong>描述事物的符号称为。数据有多种表现形式，可以是数字，也可以是文字、图形、图像、声音、语言等。在数据库中数据表示记录，例如，在学生管理数据库中，记录学生的信息包括学号、姓名、性别、年龄、籍贯和联系电话等，这些信息就是数据。</p>
<p><strong>数据库（Database）</strong>指长期存储在计算机内的、有组织的、可共享的数据集合。</p>
<p><strong>数据库管理系统（DBMS）</strong>是数据库系统的核心软件之一，是位于用户与操作系统之间的数据管理软件，用于建立，使用和维护数据库。它的主要功能包括数据定义、数据操作、数据库的运行管理、数据库的建立和维护等几个方面。</p>
<h2 id="关系型数据库和非关系型数据库"><a href="#关系型数据库和非关系型数据库" class="headerlink" title="关系型数据库和非关系型数据库"></a>关系型数据库和非关系型数据库</h2><h3 id="关系型数据库"><a href="#关系型数据库" class="headerlink" title="关系型数据库"></a>关系型数据库</h3><p>关系型数据库是建立在关系模型基础上的数据库，借助于集合代数等数学概念和方法来处理数据库中的数据。简单说，关系型数据库是由多张能互相连接的表组成的数据库。</p>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ol>
<li>都是使用表结构，格式一致，易于维护。</li>
<li>使用通用的 SQL 语言操作，使用方便，可用于复杂查询。</li>
<li>数据存储在磁盘中，安全。</li>
</ol>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ol>
<li>读写性能比较差，不能满足海量数据的高效率读写。</li>
<li>不节省空间。因为建立在关系模型上，就要遵循某些规则，比如数据中某字段值即使为空仍要分配空间。</li>
<li>固定的表结构，灵活度较低。</li>
</ol>
<p>常见的关系型数据库有 Oracle、DB2、PostgreSQL、Microsoft SQL Server、Microsoft Access 和 MySQL 等。</p>
<h3 id="非关系型数据库"><a href="#非关系型数据库" class="headerlink" title="非关系型数据库"></a>非关系型数据库</h3><p>非关系型数据库又被称为 <a href="http://c.biancheng.net/nosql/" target="_blank" rel="noopener">NoSQL</a>（Not Only SQL )，意为不仅仅是 SQL。通常指数据以对象的形式存储在数据库中，而对象之间的关系通过每个对象自身的属性来决定。</p>
<h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><ol>
<li>非关系型数据库存储数据的格式可以是 key-value 形式、文档形式、图片形式等。使用灵活，应用场景广泛，而关系型数据库则只支持基础类型。</li>
<li>速度快，效率高。 NoSQL 可以使用硬盘或者随机存储器作为载体，而关系型数据库只能使用硬盘。</li>
<li>海量数据的维护和处理非常轻松。</li>
<li>非关系型数据库具有扩展简单、高并发、高稳定性、成本低廉的优势。</li>
<li>可以实现数据的分布式处理。</li>
</ol>
<h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><ol>
<li>非关系型数据库暂时不提供 SQL 支持，学习和使用成本较高。</li>
<li>非关系数据库没有事务处理，没有保证数据的完整性和安全性。适合处理海量数据，但是不一定安全。</li>
<li>功能没有关系型数据库完善。</li>
</ol>
<p>常见的非关系型数据库有 Neo4j、<a href="http://c.biancheng.net/mongodb/" target="_blank" rel="noopener">MongoDB</a>、<a href="http://c.biancheng.net/redis/" target="_blank" rel="noopener">Redis</a>、Memcached、MemcacheDB 和 <a href="http://c.biancheng.net/hbase/" target="_blank" rel="noopener">HBase</a></p>
<h2 id="数据库系统和组成"><a href="#数据库系统和组成" class="headerlink" title="数据库系统和组成"></a>数据库系统和组成</h2><p><strong>数据库系统（Database System，DBS）</strong>由硬件和软件共同构成。硬件主要用于存储数据库中的数据，包括计算机、存储设备等。软件部分主要包括数据库管理系统、支持数据库管理系统运行的操作系统，以及支持多种语言进行应用开发的访问技术等。</p>
<h3 id="数据库：用于存储数据的地方。"><a href="#数据库：用于存储数据的地方。" class="headerlink" title="数据库：用于存储数据的地方。"></a>数据库：用于存储数据的地方。</h3><p>数据库（DataBase，DB）提供了一个存储空间来存储各种数据，可以将数据库视为一个存储数据的容器。一个数据库可能包含许多文件，一个数据库系统中通常包含许多数据库。</p>
<h3 id="数据库管理系统：用于管理数据库的软件。"><a href="#数据库管理系统：用于管理数据库的软件。" class="headerlink" title="数据库管理系统：用于管理数据库的软件。"></a>数据库管理系统：用于管理数据库的软件。</h3><p>数据库管理系统（Database Management System，DBMS）是用户创建、管理和维护数据库时所使用的软件，位于用户和操作系统之间，对数据库进行统一管理。DBMS 能定义数据存储结构，提供数据的操作机制，维护数据库的安全性、完整性和可靠性。</p>
<h4 id="数据定义功能"><a href="#数据定义功能" class="headerlink" title="数据定义功能"></a>数据定义功能</h4><p>DBMS 提供数据定义语言（Data Definition Language，DDL），用户通过它可以方便地对数据库中的数据对象进行定义。</p>
<h4 id="数据操纵功能"><a href="#数据操纵功能" class="headerlink" title="数据操纵功能"></a>数据操纵功能</h4><p>DBMS 还提供数据操纵语言（Data Manipulation Language，DML），用户可以使用 DML 操作数据，实现对数据库的基本操作，如查询、插入、删除和修改等。</p>
<h4 id="数据库的运行管理"><a href="#数据库的运行管理" class="headerlink" title="数据库的运行管理"></a>数据库的运行管理</h4><p>数据库在建立、运用和维护时由数据库管理系统统一管理、统一控制，以保证数据的安全性、完整性、多用户对数据的并发使用及发生故障后的系统恢复。例如：</p>
<ul>
<li>数据的完整性检查功能保证用户输入的数据应满足相应的约束条件；</li>
<li>数据库的安全保护功能保证只有赋予权限的用户才能访问数据库中的数据；</li>
<li>数据库的并发控制功能使多个用户可以在同一时刻并发地访问数据库的数据；</li>
<li>数据库系统的故障恢复功能使数据库运行出现故障时可以进行数据库恢复，以保证数据库可靠地运行。</li>
</ul>
<h4 id="提供方便、有效地存取数据库信息的接口和工具"><a href="#提供方便、有效地存取数据库信息的接口和工具" class="headerlink" title="提供方便、有效地存取数据库信息的接口和工具"></a>提供方便、有效地存取数据库信息的接口和工具</h4><p>编程人员可通过编程语言与数据库之间的接口进行数据库应用程序的开发。数据库管理员（Database Administrator，DBA）可通过提供的工具对数据库进行管理。</p>
<h4 id="数据库的建立和维护功能"><a href="#数据库的建立和维护功能" class="headerlink" title="数据库的建立和维护功能"></a>数据库的建立和维护功能</h4><p>数据库功能包括数据库初始数据的输入、转换功能，数据库的转储、恢复功能，数据库的重组织功能和性能监控、分析功能等。这些功能通常由一些使用程序来完成。</p>
<h4 id="数据库应用程序：为了提高数据库系统的处理能力所使用的管理数据库库的软件补充。"><a href="#数据库应用程序：为了提高数据库系统的处理能力所使用的管理数据库库的软件补充。" class="headerlink" title="数据库应用程序：为了提高数据库系统的处理能力所使用的管理数据库库的软件补充。"></a>数据库应用程序：为了提高数据库系统的处理能力所使用的管理数据库库的软件补充。</h4><p>数据库应用程序（DataBase Application）的使用可以满足对数据管理的更高要求，还可以使数据管理过程更加直观和友好。数据库应用程序负责与 DBMS 进行通信、访问和管理 DBMS 中存储的数据，允许用户插入、修改、删除数据库中的数据。</p>
<h3 id="访问接口"><a href="#访问接口" class="headerlink" title="访问接口"></a>访问接口</h3><h4 id="ODBC"><a href="#ODBC" class="headerlink" title="ODBC"></a>ODBC</h4><p>ODBC（Open Database Connectivity，开放数据库互连）为访问不同的 SQL 数据库提供了一个共同的接口。ODBC 使用 SQL 作为访问数据的标准。这一接口提供了最大限度的互操作性。一个应用程序可以通过共同的一组代码访问不同的 SQL 数据库管理系统。</p>
<h4 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h4><p>Java Data Base（JDBC，Java 数据库连接）用于 Java 应用程序连接数据库的标准方法，是一种用于执行 SQL 语句的 Java API，可以为多种关系数据库提供统一访问，它由一组用 Java 语言编写的类和接口组成。</p>
<h4 id="ADO-NET"><a href="#ADO-NET" class="headerlink" title="ADO.NET"></a>ADO.NET</h4><p>ADO.NET 是微软在 .NET 框架下开发设计的一组用于和数据源进行交互的面向对象类库。ADO.NET 提供了对关系数据、XML 和应用程序的访问，允许和不同类型的数据源以及数据库进行交互。</p>
<h4 id="PDO"><a href="#PDO" class="headerlink" title="PDO"></a>PDO</h4><p>PDO（PHP Data Object）为 PHP 访问数据库定义了一个轻量级的、一致性的接口，它提供了一个数据访问抽象层，这样，无论使用什么数据库，都可以通过一致的函数执行查询和获取数据。PDO 是 PHP 5 新加入的一个重大功能。</p>
<h3 id="数据库种类"><a href="#数据库种类" class="headerlink" title="数据库种类"></a>数据库种类</h3><h4 id="层次数据库（Hierarchical-Database，HDB）"><a href="#层次数据库（Hierarchical-Database，HDB）" class="headerlink" title="层次数据库（Hierarchical Database，HDB）"></a>层次数据库（Hierarchical Database，HDB）</h4><p>层次数据库是最早研制成功的数据库系统，它把数据通过层次结构（树形结构）的方式表现出来。层次数据库曾经是数据库的主流，但随着关系数据库的出现和普及，现在已经很少使用了。</p>
<p>比较具有代表性的层次数据库是 IMS（Information Management System）数据库，由 IBM 公司研制成功。</p>
<h4 id="关系型数据库（Relational-Database，RDB）"><a href="#关系型数据库（Relational-Database，RDB）" class="headerlink" title="关系型数据库（Relational Database，RDB）"></a>关系型数据库（Relational Database，RDB）</h4><p>关系型数据库是现在应用最广泛的数据库。关系型数据库在 1969 年诞生，可谓历史悠久。和 Excel 工作表一样，关系型数据库也采用由行和列组成的二维表来管理数据，所以简单易懂。同时，它还使用 SQL（Structured Query Language，结构化查询语言）对数据进行操作。</p>
<p>比较具有代表性的关系型数据库有 Oracle Database、SQL Server、DB2、PostgreSQL 和<a href="http://c.biancheng.net/mysql/" target="_blank" rel="noopener">MySQL</a>。</p>
<h4 id="面向文档（Document-Oriented）数据库"><a href="#面向文档（Document-Oriented）数据库" class="headerlink" title="面向文档（Document-Oriented）数据库"></a>面向文档（Document-Oriented）数据库</h4><p>面向文档数据库会将数据以文档的形式存储。每个文档都是一系列数据项的集合。每个数据项都有一个名称与对应的值，值既可以是简单的数据类型，如字符串、数字和日期等；也可以是复杂的类型，如有序列表和关联对象。</p>
<p>数据存储的最小单位是文档，同一个表中存储的文档属性可以是不同的，数据可以使用XML、JSON或者JSONB等多种形式存储。</p>
<p>具有代表性的面向文档数据库有 MongDB 和 CouchDB。</p>
<h4 id="列存储（Column-oriented）数据库"><a href="#列存储（Column-oriented）数据库" class="headerlink" title="列存储（Column-oriented）数据库"></a>列存储（Column-oriented）数据库</h4><p>列存储数据库将数据存储存在列族（column family）中，一个列族用来存储经常被一起查询的相关数据。例如，如果有一个 Person 类，我们经常会一起查询他们的姓名和年龄而不是薪资。这种情况下，姓名和年龄就会被放入一个列族中，而薪资则在另一个列族中。</p>
<p>列存储数据库通常用来应对分布式存储的海量数据。具有代表性的列存储数据库有 Cassandra 和 <a href="http://c.biancheng.net/hbase/" target="_blank" rel="noopener">HBase</a>。</p>
<h4 id="XML-数据库（XML-Database，XMLDB）"><a href="#XML-数据库（XML-Database，XMLDB）" class="headerlink" title="XML 数据库（XML Database，XMLDB）"></a>XML 数据库（XML Database，XMLDB）</h4><p>XML 数据库是一种支持对 XML（标准通用标记语言下的一个应用）格式文档进行存储和查询等操作的数据管理系统。在系统中，开发人员可以对数据库中的 XML 文档进行查询、导出和指定格式的序列化。</p>
<h4 id="键值存储数据库（Key-Value-Store，KVS）"><a href="#键值存储数据库（Key-Value-Store，KVS）" class="headerlink" title="键值存储数据库（Key-Value Store，KVS）"></a>键值存储数据库（Key-Value Store，KVS）</h4><p>键值存储数据库是用来保存查询所使用的主键（Key）和值（Value）的组合的数据库。具有编程语言知识的读者可以把它想象成关联数组或者散列（hash）。</p>
<p>具有代表性的键值存储数据库有 <a href="http://c.biancheng.net/redis/" target="_blank" rel="noopener">Redis</a>、Memcached 和 MemcachedDB。</p>
<h3 id="常用数据库"><a href="#常用数据库" class="headerlink" title="常用数据库"></a>常用数据库</h3><h4 id="Oracle"><a href="#Oracle" class="headerlink" title="Oracle"></a>Oracle</h4><p>Oracle 是甲骨文公司的一款关系型数据库管理系统，在数据库领域一直处于领先地位的产品，是目前世界上流行的关系型数据库之一，是一种高效率、可靠性好、适应高吞吐量的数据库方案。</p>
<h5 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h5><ol>
<li>Oracle 可移植性好，能在所有主流平台上运行（包括 Windows），完全支持所有工业标准。采用完全开放策略，使客户可以选择最适合解决方案。以及对开发商的全力支持。</li>
<li>获得最高认证级别的 ISO 标准认证，安全性高。</li>
<li>与其它数据库相比，Oracle 性能最高。保持着开放平台下 TPC-D 和 TPC-C 世界记录。</li>
<li>多层次网络计算，支持多种工业标准，可以用 ODBC、JDBC、OCI 等网络客户连接 。</li>
<li>完全向下兼容，因此被广泛应用，且风险低 。</li>
</ol>
<blockquote>
<p>向下兼容指的是高版本支持低版本的或者说后期开发的版本支持和兼容早期开发的版本。</p>
</blockquote>
<h5 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h5><ol>
<li>对硬件的要求高</li>
<li>价格比较昂贵</li>
<li>管理维护麻烦</li>
<li>操作比较复杂</li>
</ol>
<h4 id="SQL-Server"><a href="#SQL-Server" class="headerlink" title="SQL Server"></a>SQL Server</h4><p>SQL Server 是 Microsoft（微软）公司推出的关系型数据库管理系统，主要应用于大型的管理系统中。</p>
<h5 id="优点：-1"><a href="#优点：-1" class="headerlink" title="优点："></a>优点：</h5><ol>
<li>与微软的 Windows 系列操作系统的兼容性很好。</li>
<li>高性能设计，可充分利用 WindowsNT 的优势。</li>
<li>系统管理先进，支持 Windows 图形化管理工具，支持本地和远程的系统管理和配置。</li>
<li>强壮的事务处理功能，采用各种方法保证数据的完整性。</li>
<li>支持对称多处理器结构、存储过程、ODBC，并具有自主的 SQL 语言。</li>
</ol>
<h5 id="缺点：-1"><a href="#缺点：-1" class="headerlink" title="缺点："></a>缺点：</h5><ol>
<li>SQL Server 只能在 Windows 系统上运行，没有丝毫开放性。</li>
<li>没有获得任何安全证书。</li>
<li>多用户时性能不佳 。</li>
<li>只支持 C/S 模式，SQL Server C/S 结构只支持 Windows 客户用 ADO、DAO、OLEDB、ODBC 连接。</li>
</ol>
<h4 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h4><p>MySQL 是一种开放源代码的关系型数据库管理系统，由瑞典 MySQL AB 公司开发，属于 Oracle 旗下产品。因为其速度、可靠性和适应性而备受关注。MySQL 是流行的关系型数据库管理系统之一，在 WEB 应用方面，MySQL 是最好的应用软件之一。</p>
<h5 id="优点：-2"><a href="#优点：-2" class="headerlink" title="优点："></a>优点：</h5><ol>
<li>性能卓越服务稳定，很少出现异常宕机</li>
<li>开放源代码且无版权制约，自主性强、使用成本低。</li>
<li>历史悠久、社区及用户非常活跃，遇到问题，可以很快获取到帮助。</li>
<li>软件体积小，安装使用简单，并且易于维护，安装及维护成本低。</li>
<li>支持多种操作系统，提供多种 API 接口，支持多种开发语言。</li>
</ol>
<h5 id="缺点：-2"><a href="#缺点：-2" class="headerlink" title="缺点："></a>缺点：</h5><ol>
<li>MySQL 最大的缺点是其安全系统，主要是复杂而非标准，只有调用 mysqladmin 来重读用户权限才会发生改变。</li>
<li>MySQL 不允许调试存储过程，开发和维护存储过程很难。</li>
<li>MySQL 不支持热备份。</li>
<li>MySQL 的价格随平台和安装方式变化。</li>
</ol>
<h4 id="Access"><a href="#Access" class="headerlink" title="Access"></a>Access</h4><p>Access 是由 Microsoft（微软）发布的小型关系数据库管理系统，是微软把数据库引擎的图形用户界面和软件开发工具结合在一起的一个数据库管理系统。</p>
<h5 id="优点：-3"><a href="#优点：-3" class="headerlink" title="优点："></a>优点：</h5><ol>
<li>存储方式简单，易于维护管理。Access 的对象有表、查询、窗体、报表、页、宏和模块，以上对象都存放在后缀为（.mdb 或 .accdb）的数据库文件中，便于用户的操作和管理。</li>
<li>Access 是一个面向对象的开发工具，这种基于面向对象的开发方式，使得开发应用程序更为简便。</li>
<li>界面友好、易操作。Access 是一个可视化工具，风格与 Windows 完全一样，用户想要生成对象应用，只要使用鼠标进行拖放即可，非常直观方便。系统还提供了表生成器、查询生成器、报表设计器以及数据库向导、表向导、查询向导、窗体向导、报表向导等工具，使得操作简便，容易使用和掌握。</li>
<li>集成环境，可以处理多种数据信息。Access 基于 Windows 操作系统下的集成开发环境，该环境集成了各种向导和生成器工具，极大地提高了开发人员的工作效率，使得建立数据库、创建表、设计用户界面、设计数据查询、报表打印等可以方便有序地进行。</li>
<li>支持广泛，易于扩展，弹性大。Access 是一个既可以只用来存放数据的数据库，也可以作为一个客户端开发工具来进行数据库应用系统开发。即可以开发方便易用的小型软件，也可以用来开发大型的应用系统。</li>
</ol>
<h5 id="缺点：-3"><a href="#缺点：-3" class="headerlink" title="缺点："></a>缺点：</h5><ol>
<li>不支持并发处理。</li>
<li>数据库存储量小安全性不够高。</li>
<li>Access 是小型数据库，当数据量过大时，一般百M以上（纯数据，不包括窗体、报表等客户端对象）性能会变差。</li>
<li>虽然理论上支持 255 个并发用户，但实际上根本支持不了那么多，如果以只读方式访问大概在 100 个用户左右，而如果是并发编辑，则大概在10-20个用户。</li>
<li>单表记录数过百万时，性能就会变得较差，如果加上设计不良，这个限度还要降低。</li>
<li>不能编译成可执行文件（.exe），必须要安装 Access 运行环境才能使用。</li>
</ol>
<h4 id="DB2"><a href="#DB2" class="headerlink" title="DB2"></a>DB2</h4><p>DB2 是美国 IBM 公司开发的一款支持多媒体、Web 的关系型数据库管理系统。主要应用于大型应用系统，具有较好的可伸缩性，可支持从大型机到单用户环境。</p>
<h5 id="优点：-4"><a href="#优点：-4" class="headerlink" title="优点："></a>优点：</h5><ol>
<li>相比较 MySQL 和 Oracle 两种数据库来说，DB2 提供了高层次的数据利用性、完整性、安全性、可恢复性，以及小规模到大规模地应用程序执行能力，具有与平台无关的基本功能和 SQL 命令。</li>
<li>DB2 采用了数据分级技术，能够使大型数据很方便的下载到数据库服务器，使数据库本地化和远程连接透明化。</li>
<li>拥有非常完备的查询优化器，改善了查询性能，并支持多任务并行查询。</li>
<li>具有很好的网络支持能力，每个子系统可以连接十几万个分布式用户，可同时激活上千个活动线程，对大型分布式应用系统更加使用。</li>
<li>DB2 可跨平台使用。</li>
</ol>
<h5 id="缺点：-4"><a href="#缺点：-4" class="headerlink" title="缺点："></a>缺点：</h5><ol>
<li>配置文件和参数多，且命名不规范。</li>
<li>一些 DB2 产品开发不方便。</li>
<li>和 Oracle 相比，命令多，且没 Oracle 统一规范的好。</li>
<li>由于其设计框架的问题，如果用户对数据库的本身优化和应用程序优化做的不足，那么 DB2 容易出现锁等待现象。</li>
</ol>
<h4 id="PostgreSQL"><a href="#PostgreSQL" class="headerlink" title="PostgreSQL"></a>PostgreSQL</h4><p>PostgreSQL 是一款富有特色的自由数据库管理系统，甚至可以说是最强大的自由软件数据库管理系统。该数据库管理系统支持了目前世界上最丰富的数据类型。是自由软件数据库管理系统中唯一支持事务、子查询、多版本并行控制系统、数据完整性检查等特性的自由软件。</p>
<h5 id="优点：-5"><a href="#优点：-5" class="headerlink" title="优点："></a>优点：</h5><ol>
<li>PostgreSQL 遵循的是 BSD 协议，是一个完全开源、免费、同时非常强大的关系型数据库。</li>
<li>与 PostgreSQL 配合的有很多分布式集群软件，如 pgpool、pgcluster、slony、plploxy 等等，很容易做读写分离、负载均衡、数据水平拆分等方案，而这些 MySQL 则比较难实现。</li>
<li>PostgreSQL 源代码写的很清晰，易读性比 MySQL 强，所以很多公司基本都是以 PostgreSQL 做二次开发的。</li>
<li>PostgreSQL 是多进程的，而 MySQL 是多线程的。并发不高时，MySQL处理速度快，但当并发高的时候，对于现在多核的单台机器上，MySQL 的总体处理性能不如 PostgreSQL，原因是 MySQL 的线程无法充分利用 CPU 的能力。</li>
<li>PostgreSQL 有很强大的查询优化器，支持很复杂的查询处理。</li>
</ol>
<blockquote>
<p>BSD 开源协议是一个给于使用者很大自由的协议。可以自由的使用，修改源代码，也可以将修改后的代码作为开源或者专有软件再发布。</p>
</blockquote>
<h5 id="缺点：-5"><a href="#缺点：-5" class="headerlink" title="缺点："></a>缺点：</h5><ol>
<li>对于简单而繁重的读取操作，相比较其它数据库来说，PostgreSQL 性能较低。</li>
<li>PostgreSQL 数据库扩容花费时间很长。</li>
</ol>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>缓存雪崩、穿透、击穿</title>
    <url>/blog/2022/05/01/%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%E3%80%81%E7%A9%BF%E9%80%8F%E3%80%81%E5%87%BB%E7%A9%BF%E3%80%81/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/blog/assets/css/APlayer.min.css"><script src="/blog/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="缓存雪崩、穿透、击穿"><a href="#缓存雪崩、穿透、击穿" class="headerlink" title="缓存雪崩、穿透、击穿"></a>缓存雪崩、穿透、击穿</h1><h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><h3 id="是什么？"><a href="#是什么？" class="headerlink" title="是什么？"></a>是什么？</h3><p><strong>举个简单的例子</strong>：如果所有首页的Key失效时间都是12小时，中午12点刷新的，我零点有个秒杀活动大量用户涌入，假设当时每秒 6000 个请求，本来缓存在可以扛住每秒 5000 个请求，但是缓存当时所有的Key都失效了。此时 1 秒 6000 个请求全部落数据库，数据库必然扛不住，它会报一下警，真实情况可能DBA都没反应过来就直接挂了。此时，如果没用什么特别的方案来处理这个故障，DBA 很着急，重启数据库，但是数据库立马又被新的流量给打死了。这就是我理解的缓存雪崩。</p>
<p><strong>同一时间大面积失效，那一瞬间Redis跟没有一样，那这个数量级别的请求直接打到数据库几乎是灾难性的，你想想如果打挂的是一个用户服务的库，那其他依赖他的库所有的接口几乎都会报错，如果没做熔断等策略基本上就是瞬间挂一片的节奏，你怎么重启用户都会把你打挂，等你能重启的时候，用户早就睡觉去了，并且对你的产品失去了信心，什么垃圾产品。</strong></p>
<a id="more"></a>

<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><h4 id="设置不同的失效时间"><a href="#设置不同的失效时间" class="headerlink" title="设置不同的失效时间"></a>设置不同的失效时间</h4><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">setRedis（Key，value，<span class="built_in">time</span> + Math.<span class="built_in">random</span>() * <span class="number">10000</span>）；</span><br></pre></td></tr></table></figure>

<p>在批量往<strong>Redis</strong>存数据的时候，把每个Key的失效时间都加个随机值就好了，这样可以保证数据不会在同一时间大面积失效</p>
<h4 id="集群中均匀分布"><a href="#集群中均匀分布" class="headerlink" title="集群中均匀分布"></a>集群中均匀分布</h4><p>如果<strong>Redis</strong>是集群部署，将热点数据均匀分布在不同的<strong>Redis</strong>库中也能避免全部失效的问题，不过本渣我在生产环境中操作集群的时候，单个服务都是对应的单个<strong>Redis</strong>分片，是为了方便数据的管理，但是也同样有了可能会失效这样的弊端，失效时间随机是个好策略。</p>
<h2 id="缓存穿透-恶意攻击"><a href="#缓存穿透-恶意攻击" class="headerlink" title="缓存穿透(恶意攻击)"></a>缓存穿透(恶意攻击)</h2><h3 id="是什么？-1"><a href="#是什么？-1" class="headerlink" title="是什么？"></a>是什么？</h3><p>缓存穿透是指缓存和数据库中都没有的数据，而用户不断发起请求，我们数据库的 id 都是1开始自增上去的，如发起为id值为 -1 的数据或 id 为特别大不存在的数据。这时的用户很可能是攻击者，攻击会导致数据库压力过大，严重会击垮数据库。</p>
<h3 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h3><p>我会在接口层增加校验，比如用户鉴权校验，参数做校验，不合法的参数直接代码Return，比如：id 做基础校验，id &lt;=0的直接拦截等。</p>
<h4 id="缓存null值，设置失效时间"><a href="#缓存null值，设置失效时间" class="headerlink" title="缓存null值，设置失效时间"></a>缓存null值，设置失效时间</h4><p>从缓存取不到的数据，在数据库中也没有取到，这时也可以将对应Key的Value对写为null、位置错误、稍后重试这样的值具体取啥问产品，或者看具体的场景，缓存有效时间可以设置短点，如30秒（设置太长会导致正常情况也没法使用）。</p>
<h4 id="布隆过滤器（Bloom-Filter）"><a href="#布隆过滤器（Bloom-Filter）" class="headerlink" title="布隆过滤器（Bloom Filter）"></a>布隆过滤器（Bloom Filter）</h4><p>是利用高效的数据结构和算法快速判断出你这个Key是否在数据库中存在，不存在你return就好了，存在你就去查了DB刷新KV再return。</p>
<h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><h3 id="是什么？-2"><a href="#是什么？-2" class="headerlink" title="是什么？"></a>是什么？</h3><p><strong>缓存击穿</strong>是指一个Key非常热点，在不停的扛着大并发，大并发集中对这一个点进行访问，当这个Key在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库，就像在一个完好无损的桶上凿开了一个洞。</p>
<h3 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案"></a>解决方案</h3><h4 id="永久保存"><a href="#永久保存" class="headerlink" title="永久保存"></a>永久保存</h4><h4 id="加互斥锁"><a href="#加互斥锁" class="headerlink" title="加互斥锁"></a>加互斥锁</h4>]]></content>
      <categories>
        <category>数据库</category>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>高并发性能指标</title>
    <url>/blog/2022/05/01/%E9%AB%98%E5%B9%B6%E5%8F%91%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87%EF%BC%9AQPS%E3%80%81TPS%E3%80%81RT%E3%80%81%E5%90%9E%E5%90%90%E9%87%8F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/blog/assets/css/APlayer.min.css"><script src="/blog/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="高并发性能指标：QPS、TPS、RT、吞吐量"><a href="#高并发性能指标：QPS、TPS、RT、吞吐量" class="headerlink" title="高并发性能指标：QPS、TPS、RT、吞吐量"></a>高并发性能指标：QPS、TPS、RT、吞吐量</h1><h2 id="QPS，每秒查询"><a href="#QPS，每秒查询" class="headerlink" title="QPS，每秒查询"></a>QPS，每秒查询</h2><p>QPS：Queries Per Second意思是“每秒查询率”，是一台服务器每秒能够相应的查询次数，是对一个特定的查询服务器在规定时间内所处理流量多少的衡量标准。</p>
<p>互联网中，作为域名系统服务器的机器的性能经常用每秒查询率来衡量。</p>
<a id="more"></a>

<h2 id="TPS，每秒事务"><a href="#TPS，每秒事务" class="headerlink" title="TPS，每秒事务"></a>TPS，每秒事务</h2><p>TPS：是Transactions Per Second的缩写，也就是事务数/秒。它是软件测试结果的测量单位。一个事务是指一个客户机向服务器发送请求然后服务器做出反应的过程。客户机在发送请求时开始计时，收到服务器响应后结束计时，以此来计算使用的时间和完成的事务个数。</p>
<h2 id="QPS和TPS不同点"><a href="#QPS和TPS不同点" class="headerlink" title="QPS和TPS不同点"></a>QPS和TPS不同点</h2><p>QPS vs TPS：QPS基本类似于TPS，但是不同的是，对于一个页面的一次访问，形成一个TPS；但一次页面请求，可能产生多次对服务器的请求，服务器对这些请求，就可计入“QPS”之中。如，访问一个页面会请求服务器2次，一次访问，产生一个“T”，产生2个“Q”。</p>
<h2 id="RT，响应时间"><a href="#RT，响应时间" class="headerlink" title="RT，响应时间"></a>RT，响应时间</h2><p>响应时间：执行一个请求从开始到最后收到响应数据所花费的总体时间,即从客户端发起请求到收到服务器响应结果的时间。</p>
<p>响应时间RT(Response-time)，是一个系统最重要的指标之一，它的数值大小直接反应了系统的快慢。</p>
<h2 id="并发数"><a href="#并发数" class="headerlink" title="并发数"></a>并发数</h2><p>并发数是指系统同时能处理的请求数量，这个也是反应了系统的负载能力。</p>
<h2 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h2><p>系统的吞吐量（承压能力）与request对CPU的消耗、外部接口、IO等等紧密关联。单个request 对CPU消耗越高，外部系统接口、IO速度越慢，系统吞吐能力越低，反之越高。</p>
<p>系统吞吐量几个重要参数：QPS（TPS）、并发数、响应时间。</p>
<ol>
<li>QPS（TPS）：（Query Per Second）每秒钟request/事务 数量</li>
<li>并发数： 系统同时处理的request/事务数</li>
<li>响应时间： 一般取平均响应时间</li>
</ol>
<p>理解了上面三个要素的意义之后，就能推算出它们之间的关系：</p>
<ul>
<li><strong>QPS（TPS）= 并发数/平均响应时间</strong></li>
<li><strong>并发数 = QPS*平均响应时间</strong></li>
</ul>
<h2 id="实际举例"><a href="#实际举例" class="headerlink" title="实际举例"></a>实际举例</h2><p>我们通过一个实例来把上面几个概念串起来理解。按二八定律来看，如果每天 80% 的访问集中在 20% 的时间里，这 20% 时间就叫做峰值时间。</p>
<ul>
<li>公式：( 总PV数 * 80% ) / ( 每天秒数 * 20% ) = 峰值时间每秒请求数(QPS)</li>
<li>机器：峰值时间每秒QPS / 单台机器的QPS = 需要的机器</li>
</ul>
<p><strong>1、每天300w PV 的在单台机器上，这台机器需要多少QPS？</strong> </p>
<p>( 3000000 * 0.8 ) / (86400 * 0.2 ) = 139 (QPS)</p>
<p><strong>2、如果一台机器的QPS是58，需要几台机器来支持？</strong><br>        139 / 58 = 3</p>
<h2 id="最佳线程数、QPS、RT"><a href="#最佳线程数、QPS、RT" class="headerlink" title="最佳线程数、QPS、RT"></a>最佳线程数、QPS、RT</h2><p><strong>1、单线程QPS公式：QPS=1000ms/RT</strong><br>对同一个系统而言，支持的线程数越多，QPS越高。假设一个RT是80ms,则可以很容易的计算出QPS,QPS = 1000/80 = 12.5<br>多线程场景，如果把服务端的线程数提升到2，那么整个系统的QPS则为 2*（1000/80） = 25, 可见QPS随着线程的增加而线性增长，那QPS上不去就加线程呗，听起来很有道理，公司也说的通，但是往往现实并非如此。</p>
<p><strong>2、QPS和RT的真实关系</strong></p>
<p>我们想象的QPS、RT关系如下，</p>
<p>单线程 or 纯cpu多线程</p>
<p>实际的QPS、RT关系如下，</p>
<p>高IO线程</p>
<p><strong>3、最佳线程数量</strong><br>刚好消耗完服务器的瓶颈资源的临界线程数，公式如下<br>最佳线程数量=（（线程等待时间+线程cpu时间）/线程cpu时间）* cpu数量<br>特性：</p>
<ul>
<li>在达到最佳线程数的时候，线程数量继续递增，则QPS不变，而响应时间变长，持续递增线程数量，则QPS开始下降。</li>
<li>每个系统都有其最佳线程数量，但是不同状态下，最佳线程数量是会变化的。</li>
<li>瓶颈资源可以是CPU,可以是内存，可以是锁资源，IO资源：超过最佳线程数-导致资源的竞争，超过最佳线程数-响应时间递增。</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
        <category>高并发</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>高并发</tag>
      </tags>
  </entry>
  <entry>
    <title>计算器组成</title>
    <url>/blog/2020/06/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/blog/assets/css/APlayer.min.css"><script src="/blog/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="计算器组成"><a href="#计算器组成" class="headerlink" title="计算器组成"></a>计算器组成</h1><h2 id="硬件"><a href="#硬件" class="headerlink" title="硬件"></a>硬件</h2><p><img data-src="%E7%B3%BB%E7%BB%9F%E7%A1%AC%E4%BB%B6%E7%BB%84%E6%88%90.png" alt="系统硬件组成"></p>
<h3 id="总线"><a href="#总线" class="headerlink" title="总线"></a>总线</h3><p>贯穿整个系统的是一组<strong>电子管道</strong>，称作总线  它<strong>携带信息字节</strong>并负责在各个部件间<strong>传递</strong>。通常总线被设计成<strong>传送定长的字节块</strong> ，也就是字（word)。 字中的字节数（即字长） 是一个基本的系统参数，各个系统中都不尽相同。现在的大多数机器字长要么是 4 个字节（32位）， 要么是 8 个字节(64 位）。  </p>
<h3 id="I-O设备"><a href="#I-O设备" class="headerlink" title="I/O设备"></a>I/O设备</h3><p>1/〇(输入/输出）设备是<strong>系统与外部世界</strong>的联系<strong>通道</strong>。  </p>
<p>每个 I/O 设备都通过一个控制 器或适 配器与 I/O 总线相连。控制器和适配器之间的区别主要在于它们的封装方式。</p>
<p>控制器是 I/O 设备本身或者系统的主印制电路板（通常称作<br>主板)上的芯片组。</p>
<p>适配器则是一块插在主板插槽上的卡。  </p>
<a id="more"></a>

<h3 id="主存"><a href="#主存" class="headerlink" title="主存"></a>主存</h3><p>主存是一个<strong>临时存储</strong>设备， 在处理器执行程序时，用来存放程序和程序处理的数据。  从物理上来说， 主存是由一组动态随机存取存储器(DRAM)芯片组成的。 从逻辑上来说，存储器是一个线性的字节数组， 每个字节都有其唯一的地址（数组索引）， 这些地址是从零开始的。  </p>
<h3 id="处理器（CPU"><a href="#处理器（CPU" class="headerlink" title="处理器（CPU)"></a>处理器（CPU)</h3><p>中央处理单元, 简称处理器， 是解释（或执行） 存储在主存中指令的引擎。  处理器的核心是一个大小为一个字的存储设备（或寄存器 ）， 称为程序 计数器（PC)。 在任何时刻， PC 都指向主存中的某条机器语言指令（即含有该条指令的地址）  。</p>
<p>从系统通电开始， 直到系统断电，处理器一直在不断地执行程序计数器指向的指令，再更新程序计数器， 使其指向下一条指令。处理器看上去是按照一个非常简单的指令执行模型来操作的，这个模型是由指令集架构决定的。在这个模型中，指令按照严格的顺序执<br>行，而执行一条指令包含执行一系列的步骤。处理器从程序计数器指向的内存处读取指令，解释指令中的位， 执行该指令指示的简单操作，然后更新 PCÿ 使其指向下一条指令，而这条指令并不一定和在内存中刚刚执行的指令相邻。  </p>
<p>寄存器文件是一个小的存储设备，由一些单个字长的寄存器组成，每个寄存器都有唯一的名字。 ALU 计算新的 数据和 地址值。下面是一些简单 操作的例子，CPU 在指令的要求下可能会执行这些操作。  </p>
<ul>
<li>加载： 从主存复制一个字节或者一个字到寄存器，以覆盖寄存器原来的内容。</li>
<li>存储： 从寄存器复制一个字节或者一个字到主存的某个位置， 以覆盖这个位置上原来的内容。</li>
<li>操作： 把两个寄存器的内容复制到 ALU, ALU 对这两个字做算术运算，并将结果存放到一个寄存器中，以覆盖该寄存器中原来的内容。</li>
<li>跳转：从指令本身中抽取一个字，并将这个字复制到程序计数器（PC)中， 以覆盖PC 中原来的值  。</li>
</ul>
<p>指令集架构描述的是每条机器代码指令的效果； 而微体系结构描述的是处理器实际上是如何实现的。</p>
<h3 id="高速缓存"><a href="#高速缓存" class="headerlink" title="高速缓存"></a>高速缓存</h3><p>根据机械原理，较大的存储设备要比较小的存储设备运行得慢，而快速设备的造价远高于同类的低速设备。   比如说，一个典型系统上的磁盘驱动器可能比主存大 1000 倍， 但是对处理器而言，从磁盘驱动器上读取一个字的时间开销要比从主存中读取的开销大 1000万倍。</p>
<p>类似地，一个典型的寄存器文件只存储几百字节的信息，而主存里可存放几十亿字节。然而，处理器从寄存器文件中读数据比从 主存中读取几乎要快 100 倍。 更麻烦的是，随着这些年半导体技术的进步，这种处理 器与主存之间的差距还在持续增大。加快处理器<br>的运行速度比加快主存的运行速度要容易和便宜得多。</p>
<p>  针对这种<strong>处理器与主存之间的差异</strong>，系统设计者采用了更小更快的存储设备，称为高速缓存存储器（cache memory, 简称为 cache 或高速缓存）， 作为暂时的集结区域， 存放处理器近期可能会需要的信息。  </p>
<p><img data-src="%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98.png" alt="高速缓存"></p>
<p>上图展示了一个典型系统中的髙速缓存存储器。位于处理<br>器芯片上的 L1 高速缓存的容量可以达到数万字节，访问速度几乎和访问寄存器文件一样快。 一个容量为数十万到数百万字节的更大的 L2 高速缓存通过一条特殊的总线连接到处理器。进程访问 L2 高速缓存的时间要比访问 L1 高速缓存的时间长 5 倍，但是这仍然比访<br>问主存的时间快 5〜10 倍。 L1 和 L2 高速缓存是用一种叫做静态随机访问存储器（SRAM)的硬件技术实现的。比较新的、处理能力更强大的系统甚至有三级高速缓存： LI,L2 和L3。系统可以获得一个很大的存储器，同时访问速度也很快， 原因是利用了高速缓存的局部性原理，即程序具有访问局部区域里的数据和代码的趋势。 通过让高速缓存里存放可能经常访问的数据，大部分的内存操作都能在快速的高速缓存中完成  。</p>
<h3 id="存储设备形成层次结构"><a href="#存储设备形成层次结构" class="headerlink" title="存储设备形成层次结构"></a>存储设备形成层次结构</h3><p>每个计算机系统中的存储设备都被组织成了一个存储器层次结构，在这个层次结构中，从上至下，设备的访问速度越来越慢、 容量越来越大，并且每字节的造价也越来越便宜。寄存器文件在层次结<br>构中位于最顶部，也就是第 0级或记为 L0这里我们展示的是三层高 速缓存 L1 到 L3,占据存储器层次结构的第 1 层到第 3 层。主存在第 4 层，以此类推。  </p>
<p><img data-src="%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84.png" alt="存储器层次结构"></p>
<p>存储器层次结构的主要思想是上一层的存储器作为低一层存储器的高速缓存。因此，寄存器文件就是 L1 的高速缓存， L1 是 L2 的高速缓存， L2 是 L3 的高速缓存， L3 是主存的高速缓存，而主存又是磁盘的高速缓存。 在某些具有分布式文件系统的网络系统中，本<br>地磁盘就是存储在其他系统中磁盘上的数据的高速缓存。</p>
<h3 id="操作系统管理硬件"><a href="#操作系统管理硬件" class="headerlink" title="操作系统管理硬件"></a>操作系统管理硬件</h3><p>操作系统有两个基本功能： </p>
<h4 id="基本功能"><a href="#基本功能" class="headerlink" title="基本功能"></a>基本功能</h4><ul>
<li>防止硬件被失控的应用程序滥用</li>
<li>向应用程序提供简单一致的机制来控制复杂而又通常大不相同的低级硬件设备。</li>
</ul>
<p>操作系统通过几个基本的抽象概念（进程、虚拟内存和文件） 来实现这两个功能。</p>
 <img data-src="操作系统提供的抽象表示.png" alt="操作系统提供的抽象表示" style="zoom:200%;" />

<h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>进程是操作系统对一个正在运行的程序的一种抽象。在一个系统上可以同时运行多个进程，而每个进程都好像在独占地使用硬件。而并发运行，则是说一个进程的指令和另一个进程的指令是交错执行的。    </p>
<p>无论是在单核还是多核系统中，一个 CPU 看上去都像是在并发地执行多个进程，这是通过处理器在进程间切换来实现的。操作系统实现这种交错执行的机制称为上下文切换。  </p>
<p><img data-src="%E8%BF%9B%E7%A8%8B%E7%9A%84%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2.png" alt="进程的上下文切换"></p>
<h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>一个进程实际上可以由多个称为线程的执行单元组成，每个线程都运行在进程的上下文中， 并共享同样的代码和全局数据。  </p>
<h3 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h3><p>虚拟内存是一个抽象概念，它为每个进程提供了一个假象， 即每个进程都在独占地使用主存。每个进程看到的内存都是一致的，称为虚拟地址空间。  </p>
<p><img data-src="%E8%BF%9B%E7%A8%8B%E7%9A%84%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4.png" alt="进程的虚拟地址空间"></p>
<h3 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h3><p>文件就是<strong>字节序列</strong>，仅此而已。每个 I/O 设备，包括磁盘、键盘、显示器， 甚至网络，都可以看成是文件。系统中的所有输人输出都是通过使用一小组称为 Unix I/O 的系统函数调用读写文件来实现的。</p>
<p>文件这个简单而精致的概念是非常强大的，因为它向应用程序提供了一个统一的视图， 来看待系统中可能含有的所有各式各样的 I/O 设备。例如，处理磁盘文件内容的应用程序员可以非常幸福，因为他们无须了解具体的磁盘技术。进一步说，同一个程序可以在<br>使用不同磁盘技术的不同系统上运行。  </p>
<h3 id="并发和并行"><a href="#并发和并行" class="headerlink" title="并发和并行"></a>并发和并行</h3><p>数字计算机的整个历史中，有两个需求是驱动进步的持续动力： 一个是我们想要计算机做得更多，另一个是我们想要计算机运行得更快。当处理器能够同时做更多的事情时，这两个因素都会改进。</p>
<p>并发(concurrency)是一个通用的概念， 指一个同时具有多个活动的系统； </p>
<p>并行（parallelism)指的是用并发来使一个系统运行得更快。并行可以在计算机系统的多个抽象层次上运用。</p>
<p>在此，我们按照系统层次结构中由高到低的顺序重点强调三个层次。  </p>
<h4 id="线程级并发"><a href="#线程级并发" class="headerlink" title="线程级并发"></a>线程级并发</h4><p>构建在进程这个抽象之上，我们能够设计出同时有多个程序执行的系统，这就导致了并发。使用线程，我们甚至能够在一个进程中执行多个控制流。  </p>
<p>当构建一个由单操作系统内核控制的多处理器组成的系统时，我们就得到了一个多处理器系统。  </p>
<p>多核处理器是将多个 CPU(称为“核”)集成到一个集成电路芯片上。</p>
<p><img data-src="%E5%A4%9A%E6%A0%B8%E5%A4%84%E7%90%86%E5%99%A8.png" alt="多核处理器"></p>
<h2 id="信息表示和处理"><a href="#信息表示和处理" class="headerlink" title="信息表示和处理"></a>信息表示和处理</h2><h3 id="信息存储"><a href="#信息存储" class="headerlink" title="信息存储"></a>信息存储</h3><p>大多数计算机使用 8 位的块，或者字节（byte), 作为最小的可寻址的内存单位，而不是访问内存中单独的位。机器级程序将内存视为一个非常大的字节数组， 称为虚拟内存(virtual memory) 内存的每个 字节都由一个唯一的数字来 标识， 称为它的地址（address) 所有可能地址的集合就称为虚拟地址空间（virtual address space)。</p>
<h3 id="进制"><a href="#进制" class="headerlink" title="进制"></a>进制</h3><p>在生活中，我们通常都是使用阿拉伯数字计数的，也就是10进制，以10为单位，遇10进一，所以是由0，1，2、3、4、5、6、7、8、9这个10个数字组成的；而在计算机中，计算机是无法识别10进制数的，它只能识别0和1，也就是二进制，由0、1两位数字组成，其运算规则是逢二进一。数字在计算机底层都以二进制形式存在，计算机则是以补码的形式保存所有的整数。</p>
<p>进制就是进位制，是人们规定的一种数字进位方法；对于任何一种进制（X进制），都表示某一位置上的数运算时是逢X进一位，如：二进制就是逢二进一，八进制就是逢八进一， 十进制是逢十进一，十六进制是逢十六进一，以此类推。</p>
<h4 id="二进制表示法"><a href="#二进制表示法" class="headerlink" title="二进制表示法"></a>二进制表示法</h4><p>由0，1组成，运算规律是逢二进一，计算机只能识别二进制表示的数据；</p>
<h4 id="八进制表示法"><a href="#八进制表示法" class="headerlink" title="八进制表示法"></a>八进制表示法</h4><p>由0、1、2、3、4、5、6、7组成，运算规律是逢八进一；</p>
<h4 id="十进制表示法"><a href="#十进制表示法" class="headerlink" title="十进制表示法"></a>十进制表示法</h4><p>由0，1，2、3、4、5、6、7、8、9组成，运算规律是逢十进一；</p>
<h4 id="十六进制表示法"><a href="#十六进制表示法" class="headerlink" title="十六进制表示法"></a>十六进制表示法</h4><p>由数字0～9以及字母A，B，C，D，E，F组成，运算规律是逢十六进一；</p>
<h4 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h4><h5 id="十进制和二进制之间相互转换"><a href="#十进制和二进制之间相互转换" class="headerlink" title="十进制和二进制之间相互转换"></a>十进制和二进制之间相互转换</h5><h6 id="十进制转二进制"><a href="#十进制转二进制" class="headerlink" title="十进制转二进制"></a>十进制转二进制</h6><p>对于整数部分，用被除数反复除以2，除第一次外，每次除以2均取前一次商的整数部分作被除数并依次记下每次的余数。</p>
<p>所得到的商的最后一位余数是所求二进制数的最高位。</p>
<p><img data-src="%E5%8D%81%E8%BF%9B%E5%88%B6%E8%BD%AC%E4%BA%8C%E8%BF%9B%E5%88%B6.png" alt="十进制转二进制"></p>
<h6 id="二进制转十进制"><a href="#二进制转十进制" class="headerlink" title="二进制转十进制"></a>二进制转十进制</h6><p>进制数第1位的权值是2的0次方，第2位的权值是2的1次方，第2位的权值是2的2次方，依次计算，公式：第N位 * 2的N-1次方，结果再相加便是最后结果。<img data-src="%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%BD%AC%E5%8D%81%E8%BF%9B%E5%88%B6.png" alt="二进制转十进制"></p>
<h3 id="二进制数字存储单位"><a href="#二进制数字存储单位" class="headerlink" title="二进制数字存储单位"></a>二进制数字存储单位</h3><p>在计算机的数据存储系统中，数据存储的最小单位是位，位简记为bit，也称为比特；每个二进制数字0或1就是一个位(bit)，也就是一比特；也可以把二进制中的0和1看做开关中的“开”和“关”，1表示“开”，0表示“关”。另外，也可以把0和1的数据带到道家的阴阳八卦中去理解，0表示阴，1表示阳，0和1的转换就是阴阳的交替。 8 bit（位）= 1B，也就是一个字节（Byte），然而1KB却不等于1000B。</p>
<p>下面是详细的计算规则： </p>
<ul>
<li><p>1B（byte，字节）= 8 bit；</p>
</li>
<li><p>1KB（Kibibyte，千字节）= 1024B = 2^10 B；</p>
</li>
<li><p>1MB（Mebibyte，兆字节，百万字节，简称“兆”）= 1024KB = 2^20 B；</p>
</li>
<li><p>1GB（Gigabyte，吉字节，十亿字节，又称“千兆”）= 1024MB = 2^30 B；</p>
</li>
<li><p>1TB（Terabyte，万亿字节，太字节）= 1024GB = 2^40 B；</p>
</li>
<li><p>1PB（Petabyte，千万亿字节，拍字节）= 1024TB = 2^50 B； </p>
</li>
</ul>
<p>以上这些是二进制数的存储单位计算规则，而在硬盘容量也能看到类似的单位，但是硬盘的容量通常是以十进制标识的，所以显示有500G容量的硬盘实际容量却不足500G。</p>
<h3 id="原码、反码和补码"><a href="#原码、反码和补码" class="headerlink" title="原码、反码和补码"></a>原码、反码和补码</h3><p>在计算机内，有符号数（这里的符号指的是正负符号，有符号数指的就是正负数）有3种表示法：原码、反码和补码，所有数据的运算都是采用补码进行的，也就是基于补码来做计算。 在二进制中，二进制数的最左边为最高位，根据二进制定点表示法，二进制最高位为符号位，“0”表示正，“1”表示负，其余位表示数值的大小。也就是说二进制最左边的数决定了这个数是正数，还是负数，正数的符号位是0，负数的符号位是</p>
<p>1。 正数的原码，反码，补码都相同；</p>
<p> 负数的则有不同的计算规则，详情如下：</p>
<p> 原码：负数的原码和正数的原码差别就在最高位，正数的符号位是0，负数的符号位是1； </p>
<p>反码：负数的反码是对其原码逐位取反（0变1，1变0），但符号位（最高位）除外，因为最高位（符号位）是不能被改变的；</p>
<p> 补码：负数的补码是在其反码的末位加1（逢二进一）；</p>
<p> 需要注意的是：求反码的时候，最高位（符号位）是不能被改变的， 正数的符号位是0，负数的符号位是1。</p>
<p><img data-src="%E5%8E%9F%E7%A0%81%E5%8F%8D%E7%A0%81%E8%A1%A5%E7%A0%81.png" alt="原码反码补码"></p>
]]></content>
      <categories>
        <category>计算机系统</category>
      </categories>
      <tags>
        <tag>计算机系统</tag>
        <tag>程序运行</tag>
      </tags>
  </entry>
  <entry>
    <title>网关</title>
    <url>/blog/2020/08/18/%E7%BD%91%E5%85%B3/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/blog/assets/css/APlayer.min.css"><script src="/blog/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="网关"><a href="#网关" class="headerlink" title="网关"></a>网关</h1><h2 id="什么是API网关"><a href="#什么是API网关" class="headerlink" title="什么是API网关"></a>什么是API网关</h2><p>API网关是一个服务器，是<strong>系统的唯一入口</strong>。从面向对象设计的角度看，它与<strong>外观模式</strong>类似。API网关封装了系统内部架构，为每个客户端提供一个定制的API。它可能还具有其它职责，如身份验证、监控、负载均衡、缓存、请求分片与管理、静态响应处理。</p>
<a id="more"></a>

<p>API网关方式的核心要点是，所有的客户端和消费端都通过统一的网关接入微服务，在网关层处理所有的非业务功能。通常，网关也是提供REST/HTTP的访问API。服务端通过API-GW注册和管理服务。</p>
<p><img data-src="%E7%BD%91%E5%85%B3.png" alt="网关"></p>
<h2 id="为什么需要API网关"><a href="#为什么需要API网关" class="headerlink" title="为什么需要API网关"></a>为什么需要API网关</h2><p>下面从单体应用到微服务演变的过程去阐述，回顾单体应用时代，在业务简单、团队组织规模很小的时候，我们常常把功能都几种与一个应用中，统一部署，统一测试，如下图：<img data-src="%E5%8D%95%E4%BD%93%E5%BA%94%E7%94%A8.png" alt="单体应用">        随着业务的迅速发展，组织成员日益增多。将所有的功能几种在一个Tomcat中的时候，每更新一个功能模块，势必要更新所有的程序。牵一发而动全身，系统将很难维护。</p>
<p>单体应用满足不了日趋增长的需求之后，微服务出现了。我们利用微服务的思想，将原来的单体应用进行微服务化。将原来集中于一体的功能（如商品、订单服务）进行拆分，每个功能模块又各自的自成体系的发布、运维等功能。这样就解决了单体应用的弊端，如下：</p>
<p><img data-src="%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%9A%84%E6%80%9D%E6%83%B3.png" alt="微服务的思想"></p>
<p>这时，我们还没有看到API Gateway。举例来说，原先IOS、Android、PC客户端调用服务的地方，需要多个URL地址，有订单的、商品的、用户的。微服务化后就必须有统一的出入口，这种情况下，API Gateway就出现了。API Gateway很好的解决了微服务下调用、统一接入等问题，如下图所示：</p>
<p><img data-src="api%E7%BD%91%E5%85%B3.png" alt="api网关"></p>
<p>有了API网关之后，各个API服务提供团队可以专注于自己的业务逻辑处理，而API网关更专注于安全、流量、路由等问题。</p>
<p>看到上面的图示与描述，我们可能会想到另外一个与网关类似的东西——代理。网关与代理的区别：代理是纯粹的数据透传，协议不会发生变化；网关在数据透传的背景下，还有设计协议的转换，比如上图中用户请求传输到网关的协议是HTTP，通过网关透传到下游则可能已经转换成企业内部的RPC了(比如JSF、Dubbo等企业自研的RPC框架)。</p>
<h2 id="网关的分类和功能"><a href="#网关的分类和功能" class="headerlink" title="网关的分类和功能"></a>网关的分类和功能</h2><p><img data-src="%E7%BD%91%E5%85%B3%E5%88%86%E7%B1%BB%E5%92%8C%E5%8A%9F%E8%83%BD.jpg" alt="网关分类和功能"></p>
<h2 id="主流网关"><a href="#主流网关" class="headerlink" title="主流网关"></a>主流网关</h2><h3 id="Zuul-2-0"><a href="#Zuul-2-0" class="headerlink" title="Zuul 2.0"></a>Zuul 2.0</h3><h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>Zuul是Netflix 出品的一个基于 JVM 路由和服务端的负载均衡器，在2014年被Pivotal集成至Spring Cloud微服务框架中。Zuul设计理念在于实现动态路由、监视、弹性、安全性等功能, 其亮点在于可动态发布的过滤器机制。</p>
<h4 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h4><p>Zuul 2.0是一个运行前置过滤器(inbound filters)的Netty服务，然后使用一个Netty客户端代理请求，然后在运行后置过滤器(outbound filters)后返回响应。</p>
<p><img data-src="zuul2%E6%9E%B6%E6%9E%84%E5%9B%BE.png" alt="zuul2架构图"></p>
<h4 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h4><p>过滤器是Zuul业务逻辑的核心所在。它们具有执行大量动作的能力，并且可以在请求-响应生命周期的不同部分运行，如上图所示。</p>
<ul>
<li><strong>前置过滤器</strong>在在代理请求之前运行，并且可以用于身份验证，路由和修饰请求之类的操作。</li>
<li><strong>端点过滤器</strong>可用于返回静态响应，否则内置<code>ProxyEndpoint</code>过滤器会将请求路由到源。</li>
<li><strong>后置过滤器</strong>在返回响应后运行，可用于装饰客户端响应或添加自定义响应头。</li>
</ul>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p>Zuul基于java开发，java由于拥有大量群众基础，因此对大多数程序员友好。</p>
<p>API应具备多种定制化流量控制，由于Spring cloud基于Java平台的原因，故对于绝大多数开发人员来说兼容性高。</p>
<p>开源时间长，落地实践多，生产环境下运行稳定，坑少。</p>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>Zuul出世尚早，云原生概念还不普及，因此没有针对云原生的理念去设计API网关，也没有原生兼容Kubernetes、Mesos等容器编排平台，网关本身也不是CRD资源。再者就是Spring cloud支持java，所以对于Zuul来说扩展性低。</p>
<p>有些读者可能会有疑问，既然Zuul是基于Spring Cloud微服务框架设计的API网关，那么在目前流行的Kubernetes平台上岂不是发挥不了其优势了，其实Spring Cloud也考虑过这点，如何在脱离Spring Cloud的情况下在Kubernetes上使用Zuul，于是Spring旗下开发了一个子项目Spring cloud Kubernetes，其作用就是将Kubernetes中的服务模型映射至Spring cloud服务模型中，从而可以使用Spring cloud的sdk去实现对Kubernetes服务的管理。借助于Spring cloud Kubernetes项目，Zuul可以和Kubernetes融合并实现API网关能力，也可勉强称作云原生API网关。但是换个角度想问题， Kubernetes天然具备微服务能力，且有许多相应的原生API网关，我们为何不去使用呢？在Spring Cloud与Kubernetes中间强加一层适配器似乎有点多此一举的意思。</p>
<p>就安全层面而言，Zuul通过安全框架可以实现绝大多数安全功能，但因为这些安全框架多基于Java编写，很难应用到在以Go语言为主的云原生平台中，这也是Zuul在安全层面面临的现状。</p>
<h3 id="Kong"><a href="#Kong" class="headerlink" title="Kong"></a><a href="https://docs.konghq.com/" target="_blank" rel="noopener">Kong</a></h3><h4 id="背景-1"><a href="#背景-1" class="headerlink" title="背景"></a>背景</h4><p>Kong是一个云原生，快速可扩展的分布式微服务抽象层（通常被称作API网关，API中间件或服务网格），其核心价值是高性能和可扩展性，于2015年作为一个开源项目提供。</p>
<p>简单的说，Kong在Nginx的反向代理基础上，通过Lua实现了脚本化的扩展，同时所有管理功能都是通过REST来实现。其内部还使用了大量的缓存，所以基本没有阻塞式的操作，性能非常优秀。</p>
<p>Kong的扩展性主要体现在其插件机制，可方便的为路由添加各种插件，</p>
<p>我们来先了解下另一种不陌生的中间件——OpenResty。</p>
<h4 id="OpenResty"><a href="#OpenResty" class="headerlink" title="OpenResty"></a>OpenResty</h4><p>OpenResty是一个基于 Nginx 与 Lua 的高性能 Web 平台，其内部集成了大量精良的 Lua 库、第三方模块以及大多数的依赖项。用于方便地搭建能够处理超高并发、扩展性极高的动态 Web 应用、Web 服务和动态网关。因此，我们可以做出各种符合我们需要的网关策略的Lua脚本，以其为基础构建高性能的网关系统。</p>
<h4 id="Kong-1"><a href="#Kong-1" class="headerlink" title="Kong"></a>Kong</h4><p>Kong基于OpenResty，是一个云原生、快速、可扩展、分布式的Api 网关。继承了OpenResty的高性能、易扩展性等特点。Kong通过简单的增加机器节点，可以很容易的水平扩展。同时功能插件化，可通过插件来扩展其能力。而且在任何基础架构上都可以运行。具有以下特性：</p>
<ul>
<li>提供了多样化的认证层来保护Api。</li>
<li>可对出入流量进行管制。</li>
<li>提供了可视化的流量检查、监视分析Api。</li>
<li>能够及时的转换请求和相应。</li>
<li>提供log解决方案</li>
<li>可通过api调用Serverless 函数。</li>
</ul>
<h4 id="业务网关与流量网关"><a href="#业务网关与流量网关" class="headerlink" title="业务网关与流量网关"></a>业务网关与流量网关</h4><p><img data-src="%E4%BD%BF%E7%94%A8kong%E6%9E%B6%E6%9E%84%E5%89%8D%E5%90%8E%E5%8F%98%E5%8C%96.png" alt="kong架构"></p>
<p>对于具体的后端业务应用或者是服务和业务有一定关联性的策略网关就是上图左边的架构模型——业务网关。 业务网关针对具体的业务需要提供特定的流控策略、缓存策略、鉴权认证策略等等。</p>
<p>与业务网关相反，定义全局性的、跟具体的后端业务应用和服务完全无关的策略网关就是上图右边所示的架构模型——流量网关。流量网关通常只专注于全局的Api管理策略，比如全局流量监控、日志记录、全局限流、黑白名单控制、接入请求到业务系统的负载均衡等，有点类似防火墙。Kong 就是典型的流量网关。</p>
<p>这里需要补充一点的是，业务网关一般部署在流量网关之后、业务系统之前，比流量网关更靠近业务系统。通常API网指的是业务网关。 有时候我们也会模糊流量网关和业务网关，让一个网关承担所有的工作,所以这两者之间并没有严格的界线。</p>
<h4 id="Kong-的架构"><a href="#Kong-的架构" class="headerlink" title="Kong 的架构"></a>Kong 的架构</h4><p><img data-src="kong%E6%9E%B6%E6%9E%84.jpg" alt="kong架构"></p>
<p><img data-src="Kong-GS-overview.png" alt="Kong-GS-overview"></p>
<table>
<thead>
<tr>
<th align="left">概念/功能</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">服务Service</td>
<td align="left">服务对象是Kong Gateway用来引用其管理的上游API和微服务的ID。</td>
</tr>
<tr>
<td align="left">路线Routes</td>
<td align="left">路由指定在请求到达API网关后如何（以及是否）将请求发送到其服务。单个服务可以具有多个路由。</td>
</tr>
<tr>
<td align="left">消费者Consumers</td>
<td align="left">使用者代表您的API的最终用户。使用使用者对象，您可以控制谁可以访问您的API。他们还允许您使用日志记录插件和Kong Vitals报告流量。</td>
</tr>
<tr>
<td align="left">Kong Manager</td>
<td align="left">Kong Manager是基于视觉浏览器的工具，用于监视和管理Kong Enterprise。</td>
</tr>
<tr>
<td align="left">Admin API</td>
<td align="left">Kong Gateway带有内部RESTful API，用于管理目的。API命令可以在集群中的任何节点上运行，并且配置将一致地应用于所有节点。</td>
</tr>
<tr>
<td align="left">Plugins</td>
<td align="left">插件提供了用于修改和控制Kong Gateway功能的模块化系统。例如，为了保护您的API，您可能需要一个访问密钥，可以使用key-auth插件进行设置。插件提供了广泛的功能，包括访问控制，缓存，速率限制，日志记录等等。</td>
</tr>
<tr>
<td align="left">限速插件Rate Limiting plugin  限速高级插件Rate Limiting Advanced plugin</td>
<td align="left">使用此插件，您可以限制客户端在给定时间内可以发出的HTTP请求数量。  此插件的高级版本还提供了滑动窗口支持，并可以通过标题和服务进行限制。</td>
</tr>
<tr>
<td align="left">代理缓存插件Proxy Caching plugin  代理缓存高级插件Proxy Caching Advanced plugin</td>
<td align="left">该插件提供了反向代理缓存实现。它在给定的时间段内根据响应代码，内容类型和请求方法缓存响应实体。  此插件的高级版本支持Redis和Redis Sentinel部署。</td>
</tr>
<tr>
<td align="left">密钥验证插件Key Auth plugin  密钥验证-加密插件Key Auth - Encrypted plugin</td>
<td align="left">此插件可让您向服务或路由添加密钥身份验证（也称为API密钥）。  此插件的高级版本将API密钥以加密格式存储在Kong Gateway数据存储区中。</td>
</tr>
<tr>
<td align="left">负载均衡Load Balancing</td>
<td align="left">Kong Gateway提供了两种负载平衡方法：基于DNS的直接方法或使用环形平衡器的方法。在本指南中，您将使用环形平衡器，该平衡器需要配置上游和目标实体。使用此方法，后端服务的添加和删除由Kong Gateway处理，并且不需要DNS更新。</td>
</tr>
<tr>
<td align="left">用户授权（RBAC）</td>
<td align="left">Kong Gateway（Enterprise）通过基于角色的访问控制（RBAC）处理用户授权。启用后，RBAC允许您创建团队和管理员，并在工作空间内或跨工作空间为他们分配精细权限。</td>
</tr>
<tr>
<td align="left">开发者门户Developer Portal</td>
<td align="left">开发人员门户网站为所有开发人员提供了一个单一的真实来源，以查找，访问和使用服务。</td>
</tr>
</tbody></table>
<h4 id="请求流程"><a href="#请求流程" class="headerlink" title="请求流程"></a>请求流程</h4><p><img data-src="gateway-traffic.png" alt="gateway-traffic"><br>每个客户请求都会先到达Kong 网关，然后再代理到最终的API。在请求和响应之间，Kong将执行已安装配置的插件，从而扩展API功能集。</p>
<h3 id="Gateway"><a href="#Gateway" class="headerlink" title="Gateway"></a>Gateway</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>Gateway是在Spring生态系统之上构建的API网关服务，基于Spring 5，Spring Boot 2和 Project Reactor等技术。Gateway旨在提供一种简单而有效的方式来对API进行路由，以及提供一些强大的过滤器功能， 例如：熔断、限流、重试等。</p>
<p>Spring Cloud Gateway 具有如下特性：</p>
<ul>
<li>基于Spring Framework 5, Project Reactor 和 Spring Boot 2.0 进行构建；</li>
<li>动态路由：能够匹配任何请求属性；</li>
<li>可以对路由指定 Predicate（断言）和 Filter（过滤器）；</li>
<li>集成Hystrix的断路器功能；</li>
<li>集成 Spring Cloud 服务发现功能；</li>
<li>易于编写的 Predicate（断言）和 Filter（过滤器）；</li>
<li>请求限流功能；</li>
<li>支持路径重写。</li>
</ul>
<h4 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h4><p><strong>Route（路由）</strong>：路由是构建网关的基本模块，它由ID，目标URI，一系列的断言和过滤器组成，如果断言为true则匹配该路由；</p>
<p><strong>Predicate（断言）</strong>：指的是Java 8 的 Function Predicate。 输入类型是Spring框架中的ServerWebExchange。 这使开发人员可以匹配HTTP请求中的所有内容，例如请求头或请求参数。如果请求与断言相匹配，则进行路由；</p>
<p><strong>Filter（过滤器）</strong>：指的是Spring框架中GatewayFilter的实例，使用过滤器，可以在请求被路由前后对请求进行修改。</p>
<h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><p><img data-src="spring_cloud_gateway_diagram.png" alt="spring_cloud_gateway_diagram"></p>
<p>客户端向 Spring Cloud Gateway 发出请求。然后在 Gateway Handler Mapping 中找到与请求相匹配的路由，将其发送到 Gateway Web Handler。Handler 再通过指定的过滤器链来将请求发送到我们实际的服务执行业务逻辑，然后返回。过滤器之间用虚线分开是因为过滤器可能会在发送代理请求之前（“pre”）或之后（“post”）执行业务逻辑。</p>
<h4 id="Webflux模型"><a href="#Webflux模型" class="headerlink" title="Webflux模型"></a>Webflux模型</h4><p>Webflux模式替换了旧的Servlet线程模型。用少量的线程处理request和response io操作，这些线程称为Loop线程，而业务交给响应式编程框架处理，响应式编程是非常灵活的，用户可以将业务中阻塞的操作提交到响应式框架的work线程中执行，而不阻塞的操作依然可以在Loop线程中进行处理，大大提高了Loop线程的利用率。官方结构图：</p>
<p><img data-src="webflux%E5%AE%98%E6%96%B9%E6%9E%B6%E6%9E%84.jpg" alt="webflux官方架构"></p>
<p>Webflux虽然可以兼容多个底层的通信框架，但是一般情况下，底层使用的还是Netty，毕竟，Netty是目前业界认可的最高性能的通信框架。而Webflux的Loop线程，正好就是著名的Reactor 模式IO处理模型的Reactor线程，如果使用的是高性能的通信框架Netty，这就是Netty的EventLoop线程。</p>
<h4 id="路由规则"><a href="#路由规则" class="headerlink" title="路由规则"></a>路由规则</h4><p>Spring Cloud Gateway 的功能很强大，我们仅仅通过 Predicates 的设计就可以看出来，Spring Cloud Gataway 帮我们内置了很多 Predicates 功能。</p>
<p>Spring Cloud Gateway 是通过 Spring WebFlux 的 <code>HandlerMapping</code> 做为底层支持来匹配到转发路由，Spring Cloud Gateway 内置了很多 Predicates 工厂，这些 Predicates 工厂通过不同的 HTTP 请求参数来匹配，多个 Predicates 工厂可以组合使用。</p>
<h4 id="断言Predicate-介绍"><a href="#断言Predicate-介绍" class="headerlink" title="断言Predicate 介绍"></a>断言Predicate 介绍</h4><p>Predicate 来源于 Java 8，是 Java 8 中引入的一个函数，Predicate 接受一个输入参数，返回一个布尔值结果。该接口包含多种默认方法来将 Predicate 组合成其他复杂的逻辑（比如：与，或，非）。可以用于接口请求参数校验、判断新老数据是否有变化需要进行更新操作。</p>
<p>在 Spring Cloud Gateway 中 Spring 利用 Predicate 的特性实现了各种路由匹配规则，有通过 Header、请求参数等不同的条件来进行作为条件匹配到对应的路由。下图总结了 Spring Cloud 内置的几种 Predicate 的实现。</p>
<p><img data-src="spring-cloud-gateway-predicate.png" alt="spring-cloud-gateway-predicate"></p>
<h2 id="主流网关对比"><a href="#主流网关对比" class="headerlink" title="主流网关对比"></a>主流网关对比</h2><table>
<thead>
<tr>
<th align="left"></th>
<th align="left">Ambassador</th>
<th align="left">Zuul</th>
<th align="left">Gloo</th>
<th align="left">Kong</th>
<th>Spring Cloud Gateway</th>
</tr>
</thead>
<tbody><tr>
<td align="left">用途</td>
<td align="left">微服务网关</td>
<td align="left">微服务网关</td>
<td align="left">微服务网关</td>
<td align="left">企业级API管理</td>
<td>微服务网关</td>
</tr>
<tr>
<td align="left">版本</td>
<td align="left">社区版/Pro版</td>
<td align="left">社区版</td>
<td align="left">社区版/企业版</td>
<td align="left">社区版/企业版</td>
<td></td>
</tr>
<tr>
<td align="left">Star</td>
<td align="left">2.4k</td>
<td align="left">8.5k</td>
<td align="left">1.9k</td>
<td align="left">24.2k</td>
<td></td>
</tr>
<tr>
<td align="left">Fork</td>
<td align="left">356</td>
<td align="left">1.7k</td>
<td align="left">130[lw1] [PM2]</td>
<td align="left">3.1k</td>
<td></td>
</tr>
<tr>
<td align="left">开发语言</td>
<td align="left">Python</td>
<td align="left">Java</td>
<td align="left">Go</td>
<td align="left">Lua</td>
<td>Java</td>
</tr>
<tr>
<td align="left">基于代理</td>
<td align="left">Envoy</td>
<td align="left">JVM</td>
<td align="left">Envoy</td>
<td align="left">Nginx</td>
<td></td>
</tr>
<tr>
<td align="left">学习曲线</td>
<td align="left">简单</td>
<td align="left">适中</td>
<td align="left">简单</td>
<td align="left">适中</td>
<td></td>
</tr>
<tr>
<td align="left">Kubernetes</td>
<td align="left">原生支持</td>
<td align="left">组件支持</td>
<td align="left">原生支持</td>
<td align="left">插件支持</td>
<td></td>
</tr>
<tr>
<td align="left">规则配置</td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td></td>
</tr>
<tr>
<td align="left">配置语言</td>
<td align="left">yaml</td>
<td align="left">restapi</td>
<td align="left">yaml</td>
<td align="left">admin restapi</td>
<td></td>
</tr>
<tr>
<td align="left">配置服务类型</td>
<td align="left">声明式</td>
<td align="left">命令式</td>
<td align="left">声明式</td>
<td align="left">命令式</td>
<td></td>
</tr>
<tr>
<td align="left">部署</td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td></td>
</tr>
<tr>
<td align="left">Kubernetes</td>
<td align="left">简单</td>
<td align="left">适中</td>
<td align="left">简单</td>
<td align="left">适中</td>
<td></td>
</tr>
<tr>
<td align="left">部署模式</td>
<td align="left">金丝雀/灰度</td>
<td align="left">金丝雀</td>
<td align="left">金丝雀</td>
<td align="left">金丝雀</td>
<td></td>
</tr>
<tr>
<td align="left">配置存储</td>
<td align="left">Kubernetes Etcd组件</td>
<td align="left">内存</td>
<td align="left">Kubernetes Etcd组件</td>
<td align="left">Postgres、Cassandra</td>
<td></td>
</tr>
<tr>
<td align="left">可扩展性</td>
<td align="left">外部集成</td>
<td align="left">插件</td>
<td align="left">插件</td>
<td align="left">插件</td>
<td></td>
</tr>
<tr>
<td align="left">基本功能</td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td></td>
</tr>
<tr>
<td align="left">服务发现</td>
<td align="left">动态</td>
<td align="left">动态</td>
<td align="left">动态</td>
<td align="left">动态</td>
<td></td>
</tr>
<tr>
<td align="left">协议</td>
<td align="left">http、https、grpc、tcp、udp、tcp+ssl</td>
<td align="left">http、https</td>
<td align="left">http、https、grpc</td>
<td align="left">http、https、grpc、tcp、udp</td>
<td></td>
</tr>
<tr>
<td align="left">限速</td>
<td align="left">支持</td>
<td align="left">自开发</td>
<td align="left">支持</td>
<td align="left">支持</td>
<td></td>
</tr>
<tr>
<td align="left">熔断</td>
<td align="left">支持</td>
<td align="left">自开发/组件</td>
<td align="left">支持</td>
<td align="left">支持</td>
<td></td>
</tr>
<tr>
<td align="left">健康检查</td>
<td align="left">支持</td>
<td align="left">自开发/组件</td>
<td align="left">支持</td>
<td align="left">支持</td>
<td></td>
</tr>
<tr>
<td align="left">负载均衡</td>
<td align="left">支持</td>
<td align="left">支持</td>
<td align="left">支持</td>
<td align="left">支持</td>
<td></td>
</tr>
<tr>
<td align="left">Istio集成</td>
<td align="left">支持</td>
<td align="left">不支持</td>
<td align="left">支持</td>
<td align="left">不支持</td>
<td></td>
</tr>
<tr>
<td align="left">Serverless</td>
<td align="left">支持</td>
<td align="left">不支持</td>
<td align="left">支持</td>
<td align="left">插件支持</td>
<td></td>
</tr>
<tr>
<td align="left">安全功能</td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td></td>
</tr>
<tr>
<td align="left">Web应用防火墙</td>
<td align="left">支持</td>
<td align="left">自开发/组件</td>
<td align="left">支持</td>
<td align="left">插件支持</td>
<td></td>
</tr>
<tr>
<td align="left">访问控制</td>
<td align="left">支持[lw3] [PM4]</td>
<td align="left">自开发/组件</td>
<td align="left">支持</td>
<td align="left">插件支持</td>
<td></td>
</tr>
<tr>
<td align="left">基本认证授权</td>
<td align="left">Basic Auth、OIDC</td>
<td align="left">自开发/组件</td>
<td align="left">JWT、API Keys、OPA Authorization、LDAP、Custom Auth  server、Plugin Auth</td>
<td align="left">Basic Auth、HMAC、JWT、Key、LDAP、OAuth 2.0、PASETO、OIDC</td>
<td></td>
</tr>
<tr>
<td align="left">SSL证书管理</td>
<td align="left">支持</td>
<td align="left">自开发/组件</td>
<td align="left">不支持</td>
<td align="left">插件支持</td>
<td></td>
</tr>
<tr>
<td align="left">数据丢失防护</td>
<td align="left">不支持</td>
<td align="left">自开发/组件</td>
<td align="left">支持</td>
<td align="left">不支持</td>
<td></td>
</tr>
<tr>
<td align="left">CORS</td>
<td align="left">支持</td>
<td align="left">自开发/组件</td>
<td align="left">支持</td>
<td align="left">插件支持</td>
<td></td>
</tr>
<tr>
<td align="left">JWT细粒度认证授权</td>
<td align="left">支持</td>
<td align="left">自开发/组件</td>
<td align="left">支持</td>
<td align="left">插件支持</td>
<td></td>
</tr>
<tr>
<td align="left">限速服务</td>
<td align="left">支持</td>
<td align="left">自开发/组件</td>
<td align="left">支持</td>
<td align="left">插件支持</td>
<td></td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>微服务</category>
        <category>网关</category>
      </categories>
      <tags>
        <tag>网关</tag>
        <tag>Zuul</tag>
        <tag>Gateway</tag>
      </tags>
  </entry>
</search>
